<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>数据库 on uh</title>
    <link>https://uhuuh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
    <description>Recent content in 数据库 on uh</description>
    <image>
      <title>uh</title>
      <url>https://uhuuh.github.io/images/papermod-cover.png</url>
      <link>https://uhuuh.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 29 Feb 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://uhuuh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MYSQL</title>
      <link>https://uhuuh.github.io/posts/mysql/</link>
      <pubDate>Thu, 29 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://uhuuh.github.io/posts/mysql/</guid>
      <description>查询优化 表底层使用B+树存储，树的节点是内存页，页内有多条记录，页按照主键值排序。表上的索引也是按照B+树存储，存储索引值和主键值。由于表和索引有类似的结构，表页叫聚簇索引，索引也叫二级索引。查询时使用到了索引，找到索引值和主键值，再根据主键值回聚簇索引找到对应的记录，这个过程叫回表，这也是二级索引名字的由来。 索引本身很复杂，可以有一列或者多列组成，也可以施加非空约束，施加唯一约束。主键实际上就是非空唯一索引 单表查询方法 查询只考虑设计单表，根据查询语句和表上信息可能做出一下区分 单索引时
以下将主键视作非空唯一索引 多列索引当查询中只涉及前面几列时可以利用索引加快查询 查询类型 查询条件 说明 const 非空唯一索引等值查询 只需找到一条记录 ref 索引等值查询 由于索引不唯一，可能找到多条索引 ref_or_null 索引等值或为空查询 range 索引多个搜索区间查询 index 索引复杂查询 复杂查询中可能使用内置函数、多列索引使用后面几列，LIKE操作设定后面字符等。select的列都能在索引中找到 all 索引复杂查询 双索引时
如果可以索引合并
intersection，需要涉及索引顺序与主键一致。实现类似求两个有序数组的交集，不相等时丢掉小的元素，相等时加入结果数组中 union，需要涉及索引顺序与主键一致。实现类似求两个有序数组的并集，不相等时小的元素加入结果集，相等时任意丢掉一个元素 sort-union，不需要涉及索引顺序与主键一致。从A表中取所有合法记录，再从B表中取所有合法记录，两处合法记录排序后合并 否则就全表扫描，index或者all
索引合并时需要索引涉及顺序与主键一致时，常见于等值查询，二级索引等值后再按照主键值排序
==没有sort-intersection==
即便是单表查询，查询语句很复杂，索引也有很多类型，好像很难解析单表查询语句得到具体的执行方法
多表连接 两表连接，实际上定义一个与两表相关联的条件，求满足该条件的两表笛卡尔积子集。实现时一个表A作为驱动表，另一个表B作为被驱动表，每次从A中选择一个记录，再从B中选择满足条件的所有记录。所以驱动表只需要遍历一次，被驱动表要遍历多次 存在四种连接，内连接，左外连接，右外连接，全连接。这些连接在与驱动表的选择和连接条件的处理方式上不同。内连接对于连接条件不满足的记录不会显示在结果表中，其他连接则会，结果表中不满足的地方是空值代替。 sql在on语句中指定连接条件。由于内节点不满足该条件记录不显示结果表中，on作用与where作用一致，故内连接的on语句可以省略。 嵌套循环连接算法 从两表中选择一个查询代价小的表A作为驱动表，根据where中只涉及单表的查询语句进行判断 根据where中只涉及表A的查询语句，每次从驱动表获取一个合法记录 根据where中只涉及表B的查询语句（由于已经确定表A的一个记录，where中涉及两表的查询语句也转化成单表查询语句），每次从被驱动表中获取一个合法记录 依据连接类型和这两个记录是否满足on条件，决定结果是否返回两个记录连接和表B记录是否为空 重复上述过程，直到找到所有连接记录。处于节省内存的考虑，迭代式返回连接记录，但是运算速度稍慢。 基于块的嵌套循环连接算法 一次选择驱动表中多个合法记录，同时与被驱动表中的合法记录进行匹配，加快连接算法 数据库表连接的简单解释 - 阮一峰的网络日志 (ruanyifeng.com) 查询优化 成本主要分为cpu和io成本，cpu成本是判断记录是否满足条件的成本，io成本是读取页的成本
all的成本。聚簇索引页数 * io常数 + 记录总数 * cpu常数，其中依次是加载聚簇索引页、读取聚簇索引页内容的成本 range的成本。扫描区间总页数 * io常数 + 扫描区间总记录数 * cpu常数 + 扫描区间总记录数 * io常数 + 扫描区间总记录数 * cpu常数，其中依次是加载二级索引页，读取二级索引页内容，根据每个二级索引页内容回表时加载聚簇索引页，读取聚簇索引页内容的成本 其中确定扫描总页数。需要根据区间左边界在二级索引中找到对应页，右边界同理。再根据左右边界页向上搜索到公共页，确定左右边界页中间一共有多少页 其中当单点扫描区间太多时，根据表的统计数据确定重复比例，大概确定单点区间中有多少记录和多少页 两表连接的成本。驱动表成本+驱动表合法记录数量 * 被驱动表成本 其中驱动表合法记录数量也叫扇出量 多表连接的成本。如果连接表的数量过少，直接穷举所有可能的连接，阶乘复杂度。否则使用某种启发式搜索算法 事务 事务需要满足一下四大特性</description>
    </item>
    <item>
      <title>数据库原理</title>
      <link>https://uhuuh.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 29 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://uhuuh.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</guid>
      <description>绪论 数据的存储从文件系统过渡到数据库, 数据库相比于文件系统有以下优点
文件系统 数据库 数据结构化 数据描述由应用的程序负责 引入逻辑模型由数据库本身维护数据描述 数据共享和独立性 针对不同的应用使用不同的文件保存数据 所有应用统一保存数据, 不同应用的数据之间尽可能共享, 提供三级模式为不同应用提供数据视图 实体是现实中可区分的事物 实体具有一系列属性来描述自己 码是一个或者多个特殊实体属性, 可以区分一个实体. 实体可能具有多个码 实体之间有联系, 比如实体之间的一一对应, 一对多, 多对一, 多对多 数据是事物的符号化化描述 实体型是一个实体的属性集合, 实体集是同一类型实体型的集合. 实体型和实体集都可视作数据 数据模型用来描述数据, 按不同的层次有以下三种
概念模型, 一般使用ER图, 描述实体有哪些数据和实体之间的联系 逻辑模型, 有对象, 网状和关系多种. 概念模型描述了数据对应实体的属性和实体之间联系, 而逻辑模型进一步规定了数据结构, 数据操作数据完整性约束 物理模型, 进一步确定了数据是如何存储的, ==一般采用三级模式结构== 外模式, 可以为不同的应用提供不同的逻辑视图 模式, 所有数据的统一逻辑视图 内模式, 数据的具体存储方式, 一般多个外模式对应一个模式 , 一个模式对应一个内模式 与书的不同
==数据模型与模式是两个独立的概念, 把模式放在物理模型方面感觉更好些== 数据模型的三要素(数据结构, 操作和完整性约束)也是只放在了逻辑模型中 关系数据库 关系数据库是采用关系逻辑模型的数据库
数据结构
关系是数据的存储方式, 简单来说就是一张表, 表里面保存了一个实体集, 表中每一行是一个实体的各个属性, 同时实体与实体之间的联系也能以关系方式存储, 更形式来说关系是所有属性取值集合的笛卡尔积的子集 关系中有如下概念 域是某个属性的取值集合 候选码是可以标识实体的属性组, 其子集不能标识实体. 一个实体可能有多个候选码, 候选码中可能包含多个属性 主属性是在候选码中的属性, 其他属性是非主属性 数据操作方法</description>
    </item>
    <item>
      <title>读书笔记 mysql是怎样运行的</title>
      <link>https://uhuuh.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/</link>
      <pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://uhuuh.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/</guid>
      <description>4.从一条记录说起 数据库有不同的表组成, 表有不同的列组成, 这一章介绍了列是怎么存储的
一行数据也被成为一条记录, 一行中的不同列也被称为不同的字段
存储引擎. InnoDB是mysql默认的存储引擎, 也是最常用的存储引擎
==逆序存储==
书中介绍要讲到4中行格式, 其中compact和redundant有介绍, dynamic和compressed和compact类似, 但是处理溢出行有些分歧, 然后compressed还会使用压缩算法对行内容进行压缩
隐藏列 row_id 当用户定义表结构时没有确定主键, 并且没有不允许null和unique的列, 自动添加该列作为键 trx_id roll_pointer compact行格式 变长字符长度列表, 所有变长列(下图中的varchar)的长度信息 只存非null的列 长度信息可由多个字节确定, 首先读取一个字节第一位位0说明该字节可以表示完整的长度, 否则记录读取随后的字节. 这种策略类似字符集的变成编码策略 当char类型的列为null时, 不占据实际内存 特别的, 当采用变长编码的字符集时, 定长的一列(char)的长度信息也应该保存到该列表中, 并且该列内容至少分配M(char的长度是M) 特别的, 当长度信息需要大于2字节保存时, 溢出处理 null值列表, 所有可null列的位指示信息 按字节对齐 记录头信息, 由固定的5字节组成, 共40二进制位 redundant行格式 古老的行格式, 在mysql5之前被使用, 相比于compact空间效率更差
字段长度偏移列表 从记录真实数据部分, 各列偏移 根据记录真实数据的总长度确定(从表定义可知, 另外记录头中也有一个位可以知道该信息) 各列偏移量是用1个字节还是2两个字节表示 无论偏移量使用1个字节还是2个字节, 第一位都另做他用, 用来表示该列是否为null 当偏移量需要大于2字节时, 溢出处理 char为null时占据实际的内存, 里面都为0 对于char类型的列和使用变长编码的字符集, 直接为该列分配最大可能得空间 记录头信息, 共使用6字节 溢出列 ==什么时候列太长而需要溢出处理==
在列格式中无论是列的长度还是偏移量, 最多使用2字节(页大小是16KB, 2字节的足以表示这个页面下的长度和偏移)来表示 一页(默认16KB)至少应该能够保存两条记录(要不然失去了平衡树的意义), 可以根据页大小, 页本身的大小计算出列可以的最大长度 当需要更多字节表示时要特殊处理.</description>
    </item>
  </channel>
</rss>
