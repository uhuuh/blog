<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | uh</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - uh">
<meta name="author" content="">
<link rel="canonical" href="https://uhuuh.github.io/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.4599eadb9eb2ad3d0a8d6827b41a8fda8f2f4af226b63466c09c5fddbc8706b7.css" integrity="sha256-RZnq256yrT0KjWgntBqP2o8vSvImtjRmwJxf3byHBrc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://uhuuh.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://uhuuh.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://uhuuh.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://uhuuh.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://uhuuh.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://uhuuh.github.io/posts/index.xml">
<link rel="alternate" hreflang="en" href="https://uhuuh.github.io/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://uhuuh.github.io/posts/" /><meta property="og:image" content="https://uhuuh.github.io/images/papermod-cover.png"/>

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://uhuuh.github.io/images/papermod-cover.png"/>

<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://uhuuh.github.io/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://uhuuh.github.io/" accesskey="h" title="uh (Alt + H)">uh</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://uhuuh.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://uhuuh.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://uhuuh.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://uhuuh.github.io/">Home</a></div>
  <h1>
    Posts
    <a href="/posts/index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">docker
    </h2>
  </header>
  <div class="entry-content">
    <p> (https://www.cnblogs.com/mxnote/p/17101905.html)[docker启动容器后, 马上结束 - MasonLee - 博客园 (cnblogs.com)] 容器中没有一直运行的进程的会自动退出 网络 (Docker的4种网络模式-阿里云开发者社区)[https://developer.aliyun.com/article/653905] 提供如下网络模式
host 与宿主机在一个网络环境 container 与一个容器在一个网络环境 bridge 连接到一个网络空间中。默认模式 none 与外部没有网路连接 bridge模式通信，依靠linux的网络命名空间实现
容器之间通信 运行容器时通过name选项指定主机名，再通过dns解析到合适的容器ip地址 宿主机访问容器 运行容器时通过p选项指定要暴露的端口 容器访问宿主机 通过host.docker.internal域名，再通过dns解析到合适的宿主机环回网卡ip地址 </p>
  </div>
  <footer class="entry-footer"><span title='2024-02-29 00:00:00 +0000 UTC'>February 29, 2024</span>&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to docker" href="https://uhuuh.github.io/posts/docker/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Linux IO模型
    </h2>
  </header>
  <div class="entry-content">
    <p>总览
阻塞就是发起读取数据请求的时，当数据还没准备就绪的时候，这时请求是即刻返回，还是在这里等待数据的就绪，如果需要等待的话就是阻塞，反之如果即刻返回就是非阻塞 在IO模型里面如果请求方从发起请求到数据最后完成的这一段过程中都需要自己参与，那么这种我们就称为同步请求；反之，如果应用发送完指令后就不再参与过程了，只需要等待最终完成结果的通知，那么这就属于异步 阻塞IO
调用read时, 将进程添加进socket的等待队列中 网卡接受到数据时触发中断, 保存网络数据到socket的缓存中, 唤醒等待队列中的进程 非阻塞IO
多路复用IO
select 使用一个位数组保存监听的一系列socket, 该位数组中第i位为1时, 说明监听fd为i的socket 调用时, 将位数组复制到内核中, 依次检查位数组中的有效socket是否有可处理事件, 如果有可处理事件在另一个位数组中好对应的socket, 返回 缺点 监听的socket数量有限, 因为位数组的长度有限, 内核代码有限制位数组的最大长度 调用开销大, 每次调用都需要把位数组复制到内核中 调用时检查开销大, 每次检查时需要依次遍历位数组上的所有有效socket, 其开销与监听的socket呈线性关系 poll 克服了select的第一个缺点, 使用一个链表保存监听所有的socket epoll 在poll的基础上克服了select剩下的第二个和第三个缺点 内核内部维护一个红黑树和一个等待队列, 红黑树保存了d到监听事件的对应关系, 等待队列保存了有效的fd fd有效时, 将该fd添加到等待队列中 信号驱动IO
当数据就绪时, 内核给应用发送一个信号, 应用调用信号处理函数, 该函数中调用read将数据从内核缓存区复制到应用缓存区 异步IO
当数据就绪时, 内核将数据从内核缓存区复制到应用缓存区, 然后给应用发送一个信号 与信号驱动IO区别是, 内核将数据从内核缓存区复制到应用缓存区 问题 为什么select调用时要将位数组复制到内核, 内核使用位数组的指针不行吗? 是出于安全的考虑吗 socket细节, fd细节 参考 看一遍就理解：IO 模型详解-常用的io模型 (51cto.com) 五种IO模型介绍 100%弄明白5种IO模型 - 知乎 (zhihu.com) 最后部分中阻塞与非阻塞介绍, 同步与非同步介绍 IO多路复用——深入浅出理解select、poll、epoll的实现 - 知乎 (zhihu....</p>
  </div>
  <footer class="entry-footer"><span title='2024-02-29 00:00:00 +0000 UTC'>February 29, 2024</span>&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to Linux IO模型" href="https://uhuuh.github.io/posts/linux-io%E6%A8%A1%E5%9E%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">MYSQL
    </h2>
  </header>
  <div class="entry-content">
    <p>查询优化 表底层使用B&#43;树存储，树的节点是内存页，页内有多条记录，页按照主键值排序。表上的索引也是按照B&#43;树存储，存储索引值和主键值。由于表和索引有类似的结构，表页叫聚簇索引，索引也叫二级索引。查询时使用到了索引，找到索引值和主键值，再根据主键值回聚簇索引找到对应的记录，这个过程叫回表，这也是二级索引名字的由来。 索引本身很复杂，可以有一列或者多列组成，也可以施加非空约束，施加唯一约束。主键实际上就是非空唯一索引 单表查询方法 查询只考虑设计单表，根据查询语句和表上信息可能做出一下区分 单索引时
以下将主键视作非空唯一索引 多列索引当查询中只涉及前面几列时可以利用索引加快查询 查询类型 查询条件 说明 const 非空唯一索引等值查询 只需找到一条记录 ref 索引等值查询 由于索引不唯一，可能找到多条索引 ref_or_null 索引等值或为空查询 range 索引多个搜索区间查询 index 索引复杂查询 复杂查询中可能使用内置函数、多列索引使用后面几列，LIKE操作设定后面字符等。select的列都能在索引中找到 all 索引复杂查询 双索引时
如果可以索引合并
intersection，需要涉及索引顺序与主键一致。实现类似求两个有序数组的交集，不相等时丢掉小的元素，相等时加入结果数组中 union，需要涉及索引顺序与主键一致。实现类似求两个有序数组的并集，不相等时小的元素加入结果集，相等时任意丢掉一个元素 sort-union，不需要涉及索引顺序与主键一致。从A表中取所有合法记录，再从B表中取所有合法记录，两处合法记录排序后合并 否则就全表扫描，index或者all
索引合并时需要索引涉及顺序与主键一致时，常见于等值查询，二级索引等值后再按照主键值排序
==没有sort-intersection==
即便是单表查询，查询语句很复杂，索引也有很多类型，好像很难解析单表查询语句得到具体的执行方法
多表连接 两表连接，实际上定义一个与两表相关联的条件，求满足该条件的两表笛卡尔积子集。实现时一个表A作为驱动表，另一个表B作为被驱动表，每次从A中选择一个记录，再从B中选择满足条件的所有记录。所以驱动表只需要遍历一次，被驱动表要遍历多次 存在四种连接，内连接，左外连接，右外连接，全连接。这些连接在与驱动表的选择和连接条件的处理方式上不同。内连接对于连接条件不满足的记录不会显示在结果表中，其他连接则会，结果表中不满足的地方是空值代替。 sql在on语句中指定连接条件。由于内节点不满足该条件记录不显示结果表中，on作用与where作用一致，故内连接的on语句可以省略。 嵌套循环连接算法 从两表中选择一个查询代价小的表A作为驱动表，根据where中只涉及单表的查询语句进行判断 根据where中只涉及表A的查询语句，每次从驱动表获取一个合法记录 根据where中只涉及表B的查询语句（由于已经确定表A的一个记录，where中涉及两表的查询语句也转化成单表查询语句），每次从被驱动表中获取一个合法记录 依据连接类型和这两个记录是否满足on条件，决定结果是否返回两个记录连接和表B记录是否为空 重复上述过程，直到找到所有连接记录。处于节省内存的考虑，迭代式返回连接记录，但是运算速度稍慢。 基于块的嵌套循环连接算法 一次选择驱动表中多个合法记录，同时与被驱动表中的合法记录进行匹配，加快连接算法 数据库表连接的简单解释 - 阮一峰的网络日志 (ruanyifeng.com) 查询优化 成本主要分为cpu和io成本，cpu成本是判断记录是否满足条件的成本，io成本是读取页的成本
all的成本。聚簇索引页数 * io常数 &#43; 记录总数 * cpu常数，其中依次是加载聚簇索引页、读取聚簇索引页内容的成本 range的成本。扫描区间总页数 * io常数 &#43; 扫描区间总记录数 * cpu常数 &#43; 扫描区间总记录数 * io常数 &#43; 扫描区间总记录数 * cpu常数，其中依次是加载二级索引页，读取二级索引页内容，根据每个二级索引页内容回表时加载聚簇索引页，读取聚簇索引页内容的成本 其中确定扫描总页数。需要根据区间左边界在二级索引中找到对应页，右边界同理。再根据左右边界页向上搜索到公共页，确定左右边界页中间一共有多少页 其中当单点扫描区间太多时，根据表的统计数据确定重复比例，大概确定单点区间中有多少记录和多少页 两表连接的成本。驱动表成本&#43;驱动表合法记录数量 * 被驱动表成本 其中驱动表合法记录数量也叫扇出量 多表连接的成本。如果连接表的数量过少，直接穷举所有可能的连接，阶乘复杂度。否则使用某种启发式搜索算法 事务 事务需要满足一下四大特性...</p>
  </div>
  <footer class="entry-footer"><span title='2024-02-29 00:00:00 +0000 UTC'>February 29, 2024</span>&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to MYSQL" href="https://uhuuh.github.io/posts/mysql/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">数据库原理
    </h2>
  </header>
  <div class="entry-content">
    <p>绪论 数据的存储从文件系统过渡到数据库, 数据库相比于文件系统有以下优点
文件系统 数据库 数据结构化 数据描述由应用的程序负责 引入逻辑模型由数据库本身维护数据描述 数据共享和独立性 针对不同的应用使用不同的文件保存数据 所有应用统一保存数据, 不同应用的数据之间尽可能共享, 提供三级模式为不同应用提供数据视图 实体是现实中可区分的事物 实体具有一系列属性来描述自己 码是一个或者多个特殊实体属性, 可以区分一个实体. 实体可能具有多个码 实体之间有联系, 比如实体之间的一一对应, 一对多, 多对一, 多对多 数据是事物的符号化化描述 实体型是一个实体的属性集合, 实体集是同一类型实体型的集合. 实体型和实体集都可视作数据 数据模型用来描述数据, 按不同的层次有以下三种
概念模型, 一般使用ER图, 描述实体有哪些数据和实体之间的联系 逻辑模型, 有对象, 网状和关系多种. 概念模型描述了数据对应实体的属性和实体之间联系, 而逻辑模型进一步规定了数据结构, 数据操作数据完整性约束 物理模型, 进一步确定了数据是如何存储的, ==一般采用三级模式结构== 外模式, 可以为不同的应用提供不同的逻辑视图 模式, 所有数据的统一逻辑视图 内模式, 数据的具体存储方式, 一般多个外模式对应一个模式 , 一个模式对应一个内模式 与书的不同
==数据模型与模式是两个独立的概念, 把模式放在物理模型方面感觉更好些== 数据模型的三要素(数据结构, 操作和完整性约束)也是只放在了逻辑模型中 关系数据库 关系数据库是采用关系逻辑模型的数据库
数据结构
关系是数据的存储方式, 简单来说就是一张表, 表里面保存了一个实体集, 表中每一行是一个实体的各个属性, 同时实体与实体之间的联系也能以关系方式存储, 更形式来说关系是所有属性取值集合的笛卡尔积的子集 关系中有如下概念 域是某个属性的取值集合 候选码是可以标识实体的属性组, 其子集不能标识实体. 一个实体可能有多个候选码, 候选码中可能包含多个属性 主属性是在候选码中的属性, 其他属性是非主属性 数据操作方法...</p>
  </div>
  <footer class="entry-footer"><span title='2024-02-29 00:00:00 +0000 UTC'>February 29, 2024</span>&nbsp;·&nbsp;2 min</footer>
  <a class="entry-link" aria-label="post link to 数据库原理" href="https://uhuuh.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">计算机网络
    </h2>
  </header>
  <div class="entry-content">
    <p> 一个网卡（网络接口，网络适配器）有mac地址、ip地址和子网掩码 在linux中一个有两个网络，一个是虚拟的环回网卡，另一个是可通外网的外网网卡。环回网卡的mac地址全0 在window中好像没有环回网卡，但是环回地址也能正常使用 当socket监听地址为0.0.0.0时，会同时监听来自多个网卡上的数据 局域网数据发送 局域网数据发送有多种实现方式，一般常见是以太网 在以太网中，设备通过总线连接在一起，每个设备有mac地址进行标识 系统上只会使用ip地址进行通信，Address Resolution Protocol协议（arp）可以向机器的ip地址转化为mac地址。 查询arp表如果存在目标ip地址到目标mac地址的映射，同时这个创建时间比较新，使用该映射将目标ip地址转化为目标mac地址 否则发送以太网广播数据包，其中有本机ip，本机mac和目标ip 目标机器接受到该数据包后，存储该发送ip到发送mac的映射到自己的arp表中，同时发送一个单播以太网包，其中包含自己的mac地址。发送方收到该以太网包后，补全相应映射 其他机器接受到该数据包后，仅仅存储发送ip到发送mac的映射到自己arp表中 集线器、网桥、交换机的区别（详解干货！！！） - 知乎 (zhihu.com) 集线器将每个端口与其他端口连接起来，工作在物理层。 网桥和交换器在链路层，可以减少单播消息过程中广播的次数 网桥自动建立转化表。比如当有mac1从port1来，在端口表上建立mac1到port1的映射。如果有一个局域消息是目标地址是mac1，如果转发表中存在相应映射，将其转发到port1，否则对除了发送端口外的其他端口都进行转发 交换器是网桥的细化，在单播消息过程中的广播次数更有效。网桥学习到一个端口中有哪些mac地址，交换机学习到一个端口有哪一个mac地址 互联网数据发送 机器发送 若发送方ip在环回子网中时，数据包发往环回网卡 若发送方ip在同一个子网时，根据arp协议得到对方mac地址，按局域网方式发送 若发送方ip不在同一个子网时，根据arp协议得到网关mac地址，按局域网方式发送 当机器上存在多个网卡时，根据系统配置的路由表决定数据包分发到哪个网卡上，并且其上一般有个默认路由 网关（路由器）转发 查询路由表找到下一跳ip、下一跳mac地址和端口，将数据包中接受方ip转化为下一跳ip后，转发到相应端口按局域网方式发送 显而易见，路由器一般有多个端口，每个端口对应一个网卡 路由器的路由表建立有更复杂的算法 防火墙 防火墙在数据包接受之前提供一种隔离机制，对接受到的数据包进行鉴别和处理，同时可以实现端口转发功能 iptables上记载了一些处理规则 linux网络空间 每个网络空间从逻辑上提供独立的网络协议栈，具体包括网络设备、路由表、arp表、iptables、以及套接字(socket)等 linux本身有default网络空间 linux本身有IP Forwarding功能，其本身可以视作一个路由器，为内部多个网卡之间数据包的转发提供支持 建立veth，可以为不同网络空间中建立连接 建立bridge，同时每个网络空间通过veth连接到该bridge上，可以为多个网络空间之间建立连接 bridge本身可以有一个网卡，并且该网卡也存在于default网络空间中 bridge网卡设定ip地址 连接在bridge上的网络空间将该ip地址设定为网关ip 在default网络空间中设定IP Forwarding，使得连接在bridge上的网络空间可以与default网络空间通信 参考 详细解读Linux网络命名空间，veth， birdge与路由 - 知乎 (zhihu.com) </p>
  </div>
  <footer class="entry-footer"><span title='2024-02-29 00:00:00 +0000 UTC'>February 29, 2024</span>&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to 计算机网络" href="https://uhuuh.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://uhuuh.github.io/posts/page/2/">Next&nbsp;2/3&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://uhuuh.github.io/">uh</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
