<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>设计模式 | uh</title>
<meta name="keywords" content="面向对象编程">
<meta name="description" content="UML类图 ==方法返回类型== 原则 依赖倒置原则: 一般而言, 相关的一些类之间形成模块, 模块之间产生依赖. 高层次的模块依赖低层次模块, 而低层次的模块容易因需求而变动, 进而导致依赖它的整个上游模块变动. 模块之上定义一个稳定的抽象层, 抽象(抽象等价于稳定)之间可以相互依赖. 模块也可以进一步细化到一个类的实现上, 类仅仅依赖抽象(接口或者抽象类) 开放封闭原则: 类不能被修改, 可以被扩展 单一职责原则: 一个类应该仅有一个变化的原因，该变化隐含了它的职责. 类的职责太多意味着这个类更有可能被修改 替换原则: 在代码中的任意地方, 派生类可以替换基类 接口隔离原则: 接口设计应该尽可能小而完备. 接口暴露越多意味接口变动的可能性变多 优先使用组合而不是继承: 组合相比于继承使类之间的耦合更小. 感觉无论是组合和继承都需要依赖另一个对象, 强调组合和继承依赖程度上的区别没有意义, 而应该强调组合和继承在功能上的区别 合成复用原则: 尽量使用合成/聚合的方式，而不是使用继承 对象创建相关 单例 当创建一个对象, 出于性能或者鲁棒性的考虑只需要该对象的一个实例 工厂方法 当创建一个对象, 这个对象可能变动 抽象工厂 当创建一系列相互依赖的对象时, 这些对象可能变动 原型 当创建一个对象时, 直接复制可能更方便时 建造者 当创建一个对象时, 这个对象的创建过程中可能使用到多种可选步骤 接口使用相关 门面 当需要封装一系列对象为子系统时 将一系列功能上相关的对象组成一个子系统, 为该子系统定义稳定的接口 适配器 当使用一个对象适配另一个它没有实现的接口时 装饰器 当给对象原有接口增加新功能时 装饰器模式通过组合和继承实现, 另外有着动态决定对象原有接口新增功能的优点, 具体在main方法中使用一个装饰器对象构造另一个装饰器对象. 如果装饰器模式通过继承实现, 由于装饰器对象继承的基类已经决定, 达不到上述优点 代理 当给对象原有接口访问时增加中间层, 一般为了接口调用的访问控制和缓存等 装饰器模式和代理模式的实现都是基于组合和继承, 由于侧重的使用场景略有不同, 代理模式只有一个代理对象, 装饰器模式可以有多个装饰器, 而多个装饰器之间可以套娃 场景表示相关 复合 当使用对象继承体系表示一个树形事物时 状态 当对象继承体系实现状态机, 避免使用条件语句实现状态机时不好动态添加状态, 需要事先确定改变状态的所有方法 单个状态对象只需要一个实例, 一般命令模式会结合单例模式 状态对象仅仅表示该状态和状态的转移, 一般持有当前状态和负责修改当前状态在另一个对象中 策略 当使用对象表示策略时, 实现策略的运行时可替换 使用上可以等同于一些语言中的函数对象 命令 当使用对象表示请求时, 实现请求的记录和撤销等 官方的UML类图过于理想化 解析器 略, 用的很少 迭代器 当需要提供通用的迭代对象集合的方法时 访问者 当需要给对象集合中添加各种各样的处理对象的方法时 访问器针对不同的元素实现不同的处理 有很大的限制性, 需要对象集合中的对象元素已经确定 中介者 当多个对象相互交互时, 需要修改其中的一个对象时需要改动相互依赖的所有对象 实现时添加一个中介者, 所有对象与中介者交互, 一般修改一个对象时只需要对象改对象和中介者 观察者 当对象的状态变化需要通知其他对象时, 使用该模式后可以增加和删除通知者 责任链 当一个请求有多种处理者时, 使用该模式后动态增加和删除处理者 备忘录 当需要保存与加载对象的状态 略有过时, 现在可以使用对象序列化和反序列化替代 其他 模板方法 当对象方法中某些处理上固定时, 使用该模式后可以只需要实现方法中变化的部分 实现时借助抽象类, 具体要将一个方法拆分成固定和变化两个方法 桥接 当对象继承体系要对应两个维度上的变化时, 比如图形的图形和颜色 如果仅仅使用继承实现的话有子类数量爆炸的问题, 需要结合继承和组合实现.">
<meta name="author" content="">
<link rel="canonical" href="https://uhuuh.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.4599eadb9eb2ad3d0a8d6827b41a8fda8f2f4af226b63466c09c5fddbc8706b7.css" integrity="sha256-RZnq256yrT0KjWgntBqP2o8vSvImtjRmwJxf3byHBrc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://uhuuh.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://uhuuh.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://uhuuh.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://uhuuh.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://uhuuh.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://uhuuh.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="设计模式" />
<meta property="og:description" content="UML类图 ==方法返回类型== 原则 依赖倒置原则: 一般而言, 相关的一些类之间形成模块, 模块之间产生依赖. 高层次的模块依赖低层次模块, 而低层次的模块容易因需求而变动, 进而导致依赖它的整个上游模块变动. 模块之上定义一个稳定的抽象层, 抽象(抽象等价于稳定)之间可以相互依赖. 模块也可以进一步细化到一个类的实现上, 类仅仅依赖抽象(接口或者抽象类) 开放封闭原则: 类不能被修改, 可以被扩展 单一职责原则: 一个类应该仅有一个变化的原因，该变化隐含了它的职责. 类的职责太多意味着这个类更有可能被修改 替换原则: 在代码中的任意地方, 派生类可以替换基类 接口隔离原则: 接口设计应该尽可能小而完备. 接口暴露越多意味接口变动的可能性变多 优先使用组合而不是继承: 组合相比于继承使类之间的耦合更小. 感觉无论是组合和继承都需要依赖另一个对象, 强调组合和继承依赖程度上的区别没有意义, 而应该强调组合和继承在功能上的区别 合成复用原则: 尽量使用合成/聚合的方式，而不是使用继承 对象创建相关 单例 当创建一个对象, 出于性能或者鲁棒性的考虑只需要该对象的一个实例 工厂方法 当创建一个对象, 这个对象可能变动 抽象工厂 当创建一系列相互依赖的对象时, 这些对象可能变动 原型 当创建一个对象时, 直接复制可能更方便时 建造者 当创建一个对象时, 这个对象的创建过程中可能使用到多种可选步骤 接口使用相关 门面 当需要封装一系列对象为子系统时 将一系列功能上相关的对象组成一个子系统, 为该子系统定义稳定的接口 适配器 当使用一个对象适配另一个它没有实现的接口时 装饰器 当给对象原有接口增加新功能时 装饰器模式通过组合和继承实现, 另外有着动态决定对象原有接口新增功能的优点, 具体在main方法中使用一个装饰器对象构造另一个装饰器对象. 如果装饰器模式通过继承实现, 由于装饰器对象继承的基类已经决定, 达不到上述优点 代理 当给对象原有接口访问时增加中间层, 一般为了接口调用的访问控制和缓存等 装饰器模式和代理模式的实现都是基于组合和继承, 由于侧重的使用场景略有不同, 代理模式只有一个代理对象, 装饰器模式可以有多个装饰器, 而多个装饰器之间可以套娃 场景表示相关 复合 当使用对象继承体系表示一个树形事物时 状态 当对象继承体系实现状态机, 避免使用条件语句实现状态机时不好动态添加状态, 需要事先确定改变状态的所有方法 单个状态对象只需要一个实例, 一般命令模式会结合单例模式 状态对象仅仅表示该状态和状态的转移, 一般持有当前状态和负责修改当前状态在另一个对象中 策略 当使用对象表示策略时, 实现策略的运行时可替换 使用上可以等同于一些语言中的函数对象 命令 当使用对象表示请求时, 实现请求的记录和撤销等 官方的UML类图过于理想化 解析器 略, 用的很少 迭代器 当需要提供通用的迭代对象集合的方法时 访问者 当需要给对象集合中添加各种各样的处理对象的方法时 访问器针对不同的元素实现不同的处理 有很大的限制性, 需要对象集合中的对象元素已经确定 中介者 当多个对象相互交互时, 需要修改其中的一个对象时需要改动相互依赖的所有对象 实现时添加一个中介者, 所有对象与中介者交互, 一般修改一个对象时只需要对象改对象和中介者 观察者 当对象的状态变化需要通知其他对象时, 使用该模式后可以增加和删除通知者 责任链 当一个请求有多种处理者时, 使用该模式后动态增加和删除处理者 备忘录 当需要保存与加载对象的状态 略有过时, 现在可以使用对象序列化和反序列化替代 其他 模板方法 当对象方法中某些处理上固定时, 使用该模式后可以只需要实现方法中变化的部分 实现时借助抽象类, 具体要将一个方法拆分成固定和变化两个方法 桥接 当对象继承体系要对应两个维度上的变化时, 比如图形的图形和颜色 如果仅仅使用继承实现的话有子类数量爆炸的问题, 需要结合继承和组合实现." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://uhuuh.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" /><meta property="og:image" content="https://uhuuh.github.io/images/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-22T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-12-22T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://uhuuh.github.io/images/papermod-cover.png"/>

<meta name="twitter:title" content="设计模式"/>
<meta name="twitter:description" content="UML类图 ==方法返回类型== 原则 依赖倒置原则: 一般而言, 相关的一些类之间形成模块, 模块之间产生依赖. 高层次的模块依赖低层次模块, 而低层次的模块容易因需求而变动, 进而导致依赖它的整个上游模块变动. 模块之上定义一个稳定的抽象层, 抽象(抽象等价于稳定)之间可以相互依赖. 模块也可以进一步细化到一个类的实现上, 类仅仅依赖抽象(接口或者抽象类) 开放封闭原则: 类不能被修改, 可以被扩展 单一职责原则: 一个类应该仅有一个变化的原因，该变化隐含了它的职责. 类的职责太多意味着这个类更有可能被修改 替换原则: 在代码中的任意地方, 派生类可以替换基类 接口隔离原则: 接口设计应该尽可能小而完备. 接口暴露越多意味接口变动的可能性变多 优先使用组合而不是继承: 组合相比于继承使类之间的耦合更小. 感觉无论是组合和继承都需要依赖另一个对象, 强调组合和继承依赖程度上的区别没有意义, 而应该强调组合和继承在功能上的区别 合成复用原则: 尽量使用合成/聚合的方式，而不是使用继承 对象创建相关 单例 当创建一个对象, 出于性能或者鲁棒性的考虑只需要该对象的一个实例 工厂方法 当创建一个对象, 这个对象可能变动 抽象工厂 当创建一系列相互依赖的对象时, 这些对象可能变动 原型 当创建一个对象时, 直接复制可能更方便时 建造者 当创建一个对象时, 这个对象的创建过程中可能使用到多种可选步骤 接口使用相关 门面 当需要封装一系列对象为子系统时 将一系列功能上相关的对象组成一个子系统, 为该子系统定义稳定的接口 适配器 当使用一个对象适配另一个它没有实现的接口时 装饰器 当给对象原有接口增加新功能时 装饰器模式通过组合和继承实现, 另外有着动态决定对象原有接口新增功能的优点, 具体在main方法中使用一个装饰器对象构造另一个装饰器对象. 如果装饰器模式通过继承实现, 由于装饰器对象继承的基类已经决定, 达不到上述优点 代理 当给对象原有接口访问时增加中间层, 一般为了接口调用的访问控制和缓存等 装饰器模式和代理模式的实现都是基于组合和继承, 由于侧重的使用场景略有不同, 代理模式只有一个代理对象, 装饰器模式可以有多个装饰器, 而多个装饰器之间可以套娃 场景表示相关 复合 当使用对象继承体系表示一个树形事物时 状态 当对象继承体系实现状态机, 避免使用条件语句实现状态机时不好动态添加状态, 需要事先确定改变状态的所有方法 单个状态对象只需要一个实例, 一般命令模式会结合单例模式 状态对象仅仅表示该状态和状态的转移, 一般持有当前状态和负责修改当前状态在另一个对象中 策略 当使用对象表示策略时, 实现策略的运行时可替换 使用上可以等同于一些语言中的函数对象 命令 当使用对象表示请求时, 实现请求的记录和撤销等 官方的UML类图过于理想化 解析器 略, 用的很少 迭代器 当需要提供通用的迭代对象集合的方法时 访问者 当需要给对象集合中添加各种各样的处理对象的方法时 访问器针对不同的元素实现不同的处理 有很大的限制性, 需要对象集合中的对象元素已经确定 中介者 当多个对象相互交互时, 需要修改其中的一个对象时需要改动相互依赖的所有对象 实现时添加一个中介者, 所有对象与中介者交互, 一般修改一个对象时只需要对象改对象和中介者 观察者 当对象的状态变化需要通知其他对象时, 使用该模式后可以增加和删除通知者 责任链 当一个请求有多种处理者时, 使用该模式后动态增加和删除处理者 备忘录 当需要保存与加载对象的状态 略有过时, 现在可以使用对象序列化和反序列化替代 其他 模板方法 当对象方法中某些处理上固定时, 使用该模式后可以只需要实现方法中变化的部分 实现时借助抽象类, 具体要将一个方法拆分成固定和变化两个方法 桥接 当对象继承体系要对应两个维度上的变化时, 比如图形的图形和颜色 如果仅仅使用继承实现的话有子类数量爆炸的问题, 需要结合继承和组合实现."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://uhuuh.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "设计模式",
      "item": "https://uhuuh.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "设计模式",
  "name": "设计模式",
  "description": "UML类图 ==方法返回类型== 原则 依赖倒置原则: 一般而言, 相关的一些类之间形成模块, 模块之间产生依赖. 高层次的模块依赖低层次模块, 而低层次的模块容易因需求而变动, 进而导致依赖它的整个上游模块变动. 模块之上定义一个稳定的抽象层, 抽象(抽象等价于稳定)之间可以相互依赖. 模块也可以进一步细化到一个类的实现上, 类仅仅依赖抽象(接口或者抽象类) 开放封闭原则: 类不能被修改, 可以被扩展 单一职责原则: 一个类应该仅有一个变化的原因，该变化隐含了它的职责. 类的职责太多意味着这个类更有可能被修改 替换原则: 在代码中的任意地方, 派生类可以替换基类 接口隔离原则: 接口设计应该尽可能小而完备. 接口暴露越多意味接口变动的可能性变多 优先使用组合而不是继承: 组合相比于继承使类之间的耦合更小. 感觉无论是组合和继承都需要依赖另一个对象, 强调组合和继承依赖程度上的区别没有意义, 而应该强调组合和继承在功能上的区别 合成复用原则: 尽量使用合成/聚合的方式，而不是使用继承 对象创建相关 单例 当创建一个对象, 出于性能或者鲁棒性的考虑只需要该对象的一个实例 工厂方法 当创建一个对象, 这个对象可能变动 抽象工厂 当创建一系列相互依赖的对象时, 这些对象可能变动 原型 当创建一个对象时, 直接复制可能更方便时 建造者 当创建一个对象时, 这个对象的创建过程中可能使用到多种可选步骤 接口使用相关 门面 当需要封装一系列对象为子系统时 将一系列功能上相关的对象组成一个子系统, 为该子系统定义稳定的接口 适配器 当使用一个对象适配另一个它没有实现的接口时 装饰器 当给对象原有接口增加新功能时 装饰器模式通过组合和继承实现, 另外有着动态决定对象原有接口新增功能的优点, 具体在main方法中使用一个装饰器对象构造另一个装饰器对象. 如果装饰器模式通过继承实现, 由于装饰器对象继承的基类已经决定, 达不到上述优点 代理 当给对象原有接口访问时增加中间层, 一般为了接口调用的访问控制和缓存等 装饰器模式和代理模式的实现都是基于组合和继承, 由于侧重的使用场景略有不同, 代理模式只有一个代理对象, 装饰器模式可以有多个装饰器, 而多个装饰器之间可以套娃 场景表示相关 复合 当使用对象继承体系表示一个树形事物时 状态 当对象继承体系实现状态机, 避免使用条件语句实现状态机时不好动态添加状态, 需要事先确定改变状态的所有方法 单个状态对象只需要一个实例, 一般命令模式会结合单例模式 状态对象仅仅表示该状态和状态的转移, 一般持有当前状态和负责修改当前状态在另一个对象中 策略 当使用对象表示策略时, 实现策略的运行时可替换 使用上可以等同于一些语言中的函数对象 命令 当使用对象表示请求时, 实现请求的记录和撤销等 官方的UML类图过于理想化 解析器 略, 用的很少 迭代器 当需要提供通用的迭代对象集合的方法时 访问者 当需要给对象集合中添加各种各样的处理对象的方法时 访问器针对不同的元素实现不同的处理 有很大的限制性, 需要对象集合中的对象元素已经确定 中介者 当多个对象相互交互时, 需要修改其中的一个对象时需要改动相互依赖的所有对象 实现时添加一个中介者, 所有对象与中介者交互, 一般修改一个对象时只需要对象改对象和中介者 观察者 当对象的状态变化需要通知其他对象时, 使用该模式后可以增加和删除通知者 责任链 当一个请求有多种处理者时, 使用该模式后动态增加和删除处理者 备忘录 当需要保存与加载对象的状态 略有过时, 现在可以使用对象序列化和反序列化替代 其他 模板方法 当对象方法中某些处理上固定时, 使用该模式后可以只需要实现方法中变化的部分 实现时借助抽象类, 具体要将一个方法拆分成固定和变化两个方法 桥接 当对象继承体系要对应两个维度上的变化时, 比如图形的图形和颜色 如果仅仅使用继承实现的话有子类数量爆炸的问题, 需要结合继承和组合实现.",
  "keywords": [
    "面向对象编程"
  ],
  "articleBody": "UML类图 ==方法返回类型== 原则 依赖倒置原则: 一般而言, 相关的一些类之间形成模块, 模块之间产生依赖. 高层次的模块依赖低层次模块, 而低层次的模块容易因需求而变动, 进而导致依赖它的整个上游模块变动. 模块之上定义一个稳定的抽象层, 抽象(抽象等价于稳定)之间可以相互依赖. 模块也可以进一步细化到一个类的实现上, 类仅仅依赖抽象(接口或者抽象类) 开放封闭原则: 类不能被修改, 可以被扩展 单一职责原则: 一个类应该仅有一个变化的原因，该变化隐含了它的职责. 类的职责太多意味着这个类更有可能被修改 替换原则: 在代码中的任意地方, 派生类可以替换基类 接口隔离原则: 接口设计应该尽可能小而完备. 接口暴露越多意味接口变动的可能性变多 优先使用组合而不是继承: 组合相比于继承使类之间的耦合更小. 感觉无论是组合和继承都需要依赖另一个对象, 强调组合和继承依赖程度上的区别没有意义, 而应该强调组合和继承在功能上的区别 合成复用原则: 尽量使用合成/聚合的方式，而不是使用继承 对象创建相关 单例 当创建一个对象, 出于性能或者鲁棒性的考虑只需要该对象的一个实例 工厂方法 当创建一个对象, 这个对象可能变动 抽象工厂 当创建一系列相互依赖的对象时, 这些对象可能变动 原型 当创建一个对象时, 直接复制可能更方便时 建造者 当创建一个对象时, 这个对象的创建过程中可能使用到多种可选步骤 接口使用相关 门面 当需要封装一系列对象为子系统时 将一系列功能上相关的对象组成一个子系统, 为该子系统定义稳定的接口 适配器 当使用一个对象适配另一个它没有实现的接口时 装饰器 当给对象原有接口增加新功能时 装饰器模式通过组合和继承实现, 另外有着动态决定对象原有接口新增功能的优点, 具体在main方法中使用一个装饰器对象构造另一个装饰器对象. 如果装饰器模式通过继承实现, 由于装饰器对象继承的基类已经决定, 达不到上述优点 代理 当给对象原有接口访问时增加中间层, 一般为了接口调用的访问控制和缓存等 装饰器模式和代理模式的实现都是基于组合和继承, 由于侧重的使用场景略有不同, 代理模式只有一个代理对象, 装饰器模式可以有多个装饰器, 而多个装饰器之间可以套娃 场景表示相关 复合 当使用对象继承体系表示一个树形事物时 状态 当对象继承体系实现状态机, 避免使用条件语句实现状态机时不好动态添加状态, 需要事先确定改变状态的所有方法 单个状态对象只需要一个实例, 一般命令模式会结合单例模式 状态对象仅仅表示该状态和状态的转移, 一般持有当前状态和负责修改当前状态在另一个对象中 策略 当使用对象表示策略时, 实现策略的运行时可替换 使用上可以等同于一些语言中的函数对象 命令 当使用对象表示请求时, 实现请求的记录和撤销等 官方的UML类图过于理想化 解析器 略, 用的很少 迭代器 当需要提供通用的迭代对象集合的方法时 访问者 当需要给对象集合中添加各种各样的处理对象的方法时 访问器针对不同的元素实现不同的处理 有很大的限制性, 需要对象集合中的对象元素已经确定 中介者 当多个对象相互交互时, 需要修改其中的一个对象时需要改动相互依赖的所有对象 实现时添加一个中介者, 所有对象与中介者交互, 一般修改一个对象时只需要对象改对象和中介者 观察者 当对象的状态变化需要通知其他对象时, 使用该模式后可以增加和删除通知者 责任链 当一个请求有多种处理者时, 使用该模式后动态增加和删除处理者 备忘录 当需要保存与加载对象的状态 略有过时, 现在可以使用对象序列化和反序列化替代 其他 模板方法 当对象方法中某些处理上固定时, 使用该模式后可以只需要实现方法中变化的部分 实现时借助抽象类, 具体要将一个方法拆分成固定和变化两个方法 桥接 当对象继承体系要对应两个维度上的变化时, 比如图形的图形和颜色 如果仅仅使用继承实现的话有子类数量爆炸的问题, 需要结合继承和组合实现. 如果先有A维度再有B维度, A维度上变化使用继承表示, 结合B维度上的变化组合A维度基类后用继承表示 享元 当系统中存在大量相同的不可变对象时, 使用该模式可以尽量共享这些不可变对象, 减少程序的内存占用 建立享元工厂, 工厂创建对象时发现过去创建过直接获取 总结 抽象意味着提取一个对象上固定的部分, 可以是方法签名, 也可以是方法具体实现 接口和抽象类作用相同, 它们之间的区别在于抽象的程度不同. 抽象一个对象的时候, 只固定了方法签名的时候使用接口, 同时也固定了某些方法的实现使用抽象类 对象A依赖对象B说明对象A中有使用对象B, 比如对象A的属性, 方法参数, 方法内部new出现对象B 多继承基类有二义性问题, 有同签名的方法但是在两个基类中有不同实现. 所以java不支持多继承, c++虽然支持通过某种方法确定出现二义性时的顺序. 而多继承接口由于接口只有签名没有实现, 不会出现二义性问题, java也支持多继承接口 分解与合并, 运行时绑定 组合等同于委托, 继承等同于扩展 学习过程 简单理解设计模式概念, 写出相应的简单例子 重新整理设计模式的分类, 使用场景 重新理解设计模式的类图 参考 设计模式目录：22种设计模式 (refactoringguru.cn) 图解设计模式 练习有些简单 24.访问器_哔哩哔哩_bilibili geekband的C++设计模式在线课 ",
  "wordCount" : "174",
  "inLanguage": "en",
  "datePublished": "2023-12-22T00:00:00Z",
  "dateModified": "2023-12-22T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://uhuuh.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "uh",
    "logo": {
      "@type": "ImageObject",
      "url": "https://uhuuh.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://uhuuh.github.io/" accesskey="h" title="uh (Alt + H)">uh</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://uhuuh.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://uhuuh.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://uhuuh.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://uhuuh.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://uhuuh.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      设计模式
    </h1>
    <div class="post-meta"><span title='2023-12-22 00:00:00 +0000 UTC'>December 22, 2023</span>&nbsp;·&nbsp;1 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#uml%e7%b1%bb%e5%9b%be" aria-label="UML类图">UML类图</a></li>
                <li>
                    <a href="#%e5%8e%9f%e5%88%99" aria-label="原则">原则</a></li>
                <li>
                    <a href="#%e5%af%b9%e8%b1%a1%e5%88%9b%e5%bb%ba%e7%9b%b8%e5%85%b3" aria-label="对象创建相关">对象创建相关</a><ul>
                        
                <li>
                    <a href="#%e5%8d%95%e4%be%8b" aria-label="单例">单例</a></li>
                <li>
                    <a href="#%e5%b7%a5%e5%8e%82%e6%96%b9%e6%b3%95" aria-label="工厂方法">工厂方法</a></li>
                <li>
                    <a href="#%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82" aria-label="抽象工厂">抽象工厂</a></li>
                <li>
                    <a href="#%e5%8e%9f%e5%9e%8b" aria-label="原型">原型</a></li>
                <li>
                    <a href="#%e5%bb%ba%e9%80%a0%e8%80%85" aria-label="建造者">建造者</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%8e%a5%e5%8f%a3%e4%bd%bf%e7%94%a8%e7%9b%b8%e5%85%b3" aria-label="接口使用相关">接口使用相关</a><ul>
                        
                <li>
                    <a href="#%e9%97%a8%e9%9d%a2" aria-label="门面">门面</a></li>
                <li>
                    <a href="#%e9%80%82%e9%85%8d%e5%99%a8" aria-label="适配器">适配器</a></li>
                <li>
                    <a href="#%e8%a3%85%e9%a5%b0%e5%99%a8" aria-label="装饰器">装饰器</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%90%86" aria-label="代理">代理</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9c%ba%e6%99%af%e8%a1%a8%e7%a4%ba%e7%9b%b8%e5%85%b3" aria-label="场景表示相关">场景表示相关</a><ul>
                        
                <li>
                    <a href="#%e5%a4%8d%e5%90%88" aria-label="复合">复合</a></li>
                <li>
                    <a href="#%e7%8a%b6%e6%80%81" aria-label="状态">状态</a></li>
                <li>
                    <a href="#%e7%ad%96%e7%95%a5" aria-label="策略">策略</a></li>
                <li>
                    <a href="#%e5%91%bd%e4%bb%a4" aria-label="命令">命令</a></li>
                <li>
                    <a href="#%e8%a7%a3%e6%9e%90%e5%99%a8" aria-label="解析器">解析器</a></li>
                <li>
                    <a href="#%e8%bf%ad%e4%bb%a3%e5%99%a8" aria-label="迭代器">迭代器</a></li>
                <li>
                    <a href="#%e8%ae%bf%e9%97%ae%e8%80%85" aria-label="访问者">访问者</a></li>
                <li>
                    <a href="#%e4%b8%ad%e4%bb%8b%e8%80%85" aria-label="中介者">中介者</a></li>
                <li>
                    <a href="#%e8%a7%82%e5%af%9f%e8%80%85" aria-label="观察者">观察者</a></li>
                <li>
                    <a href="#%e8%b4%a3%e4%bb%bb%e9%93%be" aria-label="责任链">责任链</a></li>
                <li>
                    <a href="#%e5%a4%87%e5%bf%98%e5%bd%95" aria-label="备忘录">备忘录</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%85%b6%e4%bb%96" aria-label="其他">其他</a><ul>
                        
                <li>
                    <a href="#%e6%a8%a1%e6%9d%bf%e6%96%b9%e6%b3%95" aria-label="模板方法">模板方法</a></li>
                <li>
                    <a href="#%e6%a1%a5%e6%8e%a5" aria-label="桥接">桥接</a></li>
                <li>
                    <a href="#%e4%ba%ab%e5%85%83" aria-label="享元">享元</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83" aria-label="参考">参考</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="uml类图">UML类图<a hidden class="anchor" aria-hidden="true" href="#uml类图">#</a></h2>
<ul>
<li>==方法返回类型==</li>
</ul>
<h2 id="原则">原则<a hidden class="anchor" aria-hidden="true" href="#原则">#</a></h2>
<ol>
<li>依赖倒置原则: 一般而言, 相关的一些类之间形成模块, 模块之间产生依赖. 高层次的模块依赖低层次模块, 而低层次的模块容易因需求而变动, 进而导致依赖它的整个上游模块变动. 模块之上定义一个稳定的抽象层, 抽象(抽象等价于稳定)之间可以相互依赖. 模块也可以进一步细化到一个类的实现上, 类仅仅依赖抽象(接口或者抽象类)</li>
<li>开放封闭原则: 类不能被修改, 可以被扩展</li>
<li>单一职责原则: 一个类应该仅有一个变化的原因，该变化隐含了它的职责. 类的职责太多意味着这个类更有可能被修改</li>
<li>替换原则: 在代码中的任意地方, 派生类可以替换基类</li>
<li>接口隔离原则: 接口设计应该尽可能小而完备. 接口暴露越多意味接口变动的可能性变多</li>
<li>优先使用组合而不是继承: 组合相比于继承使类之间的耦合更小. 感觉无论是组合和继承都需要依赖另一个对象, 强调组合和继承依赖程度上的区别没有意义, 而应该强调组合和继承在功能上的区别</li>
<li>合成复用原则: 尽量使用合成/聚合的方式，而不是使用继承</li>
</ol>
<h2 id="对象创建相关">对象创建相关<a hidden class="anchor" aria-hidden="true" href="#对象创建相关">#</a></h2>
<h3 id="单例">单例<a hidden class="anchor" aria-hidden="true" href="#单例">#</a></h3>
<ul>
<li>当创建一个对象, 出于性能或者鲁棒性的考虑只需要该对象的一个实例</li>
</ul>
<h3 id="工厂方法">工厂方法<a hidden class="anchor" aria-hidden="true" href="#工厂方法">#</a></h3>
<ul>
<li>当创建一个对象, 这个对象可能变动</li>
</ul>
<h3 id="抽象工厂">抽象工厂<a hidden class="anchor" aria-hidden="true" href="#抽象工厂">#</a></h3>
<ul>
<li>当创建一系列相互依赖的对象时, 这些对象可能变动</li>
</ul>
<h3 id="原型">原型<a hidden class="anchor" aria-hidden="true" href="#原型">#</a></h3>
<ul>
<li>当创建一个对象时, 直接复制可能更方便时</li>
</ul>
<h3 id="建造者">建造者<a hidden class="anchor" aria-hidden="true" href="#建造者">#</a></h3>
<ul>
<li>当创建一个对象时, 这个对象的创建过程中可能使用到多种可选步骤</li>
</ul>
<h2 id="接口使用相关">接口使用相关<a hidden class="anchor" aria-hidden="true" href="#接口使用相关">#</a></h2>
<h3 id="门面">门面<a hidden class="anchor" aria-hidden="true" href="#门面">#</a></h3>
<ul>
<li>当需要封装一系列对象为子系统时</li>
<li>将一系列功能上相关的对象组成一个子系统, 为该子系统定义稳定的接口</li>
</ul>
<h3 id="适配器">适配器<a hidden class="anchor" aria-hidden="true" href="#适配器">#</a></h3>
<ul>
<li>当使用一个对象适配另一个它没有实现的接口时</li>
</ul>
<h3 id="装饰器">装饰器<a hidden class="anchor" aria-hidden="true" href="#装饰器">#</a></h3>
<ul>
<li>当给对象原有接口增加新功能时</li>
<li>装饰器模式通过组合和继承实现, 另外有着动态决定对象原有接口新增功能的优点, 具体在main方法中使用一个装饰器对象构造另一个装饰器对象. 如果装饰器模式通过继承实现, 由于装饰器对象继承的基类已经决定, 达不到上述优点</li>
</ul>
<h3 id="代理">代理<a hidden class="anchor" aria-hidden="true" href="#代理">#</a></h3>
<ul>
<li>当给对象原有接口访问时增加中间层, 一般为了接口调用的访问控制和缓存等</li>
<li>装饰器模式和代理模式的实现都是基于组合和继承, 由于侧重的使用场景略有不同, 代理模式只有一个代理对象, 装饰器模式可以有多个装饰器, 而多个装饰器之间可以套娃</li>
</ul>
<h2 id="场景表示相关">场景表示相关<a hidden class="anchor" aria-hidden="true" href="#场景表示相关">#</a></h2>
<h3 id="复合">复合<a hidden class="anchor" aria-hidden="true" href="#复合">#</a></h3>
<ul>
<li>当使用对象继承体系表示一个树形事物时</li>
</ul>
<h3 id="状态">状态<a hidden class="anchor" aria-hidden="true" href="#状态">#</a></h3>
<ul>
<li>当对象继承体系实现状态机, 避免使用条件语句实现状态机时不好动态添加状态, 需要事先确定改变状态的所有方法</li>
<li>单个状态对象只需要一个实例, 一般命令模式会结合单例模式</li>
<li>状态对象仅仅表示该状态和状态的转移, 一般持有当前状态和负责修改当前状态在另一个对象中</li>
</ul>
<h3 id="策略">策略<a hidden class="anchor" aria-hidden="true" href="#策略">#</a></h3>
<ul>
<li>当使用对象表示策略时, 实现策略的运行时可替换</li>
<li>使用上可以等同于一些语言中的函数对象</li>
</ul>
<h3 id="命令">命令<a hidden class="anchor" aria-hidden="true" href="#命令">#</a></h3>
<ul>
<li>当使用对象表示请求时, 实现请求的记录和撤销等</li>
<li>官方的UML类图过于理想化</li>
</ul>
<h3 id="解析器">解析器<a hidden class="anchor" aria-hidden="true" href="#解析器">#</a></h3>
<ul>
<li>略, 用的很少</li>
</ul>
<h3 id="迭代器">迭代器<a hidden class="anchor" aria-hidden="true" href="#迭代器">#</a></h3>
<ul>
<li>当需要提供通用的迭代对象集合的方法时</li>
</ul>
<h3 id="访问者">访问者<a hidden class="anchor" aria-hidden="true" href="#访问者">#</a></h3>
<ul>
<li>当需要给对象集合中添加各种各样的处理对象的方法时</li>
<li>访问器针对不同的元素实现不同的处理</li>
<li>有很大的限制性, 需要对象集合中的对象元素已经确定</li>
</ul>
<h3 id="中介者">中介者<a hidden class="anchor" aria-hidden="true" href="#中介者">#</a></h3>
<ul>
<li>当多个对象相互交互时, 需要修改其中的一个对象时需要改动相互依赖的所有对象</li>
<li>实现时添加一个中介者, 所有对象与中介者交互, 一般修改一个对象时只需要对象改对象和中介者</li>
</ul>
<h3 id="观察者">观察者<a hidden class="anchor" aria-hidden="true" href="#观察者">#</a></h3>
<ul>
<li>当对象的状态变化需要通知其他对象时, 使用该模式后可以增加和删除通知者</li>
</ul>
<h3 id="责任链">责任链<a hidden class="anchor" aria-hidden="true" href="#责任链">#</a></h3>
<ul>
<li>当一个请求有多种处理者时, 使用该模式后动态增加和删除处理者</li>
</ul>
<h3 id="备忘录">备忘录<a hidden class="anchor" aria-hidden="true" href="#备忘录">#</a></h3>
<ul>
<li>当需要保存与加载对象的状态</li>
<li>略有过时, 现在可以使用对象序列化和反序列化替代</li>
</ul>
<h2 id="其他">其他<a hidden class="anchor" aria-hidden="true" href="#其他">#</a></h2>
<h3 id="模板方法">模板方法<a hidden class="anchor" aria-hidden="true" href="#模板方法">#</a></h3>
<ul>
<li>当对象方法中某些处理上固定时, 使用该模式后可以只需要实现方法中变化的部分</li>
<li>实现时借助抽象类, 具体要将一个方法拆分成固定和变化两个方法</li>
</ul>
<h3 id="桥接">桥接<a hidden class="anchor" aria-hidden="true" href="#桥接">#</a></h3>
<ul>
<li>当对象继承体系要对应两个维度上的变化时, 比如图形的图形和颜色</li>
<li>如果仅仅使用继承实现的话有子类数量爆炸的问题, 需要结合继承和组合实现. 如果先有A维度再有B维度, A维度上变化使用继承表示, 结合B维度上的变化组合A维度基类后用继承表示</li>
</ul>
<h3 id="享元">享元<a hidden class="anchor" aria-hidden="true" href="#享元">#</a></h3>
<ul>
<li>当系统中存在大量相同的不可变对象时, 使用该模式可以尽量共享这些不可变对象, 减少程序的内存占用</li>
<li>建立享元工厂, 工厂创建对象时发现过去创建过直接获取</li>
</ul>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<ul>
<li>抽象意味着提取一个对象上固定的部分, 可以是方法签名, 也可以是方法具体实现</li>
<li>接口和抽象类作用相同, 它们之间的区别在于抽象的程度不同. 抽象一个对象的时候, 只固定了方法签名的时候使用接口, 同时也固定了某些方法的实现使用抽象类</li>
<li>对象A依赖对象B说明对象A中有使用对象B, 比如对象A的属性, 方法参数, 方法内部new出现对象B</li>
<li>多继承基类有二义性问题, 有同签名的方法但是在两个基类中有不同实现. 所以java不支持多继承, c++虽然支持通过某种方法确定出现二义性时的顺序. 而多继承接口由于接口只有签名没有实现, 不会出现二义性问题, java也支持多继承接口</li>
<li>分解与合并, 运行时绑定</li>
<li>组合等同于委托, 继承等同于扩展</li>
<li>学习过程
<ul>
<li>简单理解设计模式概念, 写出相应的简单例子</li>
<li>重新整理设计模式的分类, 使用场景</li>
<li>重新理解设计模式的类图</li>
</ul>
</li>
</ul>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<ul>
<li><a href="https://refactoringguru.cn/design-patterns/catalog">设计模式目录：22种设计模式 (refactoringguru.cn)</a></li>
<li>图解设计模式 练习有些简单</li>
<li><a href="https://www.bilibili.com/video/BV1Yr4y157Ci?p=24&vd_source=f1b7ffa37a1d59bcc4d8eef80521446c">24.访问器_哔哩哔哩_bilibili</a> geekband的C++设计模式在线课</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://uhuuh.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">面向对象编程</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://uhuuh.github.io/posts/rest%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC/">
    <span class="title">« Prev</span>
    <br>
    <span>REST接口设计风格</span>
  </a>
  <a class="next" href="https://uhuuh.github.io/posts/git/">
    <span class="title">Next »</span>
    <br>
    <span>Git</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 设计模式 on x"
            href="https://x.com/intent/tweet/?text=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f&amp;url=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%2f&amp;hashtags=%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8b">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 设计模式 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%2f&amp;title=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f&amp;summary=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f&amp;source=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 设计模式 on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%2f&title=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 设计模式 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 设计模式 on whatsapp"
            href="https://api.whatsapp.com/send?text=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%20-%20https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 设计模式 on telegram"
            href="https://telegram.me/share/url?text=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f&amp;url=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 设计模式 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f&u=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://uhuuh.github.io/">uh</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
