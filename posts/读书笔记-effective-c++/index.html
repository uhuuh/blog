<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>读书笔记 effective C&#43;&#43; | uh</title>
<meta name="keywords" content="cpp, 读书笔记">
<meta name="description" content="让自己习惯c&#43;&#43; 1.c&#43;&#43;是一个语言联邦 c&#43;&#43;支持多种编程泛型, 面向过程, 基于对象, 面向对象, 泛型, 元编程
c&#43;&#43;可以视为一个语言联邦, 由以下四个部分组成
c object oriented c&#43;&#43; template c&#43;&#43; stl 2.替换define 当define一个常量时, 调试不方便, 只剩下数值没有原来的变量名信息
使用const定义全局常量 使用const在类中定义常量 class A { private: static const double a; // 声明, static确保所有类只有一份该变量 } const double A::a = 1.35; // static成员变量必须在类外定义 - 旧式编译器不支持static成员变量在声明时获得初值class A{ private: static const double a; } const double A::a = 1.35; - 然后再类编译又需要一个常量值时(比如确定数组的大小), 可以使用enum hack技术. enum和define有很多相似的地方, enum最后会被替换成int, enum不能取地址class A{ private: enum {n = 5}; int arr[n]; } 当define一个函数时, 写起来很麻烦, 而且容易出错">
<meta name="author" content="">
<link rel="canonical" href="https://uhuuh.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-effective-c&#43;&#43;/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.4599eadb9eb2ad3d0a8d6827b41a8fda8f2f4af226b63466c09c5fddbc8706b7.css" integrity="sha256-RZnq256yrT0KjWgntBqP2o8vSvImtjRmwJxf3byHBrc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://uhuuh.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://uhuuh.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://uhuuh.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://uhuuh.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://uhuuh.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://uhuuh.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-effective-c&#43;&#43;/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="读书笔记 effective C&#43;&#43;" />
<meta property="og:description" content="让自己习惯c&#43;&#43; 1.c&#43;&#43;是一个语言联邦 c&#43;&#43;支持多种编程泛型, 面向过程, 基于对象, 面向对象, 泛型, 元编程
c&#43;&#43;可以视为一个语言联邦, 由以下四个部分组成
c object oriented c&#43;&#43; template c&#43;&#43; stl 2.替换define 当define一个常量时, 调试不方便, 只剩下数值没有原来的变量名信息
使用const定义全局常量 使用const在类中定义常量 class A { private: static const double a; // 声明, static确保所有类只有一份该变量 } const double A::a = 1.35; // static成员变量必须在类外定义 - 旧式编译器不支持static成员变量在声明时获得初值class A{ private: static const double a; } const double A::a = 1.35; - 然后再类编译又需要一个常量值时(比如确定数组的大小), 可以使用enum hack技术. enum和define有很多相似的地方, enum最后会被替换成int, enum不能取地址class A{ private: enum {n = 5}; int arr[n]; } 当define一个函数时, 写起来很麻烦, 而且容易出错" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://uhuuh.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-effective-c&#43;&#43;/" /><meta property="og:image" content="https://uhuuh.github.io/images/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-21T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-09-21T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://uhuuh.github.io/images/papermod-cover.png"/>

<meta name="twitter:title" content="读书笔记 effective C&#43;&#43;"/>
<meta name="twitter:description" content="让自己习惯c&#43;&#43; 1.c&#43;&#43;是一个语言联邦 c&#43;&#43;支持多种编程泛型, 面向过程, 基于对象, 面向对象, 泛型, 元编程
c&#43;&#43;可以视为一个语言联邦, 由以下四个部分组成
c object oriented c&#43;&#43; template c&#43;&#43; stl 2.替换define 当define一个常量时, 调试不方便, 只剩下数值没有原来的变量名信息
使用const定义全局常量 使用const在类中定义常量 class A { private: static const double a; // 声明, static确保所有类只有一份该变量 } const double A::a = 1.35; // static成员变量必须在类外定义 - 旧式编译器不支持static成员变量在声明时获得初值class A{ private: static const double a; } const double A::a = 1.35; - 然后再类编译又需要一个常量值时(比如确定数组的大小), 可以使用enum hack技术. enum和define有很多相似的地方, enum最后会被替换成int, enum不能取地址class A{ private: enum {n = 5}; int arr[n]; } 当define一个函数时, 写起来很麻烦, 而且容易出错"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://uhuuh.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "读书笔记 effective C++",
      "item": "https://uhuuh.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-effective-c++/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "读书笔记 effective C++",
  "name": "读书笔记 effective C\u002b\u002b",
  "description": "让自己习惯c++ 1.c++是一个语言联邦 c++支持多种编程泛型, 面向过程, 基于对象, 面向对象, 泛型, 元编程\nc++可以视为一个语言联邦, 由以下四个部分组成\nc object oriented c++ template c++ stl 2.替换define 当define一个常量时, 调试不方便, 只剩下数值没有原来的变量名信息\n使用const定义全局常量 使用const在类中定义常量 class A { private: static const double a; // 声明, static确保所有类只有一份该变量 } const double A::a = 1.35; // static成员变量必须在类外定义 - 旧式编译器不支持static成员变量在声明时获得初值\rclass A{ private: static const double a; } const double A::a = 1.35; - 然后再类编译又需要一个常量值时(比如确定数组的大小), 可以使用enum hack技术. enum和define有很多相似的地方, enum最后会被替换成int, enum不能取地址\rclass A{ private: enum {n = 5}; int arr[n]; } 当define一个函数时, 写起来很麻烦, 而且容易出错",
  "keywords": [
    "cpp", "读书笔记"
  ],
  "articleBody": "让自己习惯c++ 1.c++是一个语言联邦 c++支持多种编程泛型, 面向过程, 基于对象, 面向对象, 泛型, 元编程\nc++可以视为一个语言联邦, 由以下四个部分组成\nc object oriented c++ template c++ stl 2.替换define 当define一个常量时, 调试不方便, 只剩下数值没有原来的变量名信息\n使用const定义全局常量 使用const在类中定义常量 class A { private: static const double a; // 声明, static确保所有类只有一份该变量 } const double A::a = 1.35; // static成员变量必须在类外定义 - 旧式编译器不支持static成员变量在声明时获得初值\rclass A{ private: static const double a; } const double A::a = 1.35; - 然后再类编译又需要一个常量值时(比如确定数组的大小), 可以使用enum hack技术. enum和define有很多相似的地方, enum最后会被替换成int, enum不能取地址\rclass A{ private: enum {n = 5}; int arr[n]; } 当define一个函数时, 写起来很麻烦, 而且容易出错\n使用template inline函数替代 template\u003ctypename T\u003e inline void max(const T\u0026 a, const T\u0026 b) { return a \u003e b ? a : b; } 3.const用法 指针\nconst Widget* pw; // pw指向的内容不能改变 Widget const * pw; // 和上者一样 Widget * const pw; // pw不能改变指向 const Widget* const pw; std::vector\u003cint\u003e::iterator iter; // 实际上是一个int* const std::vector\u003cint\u003e::const_iterator iter; // const int* const 函数返回值const, 可以在if中的==误写为=时报错\nconst成员函数中禁止修改成员变量\nconst对象只能调用const成员函数, const对象经可于参数传递和返回 使用mutable修饰符使得在const成员函数中可以修改被修饰的==non-static==变量 class A { public: mutable bool a; void fun() const { a = true; // 编译器不报错 } } 与non-const成员函数之间可以重载, 进一步使用类型转换避免const与non-const写两份代码 class A { public: const char\u0026 fun() const { ... } char\u0026 fun() { return const_cast\u003cchar\u0026\u003e(static_cast\u003cconst A\u0026\u003e(*this).fun()); } } ==const_cast==\n4.对象初始化 对于内置类型, c++的c部分为了避免初始化导致的运行时成本, 不进行初始化, 而非c部分则进行. 一个解决办法是再使用该对象前永远初始化\n对于对象, 确保构造函数对对象的每个成员初始化. 构造函数使用初始化列表完成初始化(初始化列表中没有指定的成员变量使用默认构造函数完成初始化, 出于安全性考虑进行为所有成员变量进行初始化操作), 函数内部完成复杂的赋值工作\n初始化列表\n初始化顺序与类中声明顺序有关, 与在列表中的顺序无关 const变量和reference变量必须使用初始化列表进行初始化 ==non-local static对象==\n将non-local static对象放入函数内部, 将其编程local static对象, 并且该函数返回该对象的引用. 这样可以确保调用函数返回的一定是已经初始化的对象, 并且该方法也可以用来实现单例模式\nA\u0026 getA() { static A a; return a; } 构造析构赋值运算 5.对象中默认定义的函数 如果对象自己没有实现的话, 编译器会为对象实现4个public且inline的函数, default构造, 析构, copy构造和copy assignment操作符\n但是存在一些情况, 这些函数不会自动生成, 在代码中调用这些函数的话编译器会报错. 比如如下情况, copy assignment操作符不会自动生成, 因为编译器不能直接给已经完成初始化的const与reference对象进行重新赋值. 另外在派生类集成的基类中copy assignment操作符为private时, 编译器无法直接调用基类的完成基类部分数据的赋值\nclass A { private: int\u0026 a; const int b; } 6.不像使用, 应该明确拒绝自动生成的函数 比如在单例模式中应该使一个对象不能被复制\n通过拒绝主动生成的copy assignment操作符和copy构造, 实现禁止复制\n在private主动声明这两个函数, 但是不定义. 这样代码中有使用对象的复制行为(成员函数和友元函数), 虽然不会报编译错误, 但是会报链接错误 定义一个基类noncopyable, 在private中主动声明这两个函数, 派生类继承该基类 class noncopyable { protected: uncopyable() {} ~uncopyable() {} private: uncopyable(const noncopyable\u0026); uncopyable\u0026 operator=(const noncopyable\u0026); } 7.为多态基类声明virtual析构函数 多态基类说明该基类随后会被继承, 但是继承后的派生类由常常基于引用或者指针向上转型, 这样在转型后的派生类析构时调用的却是基类的析构函数, 使得该派生类只有一部分被析构. 解决方法是将基类的析构函数声明为virtual, 这样即便派生类向上转型后析构时调用的也是派生类的析构函数. 换言之, 如果要继承一个基类, 最好确保基类的析构函数是virtual.\n为了确保所有的对象调用合适的析构函数, 也没有必要析构函数前面都加上virtual, 这会造成对象占用的内存增加(虚表指针增加占用空间), 与一些c代码上的不兼容\n如果一个类中有virtual函数, 说明该类将作为多态基类, 也应该将该类的析构函数也设为virtual\n8.析构函数不应抛出异常 析构函数抛出异常, 可以造成对象析构提前终止, 只释放该对象所拥有的一部分资源\n如果析构函数有可能执行抛出异常的代码, 有以下方案\ncatch到异常后直接abort catch到异常后记录失败记录 将析构函数内可能抛出异常的代码暴露给用户, 析构函数执行时如果该代码还未被用户调用则现在调用, catch到异常后按上两种方法处理. 这个方法较好一点, 将调用这部分危险代码的责任转移到用户 9.不在构造和析构函数中调用虚函数 不应该在基类构造中调用虚函数, 因为在构造过程还未构造完此时对象属于基类而非派生类, 调用的也是基类的虚函数. ==语法上虽然没什么错误, 但是行为和其他语言不一样, 推荐使用==\nclass A { public: A() { fun(); } virtual void fun() const = 0; } class B: A { public: void fun() const {} } 比如在python中, 派生类首先执行基类构造时, 在基类构造就可以执行派生类的重载过的函数\nclass A: def __init__(self) -\u003e None: self.fun2() def fun2(self): print(\"A\") class B(A): def __init__(self) -\u003e None: super().__init__() def fun2(self): print(\"B\") b = B() // 打印B 析构函数不调用虚函数也是同样的道理\n一个缓解办法是, 派生类中初始化基类时主动传入额外信息, 帮助基类无需借用虚函数直接完成构造\n10.operator=返回引用 int a = 1, b = 2, c = 3; (a = b) = c; std::cout \u003c\u003c a \u003c\u003c std::endl; // a == 3 为类重写=操作时也要实现类似的功能, 需要返回一个引用\n11.operator=处理自我赋值 在下面的例子中, 如果this=\u0026rhs会造成pb提前被释放, 导致最终pb指向释放的资料. 简单的解决方法是再开头添加一个if检查(if部分代码取消注释)\nclass Widget { Bitmap* pb; public: Widget\u0026 operator=(const Widget\u0026 rhs) { //if (this == \u0026rhs) { //\treturn *this; //} delete pb; pb = new Bitmap(rhs.pb); return *this; } } 但是仍然存在异常方面的麻烦. 如果new失败赋值操作强制退出时, 将导致此时被赋值对象的pb资源已被释放, 使得该对象再无法使用. 正确的做法是如果资源已经申请成功后再删除旧资源. 另外再实现异常安全的同时, 也能实现自我赋值安全\nclass Widget { Bitmap* pb; public: Widget\u0026 operator=(const Widget\u0026 rhs) { Bitmap* pOrig = pb; pb = new Bitmap(*rhs.pb); delete pOrig; return *this; } } 另一个做法如下所示, 但是作者认为不够简洁\nclass Widget { Bitmap* pb; public: Widget\u0026 operator=(const Widget\u0026 rhs) { Widget temp(rhs); swap(temp); // temp的内容转移到this return *this; }// temp析构函数调用, 其管理的多余资源被释放 } 12.复制对象时不要忘记每个成分 copy构造和copy assignment操作符统称为copying函数. 自己实现copying函数时需要注意, 如果有继承首先需要调用基类的copying, 然后copy自己的成员变量\nclass A { int a; public: A(const A\u0026 x) : a(x.a) {} A\u0026 operator=(const A\u0026 x) { a = x.a; return *this; } } class B: A { int b; public: B(const B\u0026 x): A(x), b(x.b) {} // 有时候基类的成员变量无法访问, 直接调用基类的copying函数进行copy B\u0026 operator=(const B\u0026 x) { A::operator=(x); // 实现copy assignment不应带调用copy构造, 而应该同样使用基类的copy assignment. 实现copy构造时同样如此 b = x.b; return *this; } } 有时候两个copying函数有太多重复的代码, 可以将这部分代码提取出来放入一个init函数中, 而不应该在一个copying函数内部调用另一个copying函数\n资源管理 13.以对象管理资源 资源从操作系统申请后, 将来不用时资源必须归还给操作系统\n申请资源常见的一种做法是通过工厂函数返回指向该资源的指针(函数内部通过new动态申请资源), 但是资源获取方必须负责调用delete释放资源, 由于过早退出等原因这很容易出现问题 利用RAII技术(资源获取的同时初始化), 以一个对象包裹资源指针, 在对象析构的时候自动调用delete释放资源. 早期的auto_ptr(现在的unique_ptr)实现了该操作, 但是为了避免复制auto_ptr导致的资源重复释放, auto_ptr复制都是move, 使得旧auto_ptr不可用 引用型智能指针share_ptr可以实现正常复制, 在指向同一个资源的share_ptr销毁后(即引用计算为0)才会真正的释放资源. 但是share_ptr的使用也存在循环引用问题, 该问题出现后导致资源总不会被释放 在可能出现循环引用的时候, share_ptr与weak_ptr配合使用. weak_ptr基于share_ptr创建, 并不会增加该资源的引用计数, 仅仅可以或者该资源是否已经释放 智能指针析构时仅仅调用delete, 而不会delete[]. 资源数组可以直接使用vector, 或者自定义删除器\n14.在资源管理中小心copying行为 当自己实现资源管理类时, 有时候释放资源不是简单的调用delete, 还有需要小心copying行为, 具体有以下做法\n禁止复制, 重写析构函数 在内部持有一个智能指针, 并且初始化该指针时自定义删除函数 深度复制, 重写析构函数 转移, 重写析构函数 15.在资源管理类中提供原始资源的访问 在资源外面包裹一层管理类的时候, 常常需要访问原始对象, 如下有两种方法, 依情况适用, 一般显示转换比较好\n一种是显示转换, 像智能指针提供get可以获得原始对象的指针 一种是隐式转换, 重写operator函数. 但是也可能造成悬垂引用问题, 资源管理类已经释放资源, 但是由于隐式转换可能使得内部的资源被暴露在释放后还可能被引用 16.成对使用new和delete要采用相同形式 使用new分配一个对象, 相应使用delete释放. 使用new分配一个数组, 相应使用delete []释放. 这二者的区别在于分配拿到的内存块布局不同, 需要调用相应的delete形式进行删除 尽量不要使用typedef一个数组, 可能造成delete不清楚它是一个数组而错用形式 使用数组尽量使用vector, 然后再在外面套一层智能指针 17.以独立语句将newed对象置入智能指针 下面的语句可能造成内存泄露, 因为函数调用时的实参到形参的转换的各部分代码执行顺序是不定的. 可能存在如注释处的执行顺序, 申请完Wdiget对象后, 执行fun时发生异常, 导致Widget不会被释放. 正确的做法是将new处代码单独放置一行\nvoid processWidget(std::share_ptr\u003cWidget\u003e(new Wdiget), fun()) {} // new Widget // fun() // std::share_ptr 设计与声明 18.让接口被正确使用 定义新类约束接口中的数据输入范围 重载操作符, 保证与内置类型一致 工厂函数返回share_ptr可以避免误用 19.设计class犹如设计type 设计class就是设计了一个新type, 需要多加小心, 然后给出了一系列注意点\n20.传递const引用代替值 值传递开销大, 形参的构造和析构 可以正确实现泛化 一般内置类型使用值传递, 并且内置类型占用空间小. 但是当对象占用空间小的时候, 却不一定适合使用值传递, 因为可能该对象有复杂的构造过程(stl中的容器) 引用实际上是指针 21.函数不返回对象引用 返回的引用指向local对象, 会导致从该函数退出后改引用指向已经释放的内存 以值方式返回对象, 让编译器负责优化 22.将成员变量声明为private 有多种好处\n避免牢记在成员后面要不要加括号 对成员变量提供更精确的控制, 可以只读访问, 读写访问 对日后变更影响小 23.使用non-member, non-friend函数替换member函数 考虑要调用该对象的一系列删除方法, 书中推荐第二个做法更好. 因为面向对象编程不仅仅说数据应该和操作函数绑定在一起, 更应该提高数据的封装性. 因为第二种做法每个在对象中增加可以访问数据的成员函数, 说明该方法有更高的封装性\nclass A { public: void clearEverything() {} } void clearEverything(A\u0026 a) { a.clearCache(); a.clearHistory(); a.removeCookies(); } 另外一个推荐的做法是, 把相关类似上面的这种工具函数按照类别放在不同的文件夹中, 但是和对象在同一个命名空间下\n24.所有参数皆需要类型转换, 采用non-member函数 有时候设计一个类表示数值类型时, 在重载运算符时需要所有参数支持隐式类型转换, 为了支持混合算术运算. 这时候成员函数形式的重载操作符不满足要求, 因为成员函数第一个参数是隐含的this, 该参数不能接受隐式类型转换(只有在参数列表中的参数才有可能接受隐式类型转换). 合理的做法是设计一个非成员版本的重载运算符\nRational oneHalf(1, 2); Rational result1 = oneHalf * 2; Rational result1 = 2 * oneHalf; // error 25.写出一个不抛异常的swap函数 普通的swap基于对象的copying函数\n但是有时候对象有特殊设计可以对swap操作进行优化. 比如在pimpl模型下, 实现swap仅仅交换pImpl指针就行 另外基于copying的swap容易抛出异常, 而自己实现的优化swap操作可能仅仅是交互内置类型, 一般不会抛出异常 namesapce std { template\u003ctypename T\u003e void swap(T\u0026 a, T\u0026 b) { T temp(a); a = b; b = temp; } } ==这一条好像没咋看懂==\n具体有以下步骤\n写public的swap成员函数, 不应该抛出异常 同对象所在命名空间提供一个非成员swap, 里面调用对象成员swap 为对象特化std::swap, 调用对象的成员swap 实现 26.延后变量定义的出现时间 如果doSomething函数中没有使用变量a, 当该函数抛出异常的时候a承当了构造和析构成本. 但是将a定义挪到doSomething之后就没有这个问题\nvoid fun() { A a; doSomething(); return a; } 延后对象的定义时, 不仅仅需要尽量延后到使用该变量为止, 更应该延后到获得该对象初始化需要的初值. 因为方法一default构造一个对象, 再通过copy assignment合适的初始化. 方法二直接通过有参构造初始化对象. 一般来说后者比前者效率高\n27.尽量少做转型动作 理论上cpp程序通过编译后, 就不应该有类型错误. 但是实际开发中需要转型, 这也导致了类型错误出现的可能性\n有以下几种转型操作. 尽可能使用==c++风格转型==, 清晰易读, 由于细分为不同的转型编译器更容易识别出使用上的错误\n// c (T)expression; T(expression); // todo 这个也是转型吗, 感觉有时候也算是构造临时对象 //c++ const_cast\u003cT\u003e(expression); // 去掉const dynamic_cast\u003cT\u003e(expression); // 有继承关系的类之间的转型. 唯一旧式c方式无法实现, 并且唯一可能耗费巨大成本的转型 reinterpret_cast\u003cT\u003e(expression); // 低级转型. 实际动作取决于编译器, 使用它意味着代码不可移植 static_cast\u003cT\u003e(expression); // 强迫隐式类型转换 一个使用c旧式转型比较合适的场景\nclass A { public: explicit A(int size); } void fun(const A\u0026 a); fun(A(1));// 人们更喜欢这一种, 感觉上更像是生成临时对象, 而非转型 fun(static_const\u003cA\u003e(1)); 转型可能导致更多的运行成本. 下面显示了两种场景\nint a = 1; double b = a; // int与double的存储空间不同, 值在内存中的放置也不同, 编译器要生成转换的代码 class Derived: public Base1, Base2 {}; Derived d; Base2* pb = \u0026d; // 由于在base1和base2在derived存储在不同部分, 将\u0026d转换为pb可能涉及到指针偏移的计算 转型的一种错误用法. 在派生类中实现方法中先调用基类的方法, 在处理该派生类的部分\nclass Derived:public Base { void fun() { static\u003cWindow\u003e(*this).fun(); // 由于*this实际上生成了一个base对象副本, 而没有修改改派生类上面的base部分 // Base::fun(); // 实际上应该这样使用 // static(this)-\u003efun(); // todo 那这样可以正确调用基类部分的方法吗 // Derived dosomething } } dynamic_cast使用上开销比较大. 由于dynamic_cast的一个很普遍的实现版本, 是基于class的字符串名字进行依次比较. 需要dynamic_cast的一个场景是泛化为base的derived指针, 还原回derived指针, 以调用derived的特定方法. 解决方法是在base中定义一个什么也不做的同签名(与derived对象特定的函数)的virtual函数\n28.避免返回handle指向对象内部成分 const成员函数返回一个handle(指向成员变量的指针, 引用, 或者修改成员变量的函数指针)有多个问题\n不符合const成员函数的直觉, 值的调用方可以通过handle改变对象 改变成员变量的封装性, 由于外部可以通过handle直接改变指向的成员变量, 使得该成员变量从private变成了public 解决的一个简单方法是返回const handle, 但是这样也有问题\n可能造成悬垂引用, 对象内部可能已经销毁handle指向的对象, 但是外部可能还保留该handle, 并且使用它 有时候不得不返回handle, 比如为对象实现=运算符的时候\n29.努力实现异常安全代码 异常安全函数有不泄露资源和不损坏数据两个条件. 一下代码两个条件都不满足\nvoid A::fun(std::string imgSrc) { lock(\u0026mutex); delete bgImage; ++imageChanges; bgImage = new Image(ImgSrc); // new失败后, bgImage指向的数据被删除 unlock(\u0026mutex); // mutex没有被释放 } 异常安全有3个层次\n基本型, ==感觉数据没有完全被删除, 但是数据修改不完整(基本型式什么意思)== 强烈保证, 函数抛出异常后恢复到调用前的状态 不抛出异常 实现强烈保证的异常安全代码, 资源泄露容易通过RAII解决, 比如lock操作使用类封装, 但是数据损坏得通过swap操作, 生成了stack上的临时对象(抛出异常时自动销毁), 在这个临时对象上做修改, 然后swap(要求swap是异常安全的)本身对象和临时对象\nvoid A::fun(std::string imgSrc) { Lock lock(\u0026mutex); Image temp(imgSrc); swap(temp, bgImage); } 但是swap操作带来的高开销和函数内一些其他函数调用的低异常安全保证, 使我们可能不使代码有强烈安全保证\n30.了解inlining inline函数, 定义在class内的成员函数, 默认inline. 可以在函数外添加inline修饰符.\n优点\n像宏一样直接展开函数, 没有调用上的开销, 但是使用代码编写上比宏安全一些 缺点\n但是增加最后代码大小, 可能导致额外的换页行为, 降低缓存的命中率, 带来效率上损失 一般当函数本体比较小而本体简单的时候, 比较适合inline 一旦inline函数有改变, 所有调用该函数的代码都要重新编译. 如果是普通函数, 只需要重新链接 调试器无法处理inline函数 由于在inline是在编译期实现的, 所有需要inline函数完整定义, 而非声明 inline修饰函数只是推荐编译器将该函数inline, 但是某些情况下编译器不能inline函数\n该函数有递归调用 其他地方有使用该函数的指针 31.将文件的编译依存关系降到最低 由于cpp既支持原始类型, 又支持指针和引用. 头文件class的声明中也可能需要对象定义细节(编译器需要确定对象占用的空间大小, 所有需要对象的定义), 需要包含其他对象的头文件, 进而导致之前导入的头文件中些许改变, 所有导入该class声明的头文件的文件需要重新编译. 在其他语言python和java这不是个问题, 因为所有的对象只能通过指针支持, 并且对象都在heap上分配.\n一个解决办法是, 尽量使用对象的指针或者引用, 因为指针的大小是固定的, 对象指针可以通过简单的前向声明解决编译错误\n进一步有所谓的==pimpl模式==, 成员数据保存在另一个对impl对象中(==除了保存数据还会做什么==), 原对象仅仅包含成员函数声明和一个指向impl对象指针的成员变量声明 ==为声明式和定义式提供不同的头文件, 模板也能分为定义和声明== 但是每次成员函数调用都要增加一次解指针操作, impl对象内存动态分配 另一种解决办法是使用接口类, 类中所有的成员函数都是纯虚函数\n由于都是虚函数, 同样需要一层对虚表的简介访问, 另外需要额外的空间存储虚表指针 以上两种方法虽然可降低声明和实现的依赖, 但是带来性能上的消耗, 需要有选择使用\n面向对象设计 32.public继承表示is a关系 public可以实现is a关系. is a关系表示基类可以做的事情, 派生类也一定可以做, 但是反之不成立\n==鸭子型面向对象, 编译型和运行型实现==\n==展示了一个有趣例子, 说明派生类不能像基类那样==\n33.避免遮掩继承而来的名称 在文件中函数作用域的变量会遮蔽全局作用域的变量, 尽管这些变量是不同的类型\ndobule x = 1; void fun() { int x = 2; std::cout \u003c\u003c x \u003c\u003c std::endl; } 在继承的类中也是如此, 如果基类中fun不是虚函数, 而派生类中也定义了fun函数, 派生类中的fun会遮蔽基类)(不管函数签名如何), 使得public 继承带来的is a关系不能成立. 有以下方法解决\nclass Base { public: void fun(int x) {} } class Derived: public Base { public: using Base::fun; // 方法1, 是外部可见 void fun() {} } class Derived: public Base { public: void fun() {Base::fun();} // 方法2, 转交函数, 为旧式编译器上避免变量遮蔽的方法 } ==todo, 子类遮蔽和函数重载和虚函数==\n34.区分接口继承和实现继承 在public继承下\n基类的纯virtual函数, 相当于派生类只继承接口需要自己实现 基类的virtual函数, 相当于派生类继承接口和默认实现, 也可以自己更改实现 基类的普通函数, 相当于派生列继承接口和实现, 不应该改变该函数实现 当基类有virtual函数时, 派生类可能并不想要默认实现, 但是忘记自定义实现带来错误. 以下方法可以强制派生类选择实现\n// 方法1 class A{ public: virtual void fun() = 0; void defaultFun(); } class B: A { public: void fun() { defaultFun(); } } // 方法2 class A{ public: virtual void fun() = 0; } void A::fun() {} class B: A { public: void fun() { A::fun(); } } 35.考虑virtual函数之外的其他选择 将public virtual函数变成private virtual函数, 再定义一个public函数调用private virtual, 这种方法被称为==non virtual interface(NVI)==, 同时这种操作也实现了设计模式中的模板方法模式 传统策略模式通过动态传入一个策略类实现应用不同策略, 策略类中有要执行的虚函数. 代替传入一个函数指针实现策略模式 36.绝不重新定义继承而来的non virtual函数 简而言之如果D中重新定义了fun, pb和pd调用fun都是各自定义的fun\nclass B { public: void fun(); } class D:B { public: void fun(); } D d; D* pd = \u0026d; B* pb = \u0026d; ==不清楚为什么不能==\n37.绝不重新定义继承而来的缺省参数值 简而言之, 虚函数中最好不要定义默认参数. 由于默认参数处于执行效率的考虑是静态绑定, 而虚函数调用是动态绑定. 可能出现如下情况, 调用的fun可能出乎意料\nclass A { public: virtual void draw(Color color=\"red\") const {} } class B { public: virtual void draw(Color color) {} } A* pa = new B(); pa-\u003efun(\"green\"); // 调用B::fun pa-\u003efun(); // 调用A::fun ==默认参数再声明和定义, 默认参数与函数重载的关系==\n38.通过复合构造has a 对象分为两种, 一种对象可以直接对应现实世界中的事物, 另一种只是软件层面上的东西, 比如互斥器等. 前者比较好区分is a与has a关系, 但是后者不好区分is a与has a关系, 后者的has a也能叫做is implemented in terms of(根据某物实现出)\n==没太看懂==\n39.谨慎使用private继承 private可以和组合一样实现is implemented in terms of关系\n==例子没看懂==\n40.谨慎使用多重继承 缺点一, 可能继承而来的多个基类中相同的成员函数, 造成歧义 ==有调用private成员函数的例子没有看懂== 缺点二, 菱形继承例子中造成空间浪费, 但是可用虚继承解决, 但是虚继承带来额外的开销 ==对象模型上虚继承的细节== 多重继承也有优点, 举得例子类似java中可以组合多个接口 泛型编程 41.了解隐式接口和编译期多态 class相当于实现了显示接口(类成员函数定义)和运行期多态(运行时才能确定是哪一个类的虚函数), template相当于实现了隐式接口(只能知道要调用一个类型的那些操作)和编译期多态\n42.了解typename的双重意义 在声明模板参数的时候class与typename没有差别 但是在内部typename用于指出一个模板参数内的名称是类型, 而非其他东西 ==有指出的必要吗, 不能等到实例化的时候一起确定吗== template \u003ctypename T\u003e void fun(T x) { typename T::const_iterator* y; } ==typename不能用在base class list和member initialization list中== 43.学习处理模板化基类内的名称 ==没看懂==\n在模板化派生类中调用基类成员不能通过编译, 有以下三种方法可以改变\nthis指针明显调用 using 基类调用 编译器诊断可以发生在早期, 模板定义时, 也可以发生在晚期, 模板实例化时\n44.将于参数无关的代码抽离template 45.运用模板参数接受所有兼容类型 std::share_ptr\u003cTop\u003e tp = std::share_ptr\u003cMiddle\u003e(new Middle); ==成员函数模板==\n46.需要类型转换时为模板定义非成员函数 47.使用traits class表现类型信息 展示了stl中算法库advance例子使用type trait和函数重载实现编译期的type上if else\n用户类中定义trait class规定的类型 内部类使用trait class从用户类中获取类型信息, 再利用函数重载 48.template模板元编程 ==略==\n定制new和delete 49.了解new handler ",
  "wordCount" : "1345",
  "inLanguage": "en",
  "datePublished": "2023-09-21T00:00:00Z",
  "dateModified": "2023-09-21T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://uhuuh.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-effective-c++/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "uh",
    "logo": {
      "@type": "ImageObject",
      "url": "https://uhuuh.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://uhuuh.github.io/" accesskey="h" title="uh (Alt + H)">uh</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://uhuuh.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://uhuuh.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://uhuuh.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://uhuuh.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://uhuuh.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      读书笔记 effective C&#43;&#43;
    </h1>
    <div class="post-meta"><span title='2023-09-21 00:00:00 +0000 UTC'>September 21, 2023</span>&nbsp;·&nbsp;7 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e8%ae%a9%e8%87%aa%e5%b7%b1%e4%b9%a0%e6%83%afc" aria-label="让自己习惯c&#43;&#43;">让自己习惯c++</a><ul>
                        
                <li>
                    <a href="#1c%e6%98%af%e4%b8%80%e4%b8%aa%e8%af%ad%e8%a8%80%e8%81%94%e9%82%a6" aria-label="1.c&#43;&#43;是一个语言联邦">1.c++是一个语言联邦</a></li>
                <li>
                    <a href="#2%e6%9b%bf%e6%8d%a2define" aria-label="2.替换define">2.替换define</a></li>
                <li>
                    <a href="#3const%e7%94%a8%e6%b3%95" aria-label="3.const用法">3.const用法</a></li>
                <li>
                    <a href="#4%e5%af%b9%e8%b1%a1%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="4.对象初始化">4.对象初始化</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%9e%84%e9%80%a0%e6%9e%90%e6%9e%84%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97" aria-label="构造析构赋值运算">构造析构赋值运算</a><ul>
                        
                <li>
                    <a href="#5%e5%af%b9%e8%b1%a1%e4%b8%ad%e9%bb%98%e8%ae%a4%e5%ae%9a%e4%b9%89%e7%9a%84%e5%87%bd%e6%95%b0" aria-label="5.对象中默认定义的函数">5.对象中默认定义的函数</a></li>
                <li>
                    <a href="#6%e4%b8%8d%e5%83%8f%e4%bd%bf%e7%94%a8-%e5%ba%94%e8%af%a5%e6%98%8e%e7%a1%ae%e6%8b%92%e7%bb%9d%e8%87%aa%e5%8a%a8%e7%94%9f%e6%88%90%e7%9a%84%e5%87%bd%e6%95%b0" aria-label="6.不像使用, 应该明确拒绝自动生成的函数">6.不像使用, 应该明确拒绝自动生成的函数</a></li>
                <li>
                    <a href="#7%e4%b8%ba%e5%a4%9a%e6%80%81%e5%9f%ba%e7%b1%bb%e5%a3%b0%e6%98%8evirtual%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0" aria-label="7.为多态基类声明virtual析构函数">7.为多态基类声明virtual析构函数</a></li>
                <li>
                    <a href="#8%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0%e4%b8%8d%e5%ba%94%e6%8a%9b%e5%87%ba%e5%bc%82%e5%b8%b8" aria-label="8.析构函数不应抛出异常">8.析构函数不应抛出异常</a></li>
                <li>
                    <a href="#9%e4%b8%8d%e5%9c%a8%e6%9e%84%e9%80%a0%e5%92%8c%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0%e4%b8%ad%e8%b0%83%e7%94%a8%e8%99%9a%e5%87%bd%e6%95%b0" aria-label="9.不在构造和析构函数中调用虚函数">9.不在构造和析构函数中调用虚函数</a></li>
                <li>
                    <a href="#10operator%e8%bf%94%e5%9b%9e%e5%bc%95%e7%94%a8" aria-label="10.operator=返回引用">10.operator=返回引用</a></li>
                <li>
                    <a href="#11operator%e5%a4%84%e7%90%86%e8%87%aa%e6%88%91%e8%b5%8b%e5%80%bc" aria-label="11.operator=处理自我赋值">11.operator=处理自我赋值</a></li>
                <li>
                    <a href="#12%e5%a4%8d%e5%88%b6%e5%af%b9%e8%b1%a1%e6%97%b6%e4%b8%8d%e8%a6%81%e5%bf%98%e8%ae%b0%e6%af%8f%e4%b8%aa%e6%88%90%e5%88%86" aria-label="12.复制对象时不要忘记每个成分">12.复制对象时不要忘记每个成分</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86" aria-label="资源管理">资源管理</a><ul>
                        
                <li>
                    <a href="#13%e4%bb%a5%e5%af%b9%e8%b1%a1%e7%ae%a1%e7%90%86%e8%b5%84%e6%ba%90" aria-label="13.以对象管理资源">13.以对象管理资源</a></li>
                <li>
                    <a href="#14%e5%9c%a8%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86%e4%b8%ad%e5%b0%8f%e5%bf%83copying%e8%a1%8c%e4%b8%ba" aria-label="14.在资源管理中小心copying行为">14.在资源管理中小心copying行为</a></li>
                <li>
                    <a href="#15%e5%9c%a8%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86%e7%b1%bb%e4%b8%ad%e6%8f%90%e4%be%9b%e5%8e%9f%e5%a7%8b%e8%b5%84%e6%ba%90%e7%9a%84%e8%ae%bf%e9%97%ae" aria-label="15.在资源管理类中提供原始资源的访问">15.在资源管理类中提供原始资源的访问</a></li>
                <li>
                    <a href="#16%e6%88%90%e5%af%b9%e4%bd%bf%e7%94%a8new%e5%92%8cdelete%e8%a6%81%e9%87%87%e7%94%a8%e7%9b%b8%e5%90%8c%e5%bd%a2%e5%bc%8f" aria-label="16.成对使用new和delete要采用相同形式">16.成对使用new和delete要采用相同形式</a></li>
                <li>
                    <a href="#17%e4%bb%a5%e7%8b%ac%e7%ab%8b%e8%af%ad%e5%8f%a5%e5%b0%86newed%e5%af%b9%e8%b1%a1%e7%bd%ae%e5%85%a5%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88" aria-label="17.以独立语句将newed对象置入智能指针">17.以独立语句将newed对象置入智能指针</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%a3%b0%e6%98%8e" aria-label="设计与声明">设计与声明</a><ul>
                        
                <li>
                    <a href="#18%e8%ae%a9%e6%8e%a5%e5%8f%a3%e8%a2%ab%e6%ad%a3%e7%a1%ae%e4%bd%bf%e7%94%a8" aria-label="18.让接口被正确使用">18.让接口被正确使用</a></li>
                <li>
                    <a href="#19%e8%ae%be%e8%ae%a1class%e7%8a%b9%e5%a6%82%e8%ae%be%e8%ae%a1type" aria-label="19.设计class犹如设计type">19.设计class犹如设计type</a></li>
                <li>
                    <a href="#20%e4%bc%a0%e9%80%92const%e5%bc%95%e7%94%a8%e4%bb%a3%e6%9b%bf%e5%80%bc" aria-label="20.传递const引用代替值">20.传递const引用代替值</a></li>
                <li>
                    <a href="#21%e5%87%bd%e6%95%b0%e4%b8%8d%e8%bf%94%e5%9b%9e%e5%af%b9%e8%b1%a1%e5%bc%95%e7%94%a8" aria-label="21.函数不返回对象引用">21.函数不返回对象引用</a></li>
                <li>
                    <a href="#22%e5%b0%86%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e%e4%b8%baprivate" aria-label="22.将成员变量声明为private">22.将成员变量声明为private</a></li>
                <li>
                    <a href="#23%e4%bd%bf%e7%94%a8non-member-non-friend%e5%87%bd%e6%95%b0%e6%9b%bf%e6%8d%a2member%e5%87%bd%e6%95%b0" aria-label="23.使用non-member, non-friend函数替换member函数">23.使用non-member, non-friend函数替换member函数</a></li>
                <li>
                    <a href="#24%e6%89%80%e6%9c%89%e5%8f%82%e6%95%b0%e7%9a%86%e9%9c%80%e8%a6%81%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2-%e9%87%87%e7%94%a8non-member%e5%87%bd%e6%95%b0" aria-label="24.所有参数皆需要类型转换, 采用non-member函数">24.所有参数皆需要类型转换, 采用non-member函数</a></li>
                <li>
                    <a href="#25%e5%86%99%e5%87%ba%e4%b8%80%e4%b8%aa%e4%b8%8d%e6%8a%9b%e5%bc%82%e5%b8%b8%e7%9a%84swap%e5%87%bd%e6%95%b0" aria-label="25.写出一个不抛异常的swap函数">25.写出一个不抛异常的swap函数</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0" aria-label="实现">实现</a><ul>
                        
                <li>
                    <a href="#26%e5%bb%b6%e5%90%8e%e5%8f%98%e9%87%8f%e5%ae%9a%e4%b9%89%e7%9a%84%e5%87%ba%e7%8e%b0%e6%97%b6%e9%97%b4" aria-label="26.延后变量定义的出现时间">26.延后变量定义的出现时间</a></li>
                <li>
                    <a href="#27%e5%b0%bd%e9%87%8f%e5%b0%91%e5%81%9a%e8%bd%ac%e5%9e%8b%e5%8a%a8%e4%bd%9c" aria-label="27.尽量少做转型动作">27.尽量少做转型动作</a></li>
                <li>
                    <a href="#28%e9%81%bf%e5%85%8d%e8%bf%94%e5%9b%9ehandle%e6%8c%87%e5%90%91%e5%af%b9%e8%b1%a1%e5%86%85%e9%83%a8%e6%88%90%e5%88%86" aria-label="28.避免返回handle指向对象内部成分">28.避免返回handle指向对象内部成分</a></li>
                <li>
                    <a href="#29%e5%8a%aa%e5%8a%9b%e5%ae%9e%e7%8e%b0%e5%bc%82%e5%b8%b8%e5%ae%89%e5%85%a8%e4%bb%a3%e7%a0%81" aria-label="29.努力实现异常安全代码">29.努力实现异常安全代码</a></li>
                <li>
                    <a href="#30%e4%ba%86%e8%a7%a3inlining" aria-label="30.了解inlining">30.了解inlining</a></li>
                <li>
                    <a href="#31%e5%b0%86%e6%96%87%e4%bb%b6%e7%9a%84%e7%bc%96%e8%af%91%e4%be%9d%e5%ad%98%e5%85%b3%e7%b3%bb%e9%99%8d%e5%88%b0%e6%9c%80%e4%bd%8e" aria-label="31.将文件的编译依存关系降到最低">31.将文件的编译依存关系降到最低</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e8%ae%be%e8%ae%a1" aria-label="面向对象设计">面向对象设计</a><ul>
                        
                <li>
                    <a href="#32public%e7%bb%a7%e6%89%bf%e8%a1%a8%e7%a4%bais-a%e5%85%b3%e7%b3%bb" aria-label="32.public继承表示is a关系">32.public继承表示is a关系</a></li>
                <li>
                    <a href="#33%e9%81%bf%e5%85%8d%e9%81%ae%e6%8e%a9%e7%bb%a7%e6%89%bf%e8%80%8c%e6%9d%a5%e7%9a%84%e5%90%8d%e7%a7%b0" aria-label="33.避免遮掩继承而来的名称">33.避免遮掩继承而来的名称</a></li>
                <li>
                    <a href="#34%e5%8c%ba%e5%88%86%e6%8e%a5%e5%8f%a3%e7%bb%a7%e6%89%bf%e5%92%8c%e5%ae%9e%e7%8e%b0%e7%bb%a7%e6%89%bf" aria-label="34.区分接口继承和实现继承">34.区分接口继承和实现继承</a></li>
                <li>
                    <a href="#35%e8%80%83%e8%99%91virtual%e5%87%bd%e6%95%b0%e4%b9%8b%e5%a4%96%e7%9a%84%e5%85%b6%e4%bb%96%e9%80%89%e6%8b%a9" aria-label="35.考虑virtual函数之外的其他选择">35.考虑virtual函数之外的其他选择</a></li>
                <li>
                    <a href="#36%e7%bb%9d%e4%b8%8d%e9%87%8d%e6%96%b0%e5%ae%9a%e4%b9%89%e7%bb%a7%e6%89%bf%e8%80%8c%e6%9d%a5%e7%9a%84non-virtual%e5%87%bd%e6%95%b0" aria-label="36.绝不重新定义继承而来的non virtual函数">36.绝不重新定义继承而来的non virtual函数</a></li>
                <li>
                    <a href="#37%e7%bb%9d%e4%b8%8d%e9%87%8d%e6%96%b0%e5%ae%9a%e4%b9%89%e7%bb%a7%e6%89%bf%e8%80%8c%e6%9d%a5%e7%9a%84%e7%bc%ba%e7%9c%81%e5%8f%82%e6%95%b0%e5%80%bc" aria-label="37.绝不重新定义继承而来的缺省参数值">37.绝不重新定义继承而来的缺省参数值</a></li>
                <li>
                    <a href="#38%e9%80%9a%e8%bf%87%e5%a4%8d%e5%90%88%e6%9e%84%e9%80%a0has-a" aria-label="38.通过复合构造has a">38.通过复合构造has a</a></li>
                <li>
                    <a href="#39%e8%b0%a8%e6%85%8e%e4%bd%bf%e7%94%a8private%e7%bb%a7%e6%89%bf" aria-label="39.谨慎使用private继承">39.谨慎使用private继承</a></li>
                <li>
                    <a href="#40%e8%b0%a8%e6%85%8e%e4%bd%bf%e7%94%a8%e5%a4%9a%e9%87%8d%e7%bb%a7%e6%89%bf" aria-label="40.谨慎使用多重继承">40.谨慎使用多重继承</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%b3%9b%e5%9e%8b%e7%bc%96%e7%a8%8b" aria-label="泛型编程">泛型编程</a><ul>
                        
                <li>
                    <a href="#41%e4%ba%86%e8%a7%a3%e9%9a%90%e5%bc%8f%e6%8e%a5%e5%8f%a3%e5%92%8c%e7%bc%96%e8%af%91%e6%9c%9f%e5%a4%9a%e6%80%81" aria-label="41.了解隐式接口和编译期多态">41.了解隐式接口和编译期多态</a></li>
                <li>
                    <a href="#42%e4%ba%86%e8%a7%a3typename%e7%9a%84%e5%8f%8c%e9%87%8d%e6%84%8f%e4%b9%89" aria-label="42.了解typename的双重意义">42.了解typename的双重意义</a></li>
                <li>
                    <a href="#43%e5%ad%a6%e4%b9%a0%e5%a4%84%e7%90%86%e6%a8%a1%e6%9d%bf%e5%8c%96%e5%9f%ba%e7%b1%bb%e5%86%85%e7%9a%84%e5%90%8d%e7%a7%b0" aria-label="43.学习处理模板化基类内的名称">43.学习处理模板化基类内的名称</a></li>
                <li>
                    <a href="#44%e5%b0%86%e4%ba%8e%e5%8f%82%e6%95%b0%e6%97%a0%e5%85%b3%e7%9a%84%e4%bb%a3%e7%a0%81%e6%8a%bd%e7%a6%bbtemplate" aria-label="44.将于参数无关的代码抽离template">44.将于参数无关的代码抽离template</a></li>
                <li>
                    <a href="#45%e8%bf%90%e7%94%a8%e6%a8%a1%e6%9d%bf%e5%8f%82%e6%95%b0%e6%8e%a5%e5%8f%97%e6%89%80%e6%9c%89%e5%85%bc%e5%ae%b9%e7%b1%bb%e5%9e%8b" aria-label="45.运用模板参数接受所有兼容类型">45.运用模板参数接受所有兼容类型</a></li>
                <li>
                    <a href="#46%e9%9c%80%e8%a6%81%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e6%97%b6%e4%b8%ba%e6%a8%a1%e6%9d%bf%e5%ae%9a%e4%b9%89%e9%9d%9e%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0" aria-label="46.需要类型转换时为模板定义非成员函数">46.需要类型转换时为模板定义非成员函数</a></li>
                <li>
                    <a href="#47%e4%bd%bf%e7%94%a8traits-class%e8%a1%a8%e7%8e%b0%e7%b1%bb%e5%9e%8b%e4%bf%a1%e6%81%af" aria-label="47.使用traits class表现类型信息">47.使用traits class表现类型信息</a></li>
                <li>
                    <a href="#48template%e6%a8%a1%e6%9d%bf%e5%85%83%e7%bc%96%e7%a8%8b" aria-label="48.template模板元编程">48.template模板元编程</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%9a%e5%88%b6new%e5%92%8cdelete" aria-label="定制new和delete">定制new和delete</a><ul>
                        
                <li>
                    <a href="#49%e4%ba%86%e8%a7%a3new-handler" aria-label="49.了解new handler">49.了解new handler</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="让自己习惯c">让自己习惯c++<a hidden class="anchor" aria-hidden="true" href="#让自己习惯c">#</a></h2>
<h3 id="1c是一个语言联邦">1.c++是一个语言联邦<a hidden class="anchor" aria-hidden="true" href="#1c是一个语言联邦">#</a></h3>
<p>c++支持多种编程泛型, 面向过程, 基于对象, 面向对象, 泛型, 元编程</p>
<p>c++可以视为一个语言联邦, 由以下四个部分组成</p>
<ul>
<li>c</li>
<li>object oriented c++</li>
<li>template c++</li>
<li>stl</li>
</ul>
<h3 id="2替换define">2.替换define<a hidden class="anchor" aria-hidden="true" href="#2替换define">#</a></h3>
<p>当define一个常量时, 调试不方便, 只剩下数值没有原来的变量名信息</p>
<ul>
<li>使用const定义全局常量</li>
<li>使用const在类中定义常量</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">static</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// 声明, static确保所有类只有一份该变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">double</span> <span class="n">A</span><span class="o">::</span><span class="n">a</span> <span class="o">=</span> <span class="mf">1.35</span><span class="p">;</span> <span class="c1">// static成员变量必须在类外定义
</span></span></span></code></pre></div><pre><code>- 旧式编译器不支持static成员变量在声明时获得初值
</code></pre>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">static</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">double</span> <span class="n">A</span><span class="o">::</span><span class="n">a</span> <span class="o">=</span> <span class="mf">1.35</span><span class="p">;</span>
</span></span></code></pre></div><pre><code>- 然后再类编译又需要一个常量值时(比如确定数组的大小), 可以使用enum hack技术. enum和define有很多相似的地方, enum最后会被替换成int, enum不能取地址
</code></pre>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">enum</span> <span class="p">{</span><span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>当define一个函数时, 写起来很麻烦, 而且容易出错</p>
<ul>
<li>使用template inline函数替代</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">void</span> <span class="n">max</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="3const用法">3.const用法<a hidden class="anchor" aria-hidden="true" href="#3const用法">#</a></h3>
<p>指针</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">Widget</span><span class="o">*</span> <span class="n">pw</span><span class="p">;</span> <span class="c1">// pw指向的内容不能改变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="k">const</span> <span class="o">*</span> <span class="n">pw</span><span class="p">;</span> <span class="c1">// 和上者一样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Widget</span> <span class="o">*</span> <span class="k">const</span> <span class="n">pw</span><span class="p">;</span> <span class="c1">// pw不能改变指向
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="n">Widget</span><span class="o">*</span> <span class="k">const</span> <span class="n">pw</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">;</span> <span class="c1">// 实际上是一个int* const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">iter</span><span class="p">;</span> <span class="c1">// const int* const
</span></span></span></code></pre></div><p>函数返回值const, 可以在if中的<code>==</code>误写为<code>=</code>时报错</p>
<p>const成员函数中禁止修改成员变量</p>
<ul>
<li>const对象只能调用const成员函数, const对象经可于参数传递和返回</li>
<li>使用mutable修饰符使得在const成员函数中可以修改被修饰的==non-static==变量</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">mutable</span> <span class="kt">bool</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">fun</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">a</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 编译器不报错 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>与non-const成员函数之间可以重载, 进一步使用类型转换避免const与non-const写两份代码</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">const</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="n">fun</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="p">...</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span><span class="o">&amp;</span> <span class="n">fun</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">fun</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>==const_cast==</p>
<h3 id="4对象初始化">4.对象初始化<a hidden class="anchor" aria-hidden="true" href="#4对象初始化">#</a></h3>
<p>对于内置类型, c++的c部分为了避免初始化导致的运行时成本, 不进行初始化, 而非c部分则进行. 一个解决办法是再使用该对象前永远初始化</p>
<p>对于对象, 确保构造函数对对象的每个成员初始化. 构造函数使用初始化列表完成初始化(初始化列表中没有指定的成员变量使用默认构造函数完成初始化, 出于安全性考虑进行为所有成员变量进行初始化操作), 函数内部完成复杂的赋值工作</p>
<p>初始化列表</p>
<ul>
<li>初始化顺序与类中声明顺序有关, 与在列表中的顺序无关</li>
<li>const变量和reference变量必须使用初始化列表进行初始化</li>
</ul>
<p>==non-local static对象==</p>
<p>将non-local static对象放入函数内部, 将其编程local static对象, 并且该函数返回该对象的引用. 这样可以确保调用函数返回的一定是已经初始化的对象, 并且该方法也可以用来实现单例模式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">A</span><span class="o">&amp;</span> <span class="n">getA</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">static</span> <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="构造析构赋值运算">构造析构赋值运算<a hidden class="anchor" aria-hidden="true" href="#构造析构赋值运算">#</a></h2>
<h3 id="5对象中默认定义的函数">5.对象中默认定义的函数<a hidden class="anchor" aria-hidden="true" href="#5对象中默认定义的函数">#</a></h3>
<p>如果对象自己没有实现的话, 编译器会为对象实现4个public且inline的函数, default构造, 析构, copy构造和copy assignment操作符</p>
<p>但是存在一些情况, 这些函数不会自动生成, 在代码中调用这些函数的话编译器会报错. 比如如下情况, copy assignment操作符不会自动生成, 因为编译器不能直接给已经完成初始化的const与reference对象进行重新赋值. 另外在派生类集成的基类中copy assignment操作符为private时, 编译器无法直接调用基类的完成基类部分数据的赋值</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">const</span> <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="6不像使用-应该明确拒绝自动生成的函数">6.不像使用, 应该明确拒绝自动生成的函数<a hidden class="anchor" aria-hidden="true" href="#6不像使用-应该明确拒绝自动生成的函数">#</a></h3>
<p>比如在单例模式中应该使一个对象不能被复制</p>
<p>通过拒绝主动生成的copy assignment操作符和copy构造, 实现禁止复制</p>
<ul>
<li>在private主动声明这两个函数, 但是不定义. 这样代码中有使用对象的复制行为(成员函数和友元函数), 虽然不会报编译错误, 但是会报链接错误</li>
<li>定义一个基类noncopyable, 在private中主动声明这两个函数, 派生类继承该基类</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">noncopyable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">uncopyable</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="o">~</span><span class="n">uncopyable</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">uncopyable</span><span class="p">(</span><span class="k">const</span> <span class="n">noncopyable</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">uncopyable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">noncopyable</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="7为多态基类声明virtual析构函数">7.为多态基类声明virtual析构函数<a hidden class="anchor" aria-hidden="true" href="#7为多态基类声明virtual析构函数">#</a></h3>
<p>多态基类说明该基类随后会被继承, 但是继承后的派生类由常常基于引用或者指针向上转型, 这样在转型后的派生类析构时调用的却是基类的析构函数, 使得该派生类只有一部分被析构. 解决方法是将基类的析构函数声明为virtual, 这样即便派生类向上转型后析构时调用的也是派生类的析构函数. 换言之, 如果要继承一个基类, 最好确保基类的析构函数是virtual.</p>
<p>为了确保所有的对象调用合适的析构函数, 也没有必要析构函数前面都加上virtual, 这会造成对象占用的内存增加(虚表指针增加占用空间), 与一些c代码上的不兼容</p>
<p>如果一个类中有virtual函数, 说明该类将作为多态基类, 也应该将该类的析构函数也设为virtual</p>
<h3 id="8析构函数不应抛出异常">8.析构函数不应抛出异常<a hidden class="anchor" aria-hidden="true" href="#8析构函数不应抛出异常">#</a></h3>
<p>析构函数抛出异常, 可以造成对象析构提前终止, 只释放该对象所拥有的一部分资源</p>
<p>如果析构函数有可能执行抛出异常的代码, 有以下方案</p>
<ul>
<li>catch到异常后直接abort</li>
<li>catch到异常后记录失败记录</li>
<li>将析构函数内可能抛出异常的代码暴露给用户, 析构函数执行时如果该代码还未被用户调用则现在调用, catch到异常后按上两种方法处理. 这个方法较好一点, 将调用这部分危险代码的责任转移到用户</li>
</ul>
<h3 id="9不在构造和析构函数中调用虚函数">9.不在构造和析构函数中调用虚函数<a hidden class="anchor" aria-hidden="true" href="#9不在构造和析构函数中调用虚函数">#</a></h3>
<p>不应该在基类构造中调用虚函数, 因为在构造过程还未构造完此时对象属于基类而非派生类, 调用的也是基类的虚函数. ==语法上虽然没什么错误, 但是行为和其他语言不一样, 推荐使用==</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">A</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">fun</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">fun</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="n">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="n">fun</span><span class="p">()</span> <span class="k">const</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>比如在python中, 派生类首先执行基类构造时, 在基类构造就可以执行派生类的重载过的函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">fun2</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">fun2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;A&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">fun2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;B&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span> <span class="o">//</span> <span class="n">打印B</span>
</span></span></code></pre></div><p>析构函数不调用虚函数也是同样的道理</p>
<p>一个缓解办法是, 派生类中初始化基类时主动传入额外信息, 帮助基类无需借用虚函数直接完成构造</p>
<h3 id="10operator返回引用">10.operator=返回引用<a hidden class="anchor" aria-hidden="true" href="#10operator返回引用">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// a == 3
</span></span></span></code></pre></div><p>为类重写=操作时也要实现类似的功能, 需要返回一个引用</p>
<h3 id="11operator处理自我赋值">11.operator=处理自我赋值<a hidden class="anchor" aria-hidden="true" href="#11operator处理自我赋值">#</a></h3>
<p>在下面的例子中, 如果this=&amp;rhs会造成pb提前被释放, 导致最终pb指向释放的资料. 简单的解决方法是再开头添加一个if检查(if部分代码取消注释)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Bitmap</span><span class="o">*</span> <span class="n">pb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//if (this == &amp;rhs) {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//	return *this;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">delete</span> <span class="n">pb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">pb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bitmap</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">pb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>但是仍然存在异常方面的麻烦. 如果new失败赋值操作强制退出时, 将导致此时被赋值对象的pb资源已被释放, 使得该对象再无法使用. 正确的做法是如果资源已经申请成功后再删除旧资源. 另外再实现异常安全的同时, 也能实现自我赋值安全</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Bitmap</span><span class="o">*</span> <span class="n">pb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">Bitmap</span><span class="o">*</span> <span class="n">pOrig</span> <span class="o">=</span> <span class="n">pb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">pb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bitmap</span><span class="p">(</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">pb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">delete</span> <span class="n">pOrig</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>另一个做法如下所示, 但是作者认为不够简洁</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Bitmap</span><span class="o">*</span> <span class="n">pb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Widget</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">Widget</span> <span class="nf">temp</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">swap</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span> <span class="c1">// temp的内容转移到this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">	<span class="p">}</span><span class="c1">// temp析构函数调用, 其管理的多余资源被释放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="12复制对象时不要忘记每个成分">12.复制对象时不要忘记每个成分<a hidden class="anchor" aria-hidden="true" href="#12复制对象时不要忘记每个成分">#</a></h3>
<p>copy构造和copy assignment操作符统称为copying函数. 自己实现copying函数时需要注意, 如果有继承首先需要调用基类的copying, 然后copy自己的成员变量</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">		<span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="n">A</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">a</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="n">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">B</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">		<span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">b</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// 有时候基类的成员变量无法访问, 直接调用基类的copying函数进行copy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">B</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">A</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// 实现copy assignment不应带调用copy构造, 而应该同样使用基类的copy assignment. 实现copy构造时同样如此
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">b</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>有时候两个copying函数有太多重复的代码, 可以将这部分代码提取出来放入一个init函数中, 而不应该在一个copying函数内部调用另一个copying函数</p>
<h2 id="资源管理">资源管理<a hidden class="anchor" aria-hidden="true" href="#资源管理">#</a></h2>
<h3 id="13以对象管理资源">13.以对象管理资源<a hidden class="anchor" aria-hidden="true" href="#13以对象管理资源">#</a></h3>
<p>资源从操作系统申请后, 将来不用时资源必须归还给操作系统</p>
<ul>
<li>申请资源常见的一种做法是通过工厂函数返回指向该资源的指针(函数内部通过new动态申请资源), 但是资源获取方必须负责调用delete释放资源, 由于过早退出等原因这很容易出现问题</li>
<li>利用RAII技术(资源获取的同时初始化), 以一个对象包裹资源指针, 在对象析构的时候自动调用delete释放资源. 早期的auto_ptr(现在的unique_ptr)实现了该操作, 但是为了避免复制auto_ptr导致的资源重复释放, auto_ptr复制都是move, 使得旧auto_ptr不可用</li>
<li>引用型智能指针share_ptr可以实现正常复制, 在指向同一个资源的share_ptr销毁后(即引用计算为0)才会真正的释放资源. 但是share_ptr的使用也存在循环引用问题, 该问题出现后导致资源总不会被释放</li>
<li>在可能出现循环引用的时候, share_ptr与weak_ptr配合使用. weak_ptr基于share_ptr创建, 并不会增加该资源的引用计数, 仅仅可以或者该资源是否已经释放</li>
</ul>
<p>智能指针析构时仅仅调用delete, 而不会<code>delete[]</code>. 资源数组可以直接使用vector, 或者自定义删除器</p>
<h3 id="14在资源管理中小心copying行为">14.在资源管理中小心copying行为<a hidden class="anchor" aria-hidden="true" href="#14在资源管理中小心copying行为">#</a></h3>
<p>当自己实现资源管理类时, 有时候释放资源不是简单的调用delete, 还有需要小心copying行为, 具体有以下做法</p>
<ul>
<li>禁止复制, 重写析构函数</li>
<li>在内部持有一个智能指针, 并且初始化该指针时自定义删除函数</li>
<li>深度复制, 重写析构函数</li>
<li>转移, 重写析构函数</li>
</ul>
<h3 id="15在资源管理类中提供原始资源的访问">15.在资源管理类中提供原始资源的访问<a hidden class="anchor" aria-hidden="true" href="#15在资源管理类中提供原始资源的访问">#</a></h3>
<p>在资源外面包裹一层管理类的时候, 常常需要访问原始对象, 如下有两种方法, 依情况适用, 一般显示转换比较好</p>
<ul>
<li>一种是显示转换, 像智能指针提供get可以获得原始对象的指针</li>
<li>一种是隐式转换, 重写operator函数. 但是也可能造成悬垂引用问题, 资源管理类已经释放资源, 但是由于隐式转换可能使得内部的资源被暴露在释放后还可能被引用</li>
</ul>
<h3 id="16成对使用new和delete要采用相同形式">16.成对使用new和delete要采用相同形式<a hidden class="anchor" aria-hidden="true" href="#16成对使用new和delete要采用相同形式">#</a></h3>
<ul>
<li>使用new分配一个对象, 相应使用delete释放. 使用new分配一个数组, 相应使用<code>delete []</code>释放. 这二者的区别在于分配拿到的内存块布局不同, 需要调用相应的delete形式进行删除</li>
<li>尽量不要使用typedef一个数组, 可能造成delete不清楚它是一个数组而错用形式</li>
<li>使用数组尽量使用vector, 然后再在外面套一层智能指针</li>
</ul>
<h3 id="17以独立语句将newed对象置入智能指针">17.以独立语句将newed对象置入智能指针<a hidden class="anchor" aria-hidden="true" href="#17以独立语句将newed对象置入智能指针">#</a></h3>
<p>下面的语句可能造成内存泄露, 因为函数调用时的实参到形参的转换的各部分代码执行顺序是不定的. 可能存在如注释处的执行顺序, 申请完Wdiget对象后, 执行fun时发生异常, 导致Widget不会被释放. 正确的做法是将new处代码单独放置一行</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">processWidget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">share_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Wdiget</span><span class="p">),</span> <span class="n">fun</span><span class="p">())</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// new Widget
</span></span></span><span class="line"><span class="cl"><span class="c1">// fun()
</span></span></span><span class="line"><span class="cl"><span class="c1">// std::share_ptr
</span></span></span></code></pre></div><h2 id="设计与声明">设计与声明<a hidden class="anchor" aria-hidden="true" href="#设计与声明">#</a></h2>
<h3 id="18让接口被正确使用">18.让接口被正确使用<a hidden class="anchor" aria-hidden="true" href="#18让接口被正确使用">#</a></h3>
<ul>
<li>定义新类约束接口中的数据输入范围</li>
<li>重载操作符, 保证与内置类型一致</li>
<li>工厂函数返回share_ptr可以避免误用</li>
</ul>
<h3 id="19设计class犹如设计type">19.设计class犹如设计type<a hidden class="anchor" aria-hidden="true" href="#19设计class犹如设计type">#</a></h3>
<p>设计class就是设计了一个新type, 需要多加小心, 然后给出了一系列注意点</p>
<h3 id="20传递const引用代替值">20.传递const引用代替值<a hidden class="anchor" aria-hidden="true" href="#20传递const引用代替值">#</a></h3>
<ul>
<li>值传递开销大, 形参的构造和析构</li>
<li>可以正确实现泛化</li>
<li>一般内置类型使用值传递, 并且内置类型占用空间小. 但是当对象占用空间小的时候, 却不一定适合使用值传递, 因为可能该对象有复杂的构造过程(stl中的容器)</li>
<li>引用实际上是指针</li>
</ul>
<h3 id="21函数不返回对象引用">21.函数不返回对象引用<a hidden class="anchor" aria-hidden="true" href="#21函数不返回对象引用">#</a></h3>
<ul>
<li>返回的引用指向local对象, 会导致从该函数退出后改引用指向已经释放的内存</li>
<li>以值方式返回对象, 让编译器负责优化</li>
</ul>
<h3 id="22将成员变量声明为private">22.将成员变量声明为private<a hidden class="anchor" aria-hidden="true" href="#22将成员变量声明为private">#</a></h3>
<p>有多种好处</p>
<ul>
<li>避免牢记在成员后面要不要加括号</li>
<li>对成员变量提供更精确的控制, 可以只读访问, 读写访问</li>
<li>对日后变更影响小</li>
</ul>
<h3 id="23使用non-member-non-friend函数替换member函数">23.使用non-member, non-friend函数替换member函数<a hidden class="anchor" aria-hidden="true" href="#23使用non-member-non-friend函数替换member函数">#</a></h3>
<p>考虑要调用该对象的一系列删除方法, 书中推荐第二个做法更好. 因为面向对象编程不仅仅说数据应该和操作函数绑定在一起, 更应该提高数据的封装性. 因为第二种做法每个在对象中增加可以访问数据的成员函数, 说明该方法有更高的封装性</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="n">clearEverything</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">clearEverything</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">a</span><span class="p">.</span><span class="n">clearCache</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">a</span><span class="p">.</span><span class="n">clearHistory</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">a</span><span class="p">.</span><span class="n">removeCookies</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>另外一个推荐的做法是, 把相关类似上面的这种工具函数按照类别放在不同的文件夹中, 但是和对象在同一个命名空间下</p>
<h3 id="24所有参数皆需要类型转换-采用non-member函数">24.所有参数皆需要类型转换, 采用non-member函数<a hidden class="anchor" aria-hidden="true" href="#24所有参数皆需要类型转换-采用non-member函数">#</a></h3>
<p>有时候设计一个类表示数值类型时, 在重载运算符时需要所有参数支持隐式类型转换, 为了支持混合算术运算. 这时候成员函数形式的重载操作符不满足要求, 因为成员函数第一个参数是隐含的this, 该参数不能接受隐式类型转换(只有在参数列表中的参数才有可能接受隐式类型转换). 合理的做法是设计一个非成员版本的重载运算符</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Rational</span> <span class="nf">oneHalf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Rational</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">oneHalf</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Rational</span> <span class="n">result1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">oneHalf</span><span class="p">;</span> <span class="c1">// error
</span></span></span></code></pre></div><h3 id="25写出一个不抛异常的swap函数">25.写出一个不抛异常的swap函数<a hidden class="anchor" aria-hidden="true" href="#25写出一个不抛异常的swap函数">#</a></h3>
<p>普通的swap基于对象的copying函数</p>
<ul>
<li>但是有时候对象有特殊设计可以对swap操作进行优化. 比如在pimpl模型下, 实现swap仅仅交换pImpl指针就行</li>
<li>另外基于copying的swap容易抛出异常, 而自己实现的优化swap操作可能仅仅是交互内置类型, 一般不会抛出异常</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">namesapce</span> <span class="n">std</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">T</span> <span class="nf">temp</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>==这一条好像没咋看懂==</p>
<p>具体有以下步骤</p>
<ul>
<li>写public的swap成员函数, 不应该抛出异常</li>
<li>同对象所在命名空间提供一个非成员swap, 里面调用对象成员swap</li>
<li>为对象特化std::swap, 调用对象的成员swap</li>
</ul>
<h2 id="实现">实现<a hidden class="anchor" aria-hidden="true" href="#实现">#</a></h2>
<h3 id="26延后变量定义的出现时间">26.延后变量定义的出现时间<a hidden class="anchor" aria-hidden="true" href="#26延后变量定义的出现时间">#</a></h3>
<p>如果doSomething函数中没有使用变量a, 当该函数抛出异常的时候a承当了构造和析构成本. 但是将a定义挪到doSomething之后就没有这个问题</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">fun</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">A</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">doSomething</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>延后对象的定义时, 不仅仅需要尽量延后到使用该变量为止, 更应该延后到获得该对象初始化需要的初值. 因为方法一default构造一个对象, 再通过copy assignment合适的初始化. 方法二直接通过有参构造初始化对象. 一般来说后者比前者效率高</p>
<h3 id="27尽量少做转型动作">27.尽量少做转型动作<a hidden class="anchor" aria-hidden="true" href="#27尽量少做转型动作">#</a></h3>
<p>理论上cpp程序通过编译后, 就不应该有类型错误. 但是实际开发中需要转型, 这也导致了类型错误出现的可能性</p>
<p>有以下几种转型操作. 尽可能使用==c++风格转型==, 清晰易读, 由于细分为不同的转型编译器更容易识别出使用上的错误</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">expression</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span> <span class="c1">// todo 这个也是转型吗, 感觉有时候也算是构造临时对象
</span></span></span><span class="line"><span class="cl"><span class="c1">//c++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span> <span class="c1">// 去掉const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span> <span class="c1">// 有继承关系的类之间的转型. 唯一旧式c方式无法实现, 并且唯一可能耗费巨大成本的转型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span> <span class="c1">// 低级转型. 实际动作取决于编译器, 使用它意味着代码不可移植
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span> <span class="c1">// 强迫隐式类型转换
</span></span></span></code></pre></div><p>一个使用c旧式转型比较合适的场景</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">explicit</span> <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">fun</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="c1">// 人们更喜欢这一种, 感觉上更像是生成临时对象, 而非转型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">fun</span><span class="p">(</span><span class="n">static_const</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> 
</span></span></code></pre></div><p>转型可能导致更多的运行成本. 下面显示了两种场景</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// int与double的存储空间不同, 值在内存中的放置也不同, 编译器要生成转换的代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base1</span><span class="p">,</span> <span class="n">Base2</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Base2</span><span class="o">*</span> <span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">;</span> <span class="c1">// 由于在base1和base2在derived存储在不同部分, 将&amp;d转换为pb可能涉及到指针偏移的计算
</span></span></span></code></pre></div><p>转型的一种错误用法. 在派生类中实现方法中先调用基类的方法, 在处理该派生类的部分</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span><span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">fun</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">static</span><span class="o">&lt;</span><span class="n">Window</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">fun</span><span class="p">();</span> <span class="c1">// 由于*this实际上生成了一个base对象副本, 而没有修改改派生类上面的base部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Base::fun(); // 实际上应该这样使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// static&lt;Window*&gt;(this)-&gt;fun(); // todo 那这样可以正确调用基类部分的方法吗
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Derived dosomething
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>dynamic_cast使用上开销比较大. 由于dynamic_cast的一个很普遍的实现版本, 是基于class的字符串名字进行依次比较. 需要dynamic_cast的一个场景是泛化为base的derived指针, 还原回derived指针, 以调用derived的特定方法. 解决方法是在base中定义一个什么也不做的同签名(与derived对象特定的函数)的virtual函数</p>
<h3 id="28避免返回handle指向对象内部成分">28.避免返回handle指向对象内部成分<a hidden class="anchor" aria-hidden="true" href="#28避免返回handle指向对象内部成分">#</a></h3>
<p>const成员函数返回一个handle(指向成员变量的指针, 引用, 或者修改成员变量的函数指针)有多个问题</p>
<ul>
<li>不符合const成员函数的直觉, 值的调用方可以通过handle改变对象</li>
<li>改变成员变量的封装性, 由于外部可以通过handle直接改变指向的成员变量, 使得该成员变量从private变成了public</li>
</ul>
<p>解决的一个简单方法是返回const handle, 但是这样也有问题</p>
<ul>
<li>可能造成悬垂引用, 对象内部可能已经销毁handle指向的对象, 但是外部可能还保留该handle, 并且使用它</li>
</ul>
<p>有时候不得不返回handle, 比如为对象实现<code>=</code>运算符的时候</p>
<h3 id="29努力实现异常安全代码">29.努力实现异常安全代码<a hidden class="anchor" aria-hidden="true" href="#29努力实现异常安全代码">#</a></h3>
<p>异常安全函数有不泄露资源和不损坏数据两个条件. 一下代码两个条件都不满足</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">fun</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">imgSrc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">delete</span> <span class="n">bgImage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="o">++</span><span class="n">imageChanges</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">bgImage</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Image</span><span class="p">(</span><span class="n">ImgSrc</span><span class="p">);</span> <span class="c1">// new失败后, bgImage指向的数据被删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// mutex没有被释放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>异常安全有3个层次</p>
<ul>
<li>基本型, ==感觉数据没有完全被删除, 但是数据修改不完整(基本型式什么意思)==</li>
<li>强烈保证, 函数抛出异常后恢复到调用前的状态</li>
<li>不抛出异常</li>
</ul>
<p>实现强烈保证的异常安全代码, 资源泄露容易通过RAII解决, 比如lock操作使用类封装, 但是数据损坏得通过swap操作, 生成了stack上的临时对象(抛出异常时自动销毁), 在这个临时对象上做修改, 然后swap(要求swap是异常安全的)本身对象和临时对象</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">fun</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">imgSrc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Lock</span> <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">Image</span> <span class="nf">temp</span><span class="p">(</span><span class="n">imgSrc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">swap</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">bgImage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>但是swap操作带来的高开销和函数内一些其他函数调用的低异常安全保证, 使我们可能不使代码有强烈安全保证</p>
<h3 id="30了解inlining">30.了解inlining<a hidden class="anchor" aria-hidden="true" href="#30了解inlining">#</a></h3>
<p>inline函数, 定义在class内的成员函数, 默认inline. 可以在函数外添加inline修饰符.</p>
<p>优点</p>
<ul>
<li>像宏一样直接展开函数, 没有调用上的开销, 但是使用代码编写上比宏安全一些</li>
</ul>
<p>缺点</p>
<ul>
<li>但是增加最后代码大小, 可能导致额外的换页行为, 降低缓存的命中率, 带来效率上损失</li>
<li>一般当函数本体比较小而本体简单的时候, 比较适合inline</li>
<li>一旦inline函数有改变, 所有调用该函数的代码都要重新编译. 如果是普通函数, 只需要重新链接</li>
<li>调试器无法处理inline函数</li>
<li>由于在inline是在编译期实现的, 所有需要inline函数完整定义, 而非声明</li>
</ul>
<p>inline修饰函数只是推荐编译器将该函数inline, 但是某些情况下编译器不能inline函数</p>
<ul>
<li>该函数有递归调用</li>
<li>其他地方有使用该函数的指针</li>
</ul>
<h3 id="31将文件的编译依存关系降到最低">31.将文件的编译依存关系降到最低<a hidden class="anchor" aria-hidden="true" href="#31将文件的编译依存关系降到最低">#</a></h3>
<p>由于cpp既支持原始类型, 又支持指针和引用. 头文件class的声明中也可能需要对象定义细节(编译器需要确定对象占用的空间大小, 所有需要对象的定义), 需要包含其他对象的头文件, 进而导致之前导入的头文件中些许改变, 所有导入该class声明的头文件的文件需要重新编译. 在其他语言python和java这不是个问题, 因为所有的对象只能通过指针支持, 并且对象都在heap上分配.</p>
<p>一个解决办法是, 尽量使用对象的指针或者引用, 因为指针的大小是固定的, 对象指针可以通过简单的前向声明解决编译错误</p>
<ul>
<li>进一步有所谓的==pimpl模式==, 成员数据保存在另一个对impl对象中(==除了保存数据还会做什么==), 原对象仅仅包含成员函数声明和一个指向impl对象指针的成员变量声明</li>
<li>==为声明式和定义式提供不同的头文件, 模板也能分为定义和声明==</li>
<li>但是每次成员函数调用都要增加一次解指针操作, impl对象内存动态分配</li>
</ul>
<p>另一种解决办法是使用接口类, 类中所有的成员函数都是纯虚函数</p>
<ul>
<li>由于都是虚函数, 同样需要一层对虚表的简介访问, 另外需要额外的空间存储虚表指针</li>
</ul>
<p>以上两种方法虽然可降低声明和实现的依赖, 但是带来性能上的消耗, 需要有选择使用</p>
<h2 id="面向对象设计">面向对象设计<a hidden class="anchor" aria-hidden="true" href="#面向对象设计">#</a></h2>
<h3 id="32public继承表示is-a关系">32.public继承表示is a关系<a hidden class="anchor" aria-hidden="true" href="#32public继承表示is-a关系">#</a></h3>
<p>public可以实现is a关系. is a关系表示基类可以做的事情, 派生类也一定可以做, 但是反之不成立</p>
<p>==鸭子型面向对象, 编译型和运行型实现==</p>
<p>==展示了一个有趣例子, 说明派生类不能像基类那样==</p>
<h3 id="33避免遮掩继承而来的名称">33.避免遮掩继承而来的名称<a hidden class="anchor" aria-hidden="true" href="#33避免遮掩继承而来的名称">#</a></h3>
<p>在文件中函数作用域的变量会遮蔽全局作用域的变量, 尽管这些变量是不同的类型</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">dobule</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">fun</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在继承的类中也是如此, 如果基类中fun不是虚函数, 而派生类中也定义了fun函数, 派生类中的fun会遮蔽基类)(不管函数签名如何), 使得public 继承带来的is a关系不能成立. 有以下方法解决</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">fun</span><span class="p">;</span> <span class="c1">// 方法1, 是外部可见
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">fun</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">fun</span><span class="p">()</span> <span class="p">{</span><span class="n">Base</span><span class="o">::</span><span class="n">fun</span><span class="p">();}</span> <span class="c1">// 方法2, 转交函数, 为旧式编译器上避免变量遮蔽的方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>==todo, 子类遮蔽和函数重载和虚函数==</p>
<h3 id="34区分接口继承和实现继承">34.区分接口继承和实现继承<a hidden class="anchor" aria-hidden="true" href="#34区分接口继承和实现继承">#</a></h3>
<p>在public继承下</p>
<ul>
<li>基类的纯virtual函数, 相当于派生类只继承接口需要自己实现</li>
<li>基类的virtual函数, 相当于派生类继承接口和默认实现, 也可以自己更改实现</li>
<li>基类的普通函数, 相当于派生列继承接口和实现, 不应该改变该函数实现</li>
</ul>
<p>当基类有virtual函数时, 派生类可能并不想要默认实现, 但是忘记自定义实现带来错误. 以下方法可以强制派生类选择实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 方法1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">fun</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="nf">defaultFun</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="n">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="n">fun</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">defaultFun</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 方法2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">fun</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">fun</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="n">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="n">fun</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">A</span><span class="o">::</span><span class="n">fun</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="35考虑virtual函数之外的其他选择">35.考虑virtual函数之外的其他选择<a hidden class="anchor" aria-hidden="true" href="#35考虑virtual函数之外的其他选择">#</a></h3>
<ul>
<li>将public virtual函数变成private virtual函数, 再定义一个public函数调用private virtual, 这种方法被称为==non virtual interface(NVI)==, 同时这种操作也实现了设计模式中的模板方法模式</li>
<li>传统策略模式通过动态传入一个策略类实现应用不同策略, 策略类中有要执行的虚函数. 代替传入一个函数指针实现策略模式</li>
</ul>
<h3 id="36绝不重新定义继承而来的non-virtual函数">36.绝不重新定义继承而来的non virtual函数<a hidden class="anchor" aria-hidden="true" href="#36绝不重新定义继承而来的non-virtual函数">#</a></h3>
<p>简而言之如果D中重新定义了fun, pb和pd调用fun都是各自定义的fun</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="n">fun</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">D</span><span class="o">:</span><span class="n">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="n">fun</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">D</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">D</span><span class="o">*</span> <span class="n">pd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="o">*</span> <span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">;</span>
</span></span></code></pre></div><p>==不清楚为什么不能==</p>
<h3 id="37绝不重新定义继承而来的缺省参数值">37.绝不重新定义继承而来的缺省参数值<a hidden class="anchor" aria-hidden="true" href="#37绝不重新定义继承而来的缺省参数值">#</a></h3>
<p>简而言之, 虚函数中最好不要定义默认参数. 由于默认参数处于执行效率的考虑是静态绑定, 而虚函数调用是动态绑定. 可能出现如下情况, 调用的fun可能出乎意料</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">(</span><span class="n">Color</span> <span class="n">color</span><span class="o">=</span><span class="s">&#34;red&#34;</span><span class="p">)</span> <span class="k">const</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">(</span><span class="n">Color</span> <span class="n">color</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A</span><span class="o">*</span> <span class="n">pa</span> <span class="o">=</span> <span class="k">new</span> <span class="n">B</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">pa</span><span class="o">-&gt;</span><span class="n">fun</span><span class="p">(</span><span class="s">&#34;green&#34;</span><span class="p">);</span> <span class="c1">// 调用B::fun
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pa</span><span class="o">-&gt;</span><span class="n">fun</span><span class="p">();</span> <span class="c1">// 调用A::fun
</span></span></span></code></pre></div><p>==默认参数再声明和定义, 默认参数与函数重载的关系==</p>
<h3 id="38通过复合构造has-a">38.通过复合构造has a<a hidden class="anchor" aria-hidden="true" href="#38通过复合构造has-a">#</a></h3>
<p>对象分为两种, 一种对象可以直接对应现实世界中的事物, 另一种只是软件层面上的东西, 比如互斥器等. 前者比较好区分is a与has a关系, 但是后者不好区分is a与has a关系, 后者的has a也能叫做is implemented in terms of(根据某物实现出)</p>
<p>==没太看懂==</p>
<h3 id="39谨慎使用private继承">39.谨慎使用private继承<a hidden class="anchor" aria-hidden="true" href="#39谨慎使用private继承">#</a></h3>
<p>private可以和组合一样实现is implemented in terms of关系</p>
<p>==例子没看懂==</p>
<h3 id="40谨慎使用多重继承">40.谨慎使用多重继承<a hidden class="anchor" aria-hidden="true" href="#40谨慎使用多重继承">#</a></h3>
<ul>
<li>缺点一, 可能继承而来的多个基类中相同的成员函数, 造成歧义 ==有调用private成员函数的例子没有看懂==</li>
<li>缺点二, 菱形继承例子中造成空间浪费, 但是可用虚继承解决, 但是虚继承带来额外的开销 ==对象模型上虚继承的细节==</li>
<li>多重继承也有优点, 举得例子类似java中可以组合多个接口</li>
</ul>
<h2 id="泛型编程">泛型编程<a hidden class="anchor" aria-hidden="true" href="#泛型编程">#</a></h2>
<h3 id="41了解隐式接口和编译期多态">41.了解隐式接口和编译期多态<a hidden class="anchor" aria-hidden="true" href="#41了解隐式接口和编译期多态">#</a></h3>
<p>class相当于实现了显示接口(类成员函数定义)和运行期多态(运行时才能确定是哪一个类的虚函数), template相当于实现了隐式接口(只能知道要调用一个类型的那些操作)和编译期多态</p>
<h3 id="42了解typename的双重意义">42.了解typename的双重意义<a hidden class="anchor" aria-hidden="true" href="#42了解typename的双重意义">#</a></h3>
<ul>
<li>在声明模板参数的时候class与typename没有差别</li>
<li>但是在内部typename用于指出一个模板参数内的名称是类型, 而非其他东西 ==有指出的必要吗, 不能等到实例化的时候一起确定吗==</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">fun</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">const_iterator</span><span class="o">*</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>==typename不能用在base class list和member initialization list中==</li>
</ul>
<h3 id="43学习处理模板化基类内的名称">43.学习处理模板化基类内的名称<a hidden class="anchor" aria-hidden="true" href="#43学习处理模板化基类内的名称">#</a></h3>
<p>==没看懂==</p>
<p>在模板化派生类中调用基类成员不能通过编译, 有以下三种方法可以改变</p>
<ul>
<li>this指针明显调用</li>
<li>using</li>
<li>基类调用</li>
</ul>
<p>编译器诊断可以发生在早期, 模板定义时, 也可以发生在晚期, 模板实例化时</p>
<h3 id="44将于参数无关的代码抽离template">44.将于参数无关的代码抽离template<a hidden class="anchor" aria-hidden="true" href="#44将于参数无关的代码抽离template">#</a></h3>
<h3 id="45运用模板参数接受所有兼容类型">45.运用模板参数接受所有兼容类型<a hidden class="anchor" aria-hidden="true" href="#45运用模板参数接受所有兼容类型">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">share_ptr</span><span class="o">&lt;</span><span class="n">Top</span><span class="o">&gt;</span> <span class="n">tp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">share_ptr</span><span class="o">&lt;</span><span class="n">Middle</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Middle</span><span class="p">);</span>
</span></span></code></pre></div><p>==成员函数模板==</p>
<h3 id="46需要类型转换时为模板定义非成员函数">46.需要类型转换时为模板定义非成员函数<a hidden class="anchor" aria-hidden="true" href="#46需要类型转换时为模板定义非成员函数">#</a></h3>
<h3 id="47使用traits-class表现类型信息">47.使用traits class表现类型信息<a hidden class="anchor" aria-hidden="true" href="#47使用traits-class表现类型信息">#</a></h3>
<p>展示了stl中算法库advance例子使用type trait和函数重载实现编译期的type上if else</p>
<ul>
<li>用户类中定义trait class规定的类型</li>
<li>内部类使用trait class从用户类中获取类型信息, 再利用函数重载</li>
</ul>
<h3 id="48template模板元编程">48.template模板元编程<a hidden class="anchor" aria-hidden="true" href="#48template模板元编程">#</a></h3>
<p>==略==</p>
<h2 id="定制new和delete">定制new和delete<a hidden class="anchor" aria-hidden="true" href="#定制new和delete">#</a></h2>
<h3 id="49了解new-handler">49.了解new handler<a hidden class="anchor" aria-hidden="true" href="#49了解new-handler">#</a></h3>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://uhuuh.github.io/tags/cpp/">Cpp</a></li>
      <li><a href="https://uhuuh.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://uhuuh.github.io/posts/go%E8%AF%AD%E8%A8%80/">
    <span class="title">« Prev</span>
    <br>
    <span>go语言</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 读书笔记 effective C&#43;&#43; on x"
            href="https://x.com/intent/tweet/?text=%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%20effective%20C%2b%2b&amp;url=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0-effective-c%2b%2b%2f&amp;hashtags=cpp%2c%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 读书笔记 effective C&#43;&#43; on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0-effective-c%2b%2b%2f&amp;title=%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%20effective%20C%2b%2b&amp;summary=%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%20effective%20C%2b%2b&amp;source=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0-effective-c%2b%2b%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 读书笔记 effective C&#43;&#43; on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0-effective-c%2b%2b%2f&title=%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%20effective%20C%2b%2b">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 读书笔记 effective C&#43;&#43; on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0-effective-c%2b%2b%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 读书笔记 effective C&#43;&#43; on whatsapp"
            href="https://api.whatsapp.com/send?text=%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%20effective%20C%2b%2b%20-%20https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0-effective-c%2b%2b%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 读书笔记 effective C&#43;&#43; on telegram"
            href="https://telegram.me/share/url?text=%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%20effective%20C%2b%2b&amp;url=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0-effective-c%2b%2b%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 读书笔记 effective C&#43;&#43; on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%20effective%20C%2b%2b&u=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0-effective-c%2b%2b%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://uhuuh.github.io/">uh</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
