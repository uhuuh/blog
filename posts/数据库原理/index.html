<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>数据库原理 | uh</title>
<meta name="keywords" content="数据库">
<meta name="description" content="绪论 数据的存储从文件系统过渡到数据库, 数据库相比于文件系统有以下优点
文件系统 数据库 数据结构化 数据描述由应用的程序负责 引入逻辑模型由数据库本身维护数据描述 数据共享和独立性 针对不同的应用使用不同的文件保存数据 所有应用统一保存数据, 不同应用的数据之间尽可能共享, 提供三级模式为不同应用提供数据视图 实体是现实中可区分的事物 实体具有一系列属性来描述自己 码是一个或者多个特殊实体属性, 可以区分一个实体. 实体可能具有多个码 实体之间有联系, 比如实体之间的一一对应, 一对多, 多对一, 多对多 数据是事物的符号化化描述 实体型是一个实体的属性集合, 实体集是同一类型实体型的集合. 实体型和实体集都可视作数据 数据模型用来描述数据, 按不同的层次有以下三种
概念模型, 一般使用ER图, 描述实体有哪些数据和实体之间的联系 逻辑模型, 有对象, 网状和关系多种. 概念模型描述了数据对应实体的属性和实体之间联系, 而逻辑模型进一步规定了数据结构, 数据操作数据完整性约束 物理模型, 进一步确定了数据是如何存储的, ==一般采用三级模式结构== 外模式, 可以为不同的应用提供不同的逻辑视图 模式, 所有数据的统一逻辑视图 内模式, 数据的具体存储方式, 一般多个外模式对应一个模式 , 一个模式对应一个内模式 与书的不同
==数据模型与模式是两个独立的概念, 把模式放在物理模型方面感觉更好些== 数据模型的三要素(数据结构, 操作和完整性约束)也是只放在了逻辑模型中 关系数据库 关系数据库是采用关系逻辑模型的数据库
数据结构
关系是数据的存储方式, 简单来说就是一张表, 表里面保存了一个实体集, 表中每一行是一个实体的各个属性, 同时实体与实体之间的联系也能以关系方式存储, 更形式来说关系是所有属性取值集合的笛卡尔积的子集 关系中有如下概念 域是某个属性的取值集合 候选码是可以标识实体的属性组, 其子集不能标识实体. 一个实体可能有多个候选码, 候选码中可能包含多个属性 主属性是在候选码中的属性, 其他属性是非主属性 数据操作方法">
<meta name="author" content="">
<link rel="canonical" href="https://uhuuh.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.4599eadb9eb2ad3d0a8d6827b41a8fda8f2f4af226b63466c09c5fddbc8706b7.css" integrity="sha256-RZnq256yrT0KjWgntBqP2o8vSvImtjRmwJxf3byHBrc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://uhuuh.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://uhuuh.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://uhuuh.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://uhuuh.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://uhuuh.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://uhuuh.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="数据库原理" />
<meta property="og:description" content="绪论 数据的存储从文件系统过渡到数据库, 数据库相比于文件系统有以下优点
文件系统 数据库 数据结构化 数据描述由应用的程序负责 引入逻辑模型由数据库本身维护数据描述 数据共享和独立性 针对不同的应用使用不同的文件保存数据 所有应用统一保存数据, 不同应用的数据之间尽可能共享, 提供三级模式为不同应用提供数据视图 实体是现实中可区分的事物 实体具有一系列属性来描述自己 码是一个或者多个特殊实体属性, 可以区分一个实体. 实体可能具有多个码 实体之间有联系, 比如实体之间的一一对应, 一对多, 多对一, 多对多 数据是事物的符号化化描述 实体型是一个实体的属性集合, 实体集是同一类型实体型的集合. 实体型和实体集都可视作数据 数据模型用来描述数据, 按不同的层次有以下三种
概念模型, 一般使用ER图, 描述实体有哪些数据和实体之间的联系 逻辑模型, 有对象, 网状和关系多种. 概念模型描述了数据对应实体的属性和实体之间联系, 而逻辑模型进一步规定了数据结构, 数据操作数据完整性约束 物理模型, 进一步确定了数据是如何存储的, ==一般采用三级模式结构== 外模式, 可以为不同的应用提供不同的逻辑视图 模式, 所有数据的统一逻辑视图 内模式, 数据的具体存储方式, 一般多个外模式对应一个模式 , 一个模式对应一个内模式 与书的不同
==数据模型与模式是两个独立的概念, 把模式放在物理模型方面感觉更好些== 数据模型的三要素(数据结构, 操作和完整性约束)也是只放在了逻辑模型中 关系数据库 关系数据库是采用关系逻辑模型的数据库
数据结构
关系是数据的存储方式, 简单来说就是一张表, 表里面保存了一个实体集, 表中每一行是一个实体的各个属性, 同时实体与实体之间的联系也能以关系方式存储, 更形式来说关系是所有属性取值集合的笛卡尔积的子集 关系中有如下概念 域是某个属性的取值集合 候选码是可以标识实体的属性组, 其子集不能标识实体. 一个实体可能有多个候选码, 候选码中可能包含多个属性 主属性是在候选码中的属性, 其他属性是非主属性 数据操作方法" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://uhuuh.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" /><meta property="og:image" content="https://uhuuh.github.io/images/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-29T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-02-29T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://uhuuh.github.io/images/papermod-cover.png"/>

<meta name="twitter:title" content="数据库原理"/>
<meta name="twitter:description" content="绪论 数据的存储从文件系统过渡到数据库, 数据库相比于文件系统有以下优点
文件系统 数据库 数据结构化 数据描述由应用的程序负责 引入逻辑模型由数据库本身维护数据描述 数据共享和独立性 针对不同的应用使用不同的文件保存数据 所有应用统一保存数据, 不同应用的数据之间尽可能共享, 提供三级模式为不同应用提供数据视图 实体是现实中可区分的事物 实体具有一系列属性来描述自己 码是一个或者多个特殊实体属性, 可以区分一个实体. 实体可能具有多个码 实体之间有联系, 比如实体之间的一一对应, 一对多, 多对一, 多对多 数据是事物的符号化化描述 实体型是一个实体的属性集合, 实体集是同一类型实体型的集合. 实体型和实体集都可视作数据 数据模型用来描述数据, 按不同的层次有以下三种
概念模型, 一般使用ER图, 描述实体有哪些数据和实体之间的联系 逻辑模型, 有对象, 网状和关系多种. 概念模型描述了数据对应实体的属性和实体之间联系, 而逻辑模型进一步规定了数据结构, 数据操作数据完整性约束 物理模型, 进一步确定了数据是如何存储的, ==一般采用三级模式结构== 外模式, 可以为不同的应用提供不同的逻辑视图 模式, 所有数据的统一逻辑视图 内模式, 数据的具体存储方式, 一般多个外模式对应一个模式 , 一个模式对应一个内模式 与书的不同
==数据模型与模式是两个独立的概念, 把模式放在物理模型方面感觉更好些== 数据模型的三要素(数据结构, 操作和完整性约束)也是只放在了逻辑模型中 关系数据库 关系数据库是采用关系逻辑模型的数据库
数据结构
关系是数据的存储方式, 简单来说就是一张表, 表里面保存了一个实体集, 表中每一行是一个实体的各个属性, 同时实体与实体之间的联系也能以关系方式存储, 更形式来说关系是所有属性取值集合的笛卡尔积的子集 关系中有如下概念 域是某个属性的取值集合 候选码是可以标识实体的属性组, 其子集不能标识实体. 一个实体可能有多个候选码, 候选码中可能包含多个属性 主属性是在候选码中的属性, 其他属性是非主属性 数据操作方法"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://uhuuh.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "数据库原理",
      "item": "https://uhuuh.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数据库原理",
  "name": "数据库原理",
  "description": "绪论 数据的存储从文件系统过渡到数据库, 数据库相比于文件系统有以下优点\n文件系统 数据库 数据结构化 数据描述由应用的程序负责 引入逻辑模型由数据库本身维护数据描述 数据共享和独立性 针对不同的应用使用不同的文件保存数据 所有应用统一保存数据, 不同应用的数据之间尽可能共享, 提供三级模式为不同应用提供数据视图 实体是现实中可区分的事物 实体具有一系列属性来描述自己 码是一个或者多个特殊实体属性, 可以区分一个实体. 实体可能具有多个码 实体之间有联系, 比如实体之间的一一对应, 一对多, 多对一, 多对多 数据是事物的符号化化描述 实体型是一个实体的属性集合, 实体集是同一类型实体型的集合. 实体型和实体集都可视作数据 数据模型用来描述数据, 按不同的层次有以下三种\n概念模型, 一般使用ER图, 描述实体有哪些数据和实体之间的联系 逻辑模型, 有对象, 网状和关系多种. 概念模型描述了数据对应实体的属性和实体之间联系, 而逻辑模型进一步规定了数据结构, 数据操作数据完整性约束 物理模型, 进一步确定了数据是如何存储的, ==一般采用三级模式结构== 外模式, 可以为不同的应用提供不同的逻辑视图 模式, 所有数据的统一逻辑视图 内模式, 数据的具体存储方式, 一般多个外模式对应一个模式 , 一个模式对应一个内模式 与书的不同\n==数据模型与模式是两个独立的概念, 把模式放在物理模型方面感觉更好些== 数据模型的三要素(数据结构, 操作和完整性约束)也是只放在了逻辑模型中 关系数据库 关系数据库是采用关系逻辑模型的数据库\n数据结构\n关系是数据的存储方式, 简单来说就是一张表, 表里面保存了一个实体集, 表中每一行是一个实体的各个属性, 同时实体与实体之间的联系也能以关系方式存储, 更形式来说关系是所有属性取值集合的笛卡尔积的子集 关系中有如下概念 域是某个属性的取值集合 候选码是可以标识实体的属性组, 其子集不能标识实体. 一个实体可能有多个候选码, 候选码中可能包含多个属性 主属性是在候选码中的属性, 其他属性是非主属性 数据操作方法",
  "keywords": [
    "数据库"
  ],
  "articleBody": "绪论 数据的存储从文件系统过渡到数据库, 数据库相比于文件系统有以下优点\n文件系统 数据库 数据结构化 数据描述由应用的程序负责 引入逻辑模型由数据库本身维护数据描述 数据共享和独立性 针对不同的应用使用不同的文件保存数据 所有应用统一保存数据, 不同应用的数据之间尽可能共享, 提供三级模式为不同应用提供数据视图 实体是现实中可区分的事物 实体具有一系列属性来描述自己 码是一个或者多个特殊实体属性, 可以区分一个实体. 实体可能具有多个码 实体之间有联系, 比如实体之间的一一对应, 一对多, 多对一, 多对多 数据是事物的符号化化描述 实体型是一个实体的属性集合, 实体集是同一类型实体型的集合. 实体型和实体集都可视作数据 数据模型用来描述数据, 按不同的层次有以下三种\n概念模型, 一般使用ER图, 描述实体有哪些数据和实体之间的联系 逻辑模型, 有对象, 网状和关系多种. 概念模型描述了数据对应实体的属性和实体之间联系, 而逻辑模型进一步规定了数据结构, 数据操作数据完整性约束 物理模型, 进一步确定了数据是如何存储的, ==一般采用三级模式结构== 外模式, 可以为不同的应用提供不同的逻辑视图 模式, 所有数据的统一逻辑视图 内模式, 数据的具体存储方式, 一般多个外模式对应一个模式 , 一个模式对应一个内模式 与书的不同\n==数据模型与模式是两个独立的概念, 把模式放在物理模型方面感觉更好些== 数据模型的三要素(数据结构, 操作和完整性约束)也是只放在了逻辑模型中 关系数据库 关系数据库是采用关系逻辑模型的数据库\n数据结构\n关系是数据的存储方式, 简单来说就是一张表, 表里面保存了一个实体集, 表中每一行是一个实体的各个属性, 同时实体与实体之间的联系也能以关系方式存储, 更形式来说关系是所有属性取值集合的笛卡尔积的子集 关系中有如下概念 域是某个属性的取值集合 候选码是可以标识实体的属性组, 其子集不能标识实体. 一个实体可能有多个候选码, 候选码中可能包含多个属性 主属性是在候选码中的属性, 其他属性是非主属性 数据操作方法\n支持关系上的增删查改 查询包含选择, 投影, 并, 差和笛卡尔积这五种基本操作, 其他查询操作可以通过组合这些基本操作得到 操作的对象和结果都是关系 具体操作工具 关系代数 集合运算, 并差交笛卡尔积 关系运算, 选择, 投影, 连接和除 关系演算 元组关系演算 域关系演算 结构化查询语言(SQL), 结合上述两者, 后面出现现在普遍使用, SQL额外支持数据定义和数据控制 数据完整性定义\n具体有以下三种 实体完整性, 关系中的主属性非空且唯一 ==参照完整性, ???== 用户自定义完整性 在数据库执行增删改操作之后, 检查是否满足完整性约束 数据库完整性 为了维护数据库的完整性, 需要数据库管理系统提供定义完整性约束条件, 检查完整性, 提供完整性违约处理\n实体完整性 创建表时指定主键 插入新纪录时检查, 该纪录主键已存在则插入失败 参照完整性 创建表时有指定外键 在参照表中新增或者修改一条记录, 该纪录的外键在被参照表中找不到, 操作失败 在被参照表中删除或者修改一条记录, 使得参照表中存在记录外键对应失败, 有三种违约处理策略, 分别是拒绝操作, 级联修改和设置空值 用户定义完整性 创建表时指定某个列唯一或非空, 或者一条记录需要满足某个条件 使用断言 使用触发器, 触发器有事件条件动作组成, 事件一般指的是某个表的增删改操作 违反用户定义完整性时, 操作失败 关系的规范化理论 ER图可以建模实体之间的关系，被参考建表，一个实体或者一个多对多关系是一张表。实体的内部属性之间也存在依赖（数据依赖），不对这些依赖进行分析和处理而简单根据实体建表，能造成数据冗余和操作异常。关系的规范化理论对属性的数据依赖进行分析和处理，提出一些范式，范式对实体表中进行拆分以降低数据冗余和操作异常。\n数据依赖\n函数依赖 属性组U中有属性集合X和Y，Y函数依赖X，说明在任意两个元组中X的取值相等时Y的取值也相等，也能说X决定Y 平凡函数依赖 Y是X的子集 非平凡函数依赖 一般情况下都默认非平凡函数依赖 部分函数依赖 完全函数依赖 如果有X的任意真子集Z，Z不能决定Y 传递函数依赖 如果X决定Y，Y决定Z，则X决定Z ==多值依赖== ==连接依赖== ==数据冗余和操作异常==\n数据冗余 插入异常 因为一些情况不能插入 删除异常 更新异常 概念\n候选码（码） 属性组，可以决定整个所有属性。一个关系中可能有多个码 主属性 属性，该属性是任意一个码中的属性 外码 属性组，非本关系上的码，而是其他关系上的码 非主属性 属性，属性组中除主属性之外的其他属性 范式\n高范式同时满足低范式 高范式可以减少数据冗余和操作异常，但是由于表拆分的太细，现实中经常需要连接多个表实现业务需求，造成计算上的损耗。现实中实现到什么级别的范式需要再时间和空间之间取舍 现实中一般设计到第三范式或者BC范式 BC范式在函数依赖的范畴上消除了操作异常 范式分类 第一范式 每个属性都不可再分 第二范式 在满足第一范式的情况下，消除非主属性对码的部分函数依赖，即非主属性完全函数依赖主属性 第三范式 在满足第一范式的情况下，消除非主属性对码的传递函数依赖 BC范式 在满足第一范式的情况下，消除主属性对码的部分和传递函数依赖 ==第四范式== ==部分函数依赖和传递函数依赖一定会造成数据冗余和操作异常吗==\n参考 数据依赖的公理系统_哔哩哔哩_bilibili 比配到书讲得清晰 【哈工大】数据库系统 战德臣（全23讲）哔哩哔哩_bilibili 更偏理论一些 数据库恢复 并发控制 事务是为了实现某个业务的一系列SQL语句集合。 事务的出现是一件很自然的事情，现实生活中一个业务常常需要一系列SQL语句实现。事务也是DBMS执行的最基本单位 为了使DBMS更好用，希望DBMS支持同时执行多个事务的能力。由于事务执行之间可能产生影响，使用ACID这四个特性用来衡量事务执行的正确性 为了实现事务的隔离性，就需要数据库的并发控制机制去决定事务之间的交错的执行是以怎样的一个顺序/时间表来进行，不可以随意地交错执行。实现并发控制有两大流派：\n悲观协议：不要让问题发生，在问题出现之前就让线程停住 乐观协议：假设并发的冲突是少数的，只在问题出现之后再去回滚 事务可串行化调度检测 在简化的系统上讨论并发事务的执行，事务由一系列对数据库对象的读操作和写操作组成\n多个事务并发执行顺序（调度）可能违反数据库的一致性\n串行化调度，一个事务的操作接着一个事务的操作执行，显然不违反数据库的一致性\n可串行化调度，执行效果等价为一种串行化调度的执行效果，也不违反数据库的一致性\n显示可串行化调度，基于观察判断 冲突可串行化调度，基于规则判断 基于交互的冲突可串行化调度判断算法\n冲突操作，两个事务针对同一个对象的写写，读写，写读操作 除了冲突操作之外交互相邻的两个操作，如果最终可以形成串行化调度是冲突可串行化调度，否则不是 如果算法判断失败不能一定说明不是可串行化调度，冲突可串行化只是充分条件，而不是必要条件（从维恩图上可知，不是冲突可串行化的有部分在显示可串行化中） 基于依赖图的冲突可串行化调度判断算法\n基于交互的算法只能判断两个事务之间的调度是否是冲突可串行化，该算法使用上有很多的局限性 如果两个事务之间有冲突操作，这两个事务使用有向边连接起来。如果最终的依赖图是无环的，说明这些事务的调度是冲突可串行化 由基于交互的算法可知冲突操作的执行顺序不能更改，不可串行化说明事务有冲突操作确定的顺序出现回路 两段锁协议（Two-Phase Locking，2PL） 仅仅有串行化调度检测方法不够，需要有并发调度协议控制事务执行直接得到一个可串行化调度 使用锁来控制对象上事务的执行顺序 独占锁（X锁）在一个对象的写操作前获取 共享锁（S锁）在一个对象的读操作前获取 ==有这两种锁的原因== 锁之间有兼容关系，当一个事务T1在一个对象A上已经获取一个锁，另一个事务T2同样在A获取一个不兼容的锁，需要等待T1释放A上的锁后获取 事务执行过程分为以下两个阶段 增长阶段，只能获取锁 缩小阶段，只能释放锁 ==使用两阶段锁协议说明的依赖图是无环的, 事务按照增长阶段的结束时间构成一条链== 缺点 级联回滚，T1写A后，T2读A，然后T1回滚时，由于T2读取了T1修改A后的值，也要跟着回滚。使用强两阶段锁（P2PL），事务提交的时候才将所有锁释放。 死锁，当事务需要获取多个锁时，两个事务都获取一部分锁，等待获取对方已经占用的一部分锁。 死锁检测。锁等待图，出现环说明死锁，将最轻量的事务（一般是持续锁数量最少得事务）回滚。 死锁预防。 优先级，按照事务开始执行时间给事务赋予优先级，高优先级想要低优先级持有的锁时，低优先级事务回滚，高优先级抢占这个锁；低优先级想要高优先级的锁是，低优先级等待高优先级释放锁。 活锁，当多个事务等待获取一个锁使，这个事务总是抢占不到已经释放的锁。这种情况一般不容易出现，先来先服务。 性能，事务执行过程中涉及很多对象。多粒度封锁，==SIX锁== 时间戳（Timestamp Ordering，T/O） 时间戳一般使用逻辑时钟，系统时钟精度不够，另外可能因为时间校准而出问题 基本的T/O协议 每个事务开始执行前赋予一个时间戳 数据库所有对象有一个读时间戳和写时间戳，即最近操作该对象的事物的时间戳 对象读写事件戳更新规则。相比于2Pl通过特定加锁解锁机制使依赖图自然无环，T/O通过以下规则在依赖图上强制使事务按照时间戳构造一条链 ==托马斯写规则== 缺点 较长的事务可能饥饿。较长的事务有更多的可能性碰到需要abort的情况，导致这个事务一直执行不完 调度不可恢复。 性能。==事务读任何对象都需要事务本地拷贝一份== ==T/O协议的改进== ==乐观并发控制==（OCC） 阶段 读阶段 验证阶段 写阶段 多版本并发控制（MVCC） 事务T1读取一个被另一个未提交事务T2更新后的对象时，在2PL中需要等待加锁，在T/O中直接回滚T1。MVCC中维护一个对象的多种版本，使得事务任何情况下的读操作都可以顺利进行，一般与其他三种并发控制协议协同作用 隔离级别 之前讨论的事务操作仅包含读写，但实际上事务也能插入和删除一个对象。幻读问题，事务T1读取表中对象数量之后，事务T2又在该表中插入或者删除对象，使得T2再次读取表中数量两次结果不一致。要实现真正的串行化，还需要解决幻读问题 各种隔离级别 读未提交。有脏读，可以看到一个未提交事务所做的修改。 读已提交。有不可重复读，两次读取对象值不一样。保存已经读取的对象值 可重复读。有幻读，两次读取表中对象数量不一样。保存已经读取的表中对象数量 串行化。解决了所有问题 ==解决幻读== 重新扫描 谓词锁，谓词上加锁 索引锁， 间隙锁 数据库设计 总结 事务处理方面还有很多不清楚的地方，中文这方面的资料太匮乏了，如果有时间需要进一步阅读资料。 问题 一致性和完整性 级联和无法恢复 参考 数据库系统概论(第5版) 15445.courses.cs.cmu.edu/spring2023/schedule.html CMU15-445课程笔记 - 知乎 (zhihu.com) 16-两阶段锁 [中文讲解] CMU-15445 数据库内核_哔哩哔哩_bilibili 进一步阅读 oceanbase/miniob: MiniOB is a compact database that assists developers in understanding the fundamental workings of a database. (github.com) 重要，国内实现数据库管理系统的资料 Database System Concepts 这本书内容比较多，但是有些地方的介绍有些简单 Transaction Processing: Concepts and Techniques 据说这本书对于事物处理内容解释的很好，有时间看一下 sqlite design and implementation 介绍sqlite源码的书 首页 | SQlite源码分析 (huili.github.io) (27 封私信 / 11 条消息) 如何学习sqlite源码？ - 知乎 (zhihu.com) ",
  "wordCount" : "326",
  "inLanguage": "en",
  "datePublished": "2024-02-29T00:00:00Z",
  "dateModified": "2024-02-29T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://uhuuh.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "uh",
    "logo": {
      "@type": "ImageObject",
      "url": "https://uhuuh.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://uhuuh.github.io/" accesskey="h" title="uh (Alt + H)">uh</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://uhuuh.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://uhuuh.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://uhuuh.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://uhuuh.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://uhuuh.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      数据库原理
    </h1>
    <div class="post-meta"><span title='2024-02-29 00:00:00 +0000 UTC'>February 29, 2024</span>&nbsp;·&nbsp;2 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e7%bb%aa%e8%ae%ba" aria-label="绪论">绪论</a></li>
                <li>
                    <a href="#%e5%85%b3%e7%b3%bb%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="关系数据库">关系数据库</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%ae%8c%e6%95%b4%e6%80%a7" aria-label="数据库完整性">数据库完整性</a></li>
                <li>
                    <a href="#%e5%85%b3%e7%b3%bb%e7%9a%84%e8%a7%84%e8%8c%83%e5%8c%96%e7%90%86%e8%ae%ba" aria-label="关系的规范化理论">关系的规范化理论</a><ul>
                        
                <li>
                    <a href="#%e5%8f%82%e8%80%83" aria-label="参考">参考</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e6%81%a2%e5%a4%8d" aria-label="数据库恢复">数据库恢复</a></li>
                <li>
                    <a href="#%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6" aria-label="并发控制">并发控制</a><ul>
                        
                <li>
                    <a href="#%e4%ba%8b%e5%8a%a1%e5%8f%af%e4%b8%b2%e8%a1%8c%e5%8c%96%e8%b0%83%e5%ba%a6%e6%a3%80%e6%b5%8b" aria-label="事务可串行化调度检测">事务可串行化调度检测</a></li>
                <li>
                    <a href="#%e4%b8%a4%e6%ae%b5%e9%94%81%e5%8d%8f%e8%ae%aetwo-phase-locking2pl" aria-label="两段锁协议（Two-Phase Locking，2PL）">两段锁协议（Two-Phase Locking，2PL）</a></li>
                <li>
                    <a href="#%e6%97%b6%e9%97%b4%e6%88%b3timestamp-orderingto" aria-label="时间戳（Timestamp Ordering，T/O）">时间戳（Timestamp Ordering，T/O）</a></li>
                <li>
                    <a href="#%e4%b9%90%e8%a7%82%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6occ" aria-label="==乐观并发控制==（OCC）">==乐观并发控制==（OCC）</a></li>
                <li>
                    <a href="#%e5%a4%9a%e7%89%88%e6%9c%ac%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6mvcc" aria-label="多版本并发控制（MVCC）">多版本并发控制（MVCC）</a></li>
                <li>
                    <a href="#%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab" aria-label="隔离级别">隔离级别</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%be%e8%ae%a1" aria-label="数据库设计">数据库设计</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li>
                <li>
                    <a href="#%e9%97%ae%e9%a2%98" aria-label="问题">问题</a></li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83-1" aria-label="参考">参考</a></li>
                <li>
                    <a href="#%e8%bf%9b%e4%b8%80%e6%ad%a5%e9%98%85%e8%af%bb" aria-label="进一步阅读">进一步阅读</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="绪论">绪论<a hidden class="anchor" aria-hidden="true" href="#绪论">#</a></h2>
<p>数据的存储从文件系统过渡到数据库, 数据库相比于文件系统有以下优点</p>
<table>
<thead>
<tr>
<th></th>
<th>文件系统</th>
<th>数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据结构化</td>
<td>数据描述由应用的程序负责</td>
<td>引入逻辑模型由数据库本身维护数据描述</td>
</tr>
<tr>
<td>数据共享和独立性</td>
<td>针对不同的应用使用不同的文件保存数据</td>
<td>所有应用统一保存数据, 不同应用的数据之间尽可能共享, 提供三级模式为不同应用提供数据视图</td>
</tr>
</tbody>
</table>
<ul>
<li>实体是现实中可区分的事物
<ul>
<li>实体具有一系列属性来描述自己</li>
<li>码是一个或者多个特殊实体属性, 可以区分一个实体. 实体可能具有多个码</li>
<li>实体之间有联系, 比如实体之间的一一对应, 一对多, 多对一, 多对多</li>
</ul>
</li>
<li>数据是事物的符号化化描述</li>
<li>实体型是一个实体的属性集合, 实体集是同一类型实体型的集合. 实体型和实体集都可视作数据</li>
</ul>
<p>数据模型用来描述数据, 按不同的层次有以下三种</p>
<ul>
<li>概念模型, 一般使用ER图, 描述实体有哪些数据和实体之间的联系</li>
<li>逻辑模型, 有对象, 网状和关系多种. 概念模型描述了数据对应实体的属性和实体之间联系, 而逻辑模型进一步规定了数据结构, 数据操作数据完整性约束</li>
<li>物理模型, 进一步确定了数据是如何存储的, ==一般采用三级模式结构==
<ul>
<li>外模式, 可以为不同的应用提供不同的逻辑视图</li>
<li>模式, 所有数据的统一逻辑视图</li>
<li>内模式, 数据的具体存储方式, 一般多个外模式对应一个模式 , 一个模式对应一个内模式</li>
</ul>
</li>
</ul>
<p>与书的不同</p>
<ul>
<li>==数据模型与模式是两个独立的概念, 把模式放在物理模型方面感觉更好些==</li>
<li>数据模型的三要素(数据结构, 操作和完整性约束)也是只放在了逻辑模型中</li>
</ul>
<h2 id="关系数据库">关系数据库<a hidden class="anchor" aria-hidden="true" href="#关系数据库">#</a></h2>
<p>关系数据库是采用关系逻辑模型的数据库</p>
<p>数据结构</p>
<ul>
<li>关系是数据的存储方式, 简单来说就是一张表, 表里面保存了一个实体集, 表中每一行是一个实体的各个属性, 同时实体与实体之间的联系也能以关系方式存储, 更形式来说关系是所有属性取值集合的笛卡尔积的子集</li>
<li>关系中有如下概念
<ul>
<li>域是某个属性的取值集合</li>
<li>候选码是可以标识实体的属性组, 其子集不能标识实体. 一个实体可能有多个候选码, 候选码中可能包含多个属性</li>
<li>主属性是在候选码中的属性, 其他属性是非主属性</li>
</ul>
</li>
</ul>
<p>数据操作方法</p>
<ul>
<li>支持关系上的增删查改</li>
<li>查询包含选择, 投影, 并, 差和笛卡尔积这五种基本操作, 其他查询操作可以通过组合这些基本操作得到</li>
<li>操作的对象和结果都是关系</li>
<li>具体操作工具
<ul>
<li>关系代数
<ul>
<li>集合运算, 并差交笛卡尔积</li>
<li>关系运算, 选择, 投影, 连接和除</li>
</ul>
</li>
<li>关系演算
<ul>
<li>元组关系演算</li>
<li>域关系演算</li>
</ul>
</li>
<li>结构化查询语言(SQL), 结合上述两者, 后面出现现在普遍使用, SQL额外支持数据定义和数据控制</li>
</ul>
</li>
</ul>
<p>数据完整性定义</p>
<ul>
<li>具体有以下三种
<ul>
<li>实体完整性, 关系中的主属性非空且唯一</li>
<li>==参照完整性, ???==</li>
<li>用户自定义完整性</li>
</ul>
</li>
<li>在数据库执行增删改操作之后, 检查是否满足完整性约束</li>
</ul>
<h2 id="数据库完整性">数据库完整性<a hidden class="anchor" aria-hidden="true" href="#数据库完整性">#</a></h2>
<p>为了维护数据库的完整性, 需要数据库管理系统提供定义完整性约束条件, 检查完整性, 提供完整性违约处理</p>
<ul>
<li>实体完整性
<ul>
<li>创建表时指定主键</li>
<li>插入新纪录时检查, 该纪录主键已存在则插入失败</li>
</ul>
</li>
<li>参照完整性
<ul>
<li>创建表时有指定外键</li>
<li>在参照表中新增或者修改一条记录, 该纪录的外键在被参照表中找不到, 操作失败</li>
<li>在被参照表中删除或者修改一条记录, 使得参照表中存在记录外键对应失败, 有三种违约处理策略, 分别是拒绝操作, 级联修改和设置空值</li>
</ul>
</li>
<li>用户定义完整性
<ul>
<li>创建表时指定某个列唯一或非空, 或者一条记录需要满足某个条件</li>
<li>使用断言</li>
<li>使用触发器, 触发器有事件条件动作组成, 事件一般指的是某个表的增删改操作</li>
<li>违反用户定义完整性时, 操作失败</li>
</ul>
</li>
</ul>
<h2 id="关系的规范化理论">关系的规范化理论<a hidden class="anchor" aria-hidden="true" href="#关系的规范化理论">#</a></h2>
<p>ER图可以建模实体之间的关系，被参考建表，一个实体或者一个多对多关系是一张表。实体的内部属性之间也存在依赖（数据依赖），不对这些依赖进行分析和处理而简单根据实体建表，能造成数据冗余和操作异常。关系的规范化理论对属性的数据依赖进行分析和处理，提出一些范式，范式对实体表中进行拆分以降低数据冗余和操作异常。</p>
<p>数据依赖</p>
<ul>
<li>函数依赖 属性组U中有属性集合X和Y，Y函数依赖X，说明在任意两个元组中X的取值相等时Y的取值也相等，也能说X决定Y
<ul>
<li>平凡函数依赖 Y是X的子集</li>
<li>非平凡函数依赖 一般情况下都默认非平凡函数依赖</li>
<li>部分函数依赖</li>
<li>完全函数依赖 如果有X的任意真子集Z，Z不能决定Y</li>
<li>传递函数依赖 如果X决定Y，Y决定Z，则X决定Z</li>
</ul>
</li>
<li>==多值依赖==</li>
<li>==连接依赖==</li>
</ul>
<p>==数据冗余和操作异常==</p>
<ul>
<li>数据冗余</li>
<li>插入异常 因为一些情况不能插入</li>
<li>删除异常</li>
<li>更新异常</li>
</ul>
<p>概念</p>
<ul>
<li>候选码（码） 属性组，可以决定整个所有属性。一个关系中可能有多个码</li>
<li>主属性 属性，该属性是任意一个码中的属性</li>
<li>外码 属性组，非本关系上的码，而是其他关系上的码</li>
<li>非主属性 属性，属性组中除主属性之外的其他属性</li>
</ul>
<p>范式</p>
<ul>
<li>高范式同时满足低范式</li>
<li>高范式可以减少数据冗余和操作异常，但是由于表拆分的太细，现实中经常需要连接多个表实现业务需求，造成计算上的损耗。现实中实现到什么级别的范式需要再时间和空间之间取舍</li>
<li>现实中一般设计到第三范式或者BC范式</li>
<li>BC范式在函数依赖的范畴上消除了操作异常</li>
<li>范式分类
<ul>
<li>第一范式 每个属性都不可再分</li>
<li>第二范式 在满足第一范式的情况下，消除非主属性对码的部分函数依赖，即非主属性完全函数依赖主属性</li>
<li>第三范式 在满足第一范式的情况下，消除非主属性对码的传递函数依赖</li>
<li>BC范式 在满足第一范式的情况下，消除主属性对码的部分和传递函数依赖</li>
<li>==第四范式==</li>
</ul>
</li>
</ul>
<p>==部分函数依赖和传递函数依赖一定会造成数据冗余和操作异常吗==</p>
<h3 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h3>
<ul>
<li><a href="https://www.bilibili.com/video/BV13J411J7Vu?p=43&vd_source=f1b7ffa37a1d59bcc4d8eef80521446c">数据依赖的公理系统_哔哩哔哩_bilibili</a> 比配到书讲得清晰</li>
<li><a href="https://www.bilibili.com/video/BV1HY4y1b72A/?spm_id_from=333.337.search-card.all.click">【哈工大】数据库系统 战德臣（全23讲）哔哩哔哩_bilibili</a> 更偏理论一些</li>
</ul>
<h2 id="数据库恢复">数据库恢复<a hidden class="anchor" aria-hidden="true" href="#数据库恢复">#</a></h2>
<h2 id="并发控制">并发控制<a hidden class="anchor" aria-hidden="true" href="#并发控制">#</a></h2>
<ul>
<li>事务是为了实现某个业务的一系列SQL语句集合。 事务的出现是一件很自然的事情，现实生活中一个业务常常需要一系列SQL语句实现。事务也是DBMS执行的最基本单位</li>
<li>为了使DBMS更好用，希望DBMS支持同时执行多个事务的能力。由于事务执行之间可能产生影响，使用ACID这四个特性用来衡量事务执行的正确性</li>
</ul>
<p>为了实现事务的隔离性，就需要数据库的并发控制机制去决定事务之间的交错的执行是以怎样的一个顺序/时间表来进行，不可以随意地交错执行。实现并发控制有两大流派：</p>
<ul>
<li>悲观协议：不要让问题发生，在问题出现之前就让线程停住</li>
<li>乐观协议：假设并发的冲突是少数的，只在问题出现之后再去回滚</li>
</ul>
<h3 id="事务可串行化调度检测">事务可串行化调度检测<a hidden class="anchor" aria-hidden="true" href="#事务可串行化调度检测">#</a></h3>
<ul>
<li>
<p>在简化的系统上讨论并发事务的执行，事务由一系列对数据库对象的读操作和写操作组成</p>
</li>
<li>
<p>多个事务并发执行顺序（调度）可能违反数据库的一致性</p>
</li>
<li>
<p>串行化调度，一个事务的操作接着一个事务的操作执行，显然不违反数据库的一致性</p>
</li>
<li>
<p>可串行化调度，执行效果等价为一种串行化调度的执行效果，也不违反数据库的一致性</p>
<ul>
<li>显示可串行化调度，基于观察判断</li>
<li>冲突可串行化调度，基于规则判断
<img loading="lazy" src="/images/Pasted%20image%2020231226230824.png" alt="Pasted image 20231226230824"  />
</li>
</ul>
</li>
<li>
<p>基于交互的冲突可串行化调度判断算法</p>
<ul>
<li>冲突操作，两个事务针对同一个对象的写写，读写，写读操作</li>
<li>除了冲突操作之外交互相邻的两个操作，如果最终可以形成串行化调度是冲突可串行化调度，否则不是</li>
<li>如果算法判断失败不能一定说明不是可串行化调度，冲突可串行化只是充分条件，而不是必要条件（从维恩图上可知，不是冲突可串行化的有部分在显示可串行化中）</li>
</ul>
</li>
<li>
<p>基于依赖图的冲突可串行化调度判断算法</p>
<ul>
<li>基于交互的算法只能判断两个事务之间的调度是否是冲突可串行化，该算法使用上有很多的局限性</li>
<li>如果两个事务之间有冲突操作，这两个事务使用有向边连接起来。如果最终的依赖图是无环的，说明这些事务的调度是冲突可串行化</li>
<li>由基于交互的算法可知冲突操作的执行顺序不能更改，不可串行化说明事务有冲突操作确定的顺序出现回路
<img loading="lazy" src="/images/Pasted%20image%2020231226232416.png" alt="Pasted image 20231226232416"  />
</li>
</ul>
</li>
</ul>
<h3 id="两段锁协议two-phase-locking2pl">两段锁协议（Two-Phase Locking，2PL）<a hidden class="anchor" aria-hidden="true" href="#两段锁协议two-phase-locking2pl">#</a></h3>
<ul>
<li>仅仅有串行化调度检测方法不够，需要有并发调度协议控制事务执行直接得到一个可串行化调度</li>
<li>使用锁来控制对象上事务的执行顺序
<ul>
<li>独占锁（X锁）在一个对象的写操作前获取</li>
<li>共享锁（S锁）在一个对象的读操作前获取</li>
</ul>
</li>
<li>==有这两种锁的原因==</li>
<li>锁之间有兼容关系，当一个事务T1在一个对象A上已经获取一个锁，另一个事务T2同样在A获取一个不兼容的锁，需要等待T1释放A上的锁后获取
<img loading="lazy" src="/images/Pasted%20image%2020231226233302.png" alt="Pasted image 20231226233302"  />
</li>
<li>事务执行过程分为以下两个阶段
<ul>
<li>增长阶段，只能获取锁</li>
<li>缩小阶段，只能释放锁</li>
</ul>
</li>
<li>==使用两阶段锁协议说明的依赖图是无环的, 事务按照增长阶段的结束时间构成一条链==</li>
<li>缺点
<ul>
<li>级联回滚，T1写A后，T2读A，然后T1回滚时，由于T2读取了T1修改A后的值，也要跟着回滚。使用强两阶段锁（P2PL），事务提交的时候才将所有锁释放。</li>
<li>死锁，当事务需要获取多个锁时，两个事务都获取一部分锁，等待获取对方已经占用的一部分锁。
<ul>
<li>死锁检测。锁等待图，出现环说明死锁，将最轻量的事务（一般是持续锁数量最少得事务）回滚。</li>
<li>死锁预防。
<ul>
<li>优先级，按照事务开始执行时间给事务赋予优先级，高优先级想要低优先级持有的锁时，低优先级事务回滚，高优先级抢占这个锁；低优先级想要高优先级的锁是，低优先级等待高优先级释放锁。</li>
</ul>
</li>
</ul>
</li>
<li>活锁，当多个事务等待获取一个锁使，这个事务总是抢占不到已经释放的锁。这种情况一般不容易出现，先来先服务。</li>
<li>性能，事务执行过程中涉及很多对象。多粒度封锁，==SIX锁==</li>
</ul>
</li>
</ul>
<h3 id="时间戳timestamp-orderingto">时间戳（Timestamp Ordering，T/O）<a hidden class="anchor" aria-hidden="true" href="#时间戳timestamp-orderingto">#</a></h3>
<ul>
<li>时间戳一般使用逻辑时钟，系统时钟精度不够，另外可能因为时间校准而出问题</li>
<li>基本的T/O协议
<ul>
<li>每个事务开始执行前赋予一个时间戳</li>
<li>数据库所有对象有一个读时间戳和写时间戳，即最近操作该对象的事物的时间戳</li>
<li>对象读写事件戳更新规则。相比于2Pl通过特定加锁解锁机制使依赖图自然无环，T/O通过以下规则在依赖图上强制使事务按照时间戳构造一条链
<img loading="lazy" src="/images/Pasted%20image%2020231227114508.png" alt="Pasted image 20231227114508"  />

<img loading="lazy" src="/images/Pasted%20image%2020231227114518.png" alt="Pasted image 20231227114518"  />
</li>
<li>==托马斯写规则==</li>
<li>缺点
<ul>
<li>较长的事务可能饥饿。较长的事务有更多的可能性碰到需要abort的情况，导致这个事务一直执行不完</li>
<li>调度不可恢复。</li>
<li>性能。==事务读任何对象都需要事务本地拷贝一份==</li>
</ul>
</li>
</ul>
</li>
<li>==T/O协议的改进==</li>
</ul>
<h3 id="乐观并发控制occ">==乐观并发控制==（OCC）<a hidden class="anchor" aria-hidden="true" href="#乐观并发控制occ">#</a></h3>
<ul>
<li>阶段
<ul>
<li>读阶段</li>
<li>验证阶段</li>
<li>写阶段</li>
</ul>
</li>
</ul>
<h3 id="多版本并发控制mvcc">多版本并发控制（MVCC）<a hidden class="anchor" aria-hidden="true" href="#多版本并发控制mvcc">#</a></h3>
<ul>
<li>事务T1读取一个被另一个未提交事务T2更新后的对象时，在2PL中需要等待加锁，在T/O中直接回滚T1。MVCC中维护一个对象的多种版本，使得事务任何情况下的读操作都可以顺利进行，一般与其他三种并发控制协议协同作用</li>
</ul>
<h3 id="隔离级别">隔离级别<a hidden class="anchor" aria-hidden="true" href="#隔离级别">#</a></h3>
<ul>
<li>之前讨论的事务操作仅包含读写，但实际上事务也能插入和删除一个对象。幻读问题，事务T1读取表中对象数量之后，事务T2又在该表中插入或者删除对象，使得T2再次读取表中数量两次结果不一致。要实现真正的串行化，还需要解决幻读问题</li>
<li>各种隔离级别
<ul>
<li>读未提交。有脏读，可以看到一个未提交事务所做的修改。</li>
<li>读已提交。有不可重复读，两次读取对象值不一样。保存已经读取的对象值</li>
<li>可重复读。有幻读，两次读取表中对象数量不一样。保存已经读取的表中对象数量</li>
<li>串行化。解决了所有问题</li>
</ul>
</li>
<li>==解决幻读==
<ul>
<li>重新扫描</li>
<li>谓词锁，谓词上加锁</li>
<li>索引锁，</li>
<li>间隙锁</li>
</ul>
</li>
</ul>
<h2 id="数据库设计">数据库设计<a hidden class="anchor" aria-hidden="true" href="#数据库设计">#</a></h2>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<ul>
<li>事务处理方面还有很多不清楚的地方，中文这方面的资料太匮乏了，如果有时间需要进一步阅读资料。</li>
</ul>
<h2 id="问题">问题<a hidden class="anchor" aria-hidden="true" href="#问题">#</a></h2>
<ul>
<li>一致性和完整性</li>
<li>级联和无法恢复</li>
</ul>
<h2 id="参考-1">参考<a hidden class="anchor" aria-hidden="true" href="#参考-1">#</a></h2>
<ul>
<li>数据库系统概论(第5版)</li>
<li><a href="https://15445.courses.cs.cmu.edu/spring2023/schedule.html">15445.courses.cs.cmu.edu/spring2023/schedule.html</a></li>
<li><a href="https://www.zhihu.com/column/c_1470863887393988608">CMU15-445课程笔记 - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.bilibili.com/video/BV1AZ4y1Q7vx/?vd_source=f1b7ffa37a1d59bcc4d8eef80521446c">16-两阶段锁 [中文讲解] CMU-15445 数据库内核_哔哩哔哩_bilibili</a></li>
</ul>
<h2 id="进一步阅读">进一步阅读<a hidden class="anchor" aria-hidden="true" href="#进一步阅读">#</a></h2>
<ul>
<li><a href="https://github.com/oceanbase/miniob">oceanbase/miniob: MiniOB is a compact database that assists developers in understanding the fundamental workings of a database. (github.com)</a> 重要，国内实现数据库管理系统的资料</li>
<li>Database System Concepts 这本书内容比较多，但是有些地方的介绍有些简单</li>
<li>Transaction Processing: Concepts and Techniques 据说这本书对于事物处理内容解释的很好，有时间看一下</li>
<li>sqlite design and implementation 介绍sqlite源码的书</li>
<li><a href="https://huili.github.io/index.html">首页 | SQlite源码分析 (huili.github.io)</a></li>
<li><a href="https://www.zhihu.com/question/22819578">(27 封私信 / 11 条消息) 如何学习sqlite源码？ - 知乎 (zhihu.com)</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://uhuuh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://uhuuh.github.io/posts/mysql/">
    <span class="title">« Prev</span>
    <br>
    <span>MYSQL</span>
  </a>
  <a class="next" href="https://uhuuh.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
    <span class="title">Next »</span>
    <br>
    <span>计算机网络</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 数据库原理 on x"
            href="https://x.com/intent/tweet/?text=%e6%95%b0%e6%8d%ae%e5%ba%93%e5%8e%9f%e7%90%86&amp;url=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E5%258E%259F%25E7%2590%2586%2f&amp;hashtags=%e6%95%b0%e6%8d%ae%e5%ba%93">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 数据库原理 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E5%258E%259F%25E7%2590%2586%2f&amp;title=%e6%95%b0%e6%8d%ae%e5%ba%93%e5%8e%9f%e7%90%86&amp;summary=%e6%95%b0%e6%8d%ae%e5%ba%93%e5%8e%9f%e7%90%86&amp;source=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E5%258E%259F%25E7%2590%2586%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 数据库原理 on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E5%258E%259F%25E7%2590%2586%2f&title=%e6%95%b0%e6%8d%ae%e5%ba%93%e5%8e%9f%e7%90%86">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 数据库原理 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E5%258E%259F%25E7%2590%2586%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 数据库原理 on whatsapp"
            href="https://api.whatsapp.com/send?text=%e6%95%b0%e6%8d%ae%e5%ba%93%e5%8e%9f%e7%90%86%20-%20https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E5%258E%259F%25E7%2590%2586%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 数据库原理 on telegram"
            href="https://telegram.me/share/url?text=%e6%95%b0%e6%8d%ae%e5%ba%93%e5%8e%9f%e7%90%86&amp;url=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E5%258E%259F%25E7%2590%2586%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 数据库原理 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%e6%95%b0%e6%8d%ae%e5%ba%93%e5%8e%9f%e7%90%86&u=https%3a%2f%2fuhuuh.github.io%2fposts%2f%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E5%258E%259F%25E7%2590%2586%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://uhuuh.github.io/">uh</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
