[{"content":" (https://www.cnblogs.com/mxnote/p/17101905.html)[docker启动容器后, 马上结束 - MasonLee - 博客园 (cnblogs.com)] 容器中没有一直运行的进程的会自动退出 网络 (Docker的4种网络模式-阿里云开发者社区)[https://developer.aliyun.com/article/653905] 提供如下网络模式\nhost 与宿主机在一个网络环境 container 与一个容器在一个网络环境 bridge 连接到一个网络空间中。默认模式 none 与外部没有网路连接 bridge模式通信，依靠linux的网络命名空间实现\n容器之间通信 运行容器时通过name选项指定主机名，再通过dns解析到合适的容器ip地址 宿主机访问容器 运行容器时通过p选项指定要暴露的端口 容器访问宿主机 通过host.docker.internal域名，再通过dns解析到合适的宿主机环回网卡ip地址 ","permalink":"https://uhuuh.github.io/posts/docker/","summary":" (https://www.cnblogs.com/mxnote/p/17101905.html)[docker启动容器后, 马上结束 - MasonLee - 博客园 (cnblogs.com)] 容器中没有一直运行的进程的会自动退出 网络 (Docker的4种网络模式-阿里云开发者社区)[https://developer.aliyun.com/article/653905] 提供如下网络模式\nhost 与宿主机在一个网络环境 container 与一个容器在一个网络环境 bridge 连接到一个网络空间中。默认模式 none 与外部没有网路连接 bridge模式通信，依靠linux的网络命名空间实现\n容器之间通信 运行容器时通过name选项指定主机名，再通过dns解析到合适的容器ip地址 宿主机访问容器 运行容器时通过p选项指定要暴露的端口 容器访问宿主机 通过host.docker.internal域名，再通过dns解析到合适的宿主机环回网卡ip地址 ","title":"docker"},{"content":"总览\n阻塞就是发起读取数据请求的时，当数据还没准备就绪的时候，这时请求是即刻返回，还是在这里等待数据的就绪，如果需要等待的话就是阻塞，反之如果即刻返回就是非阻塞 在IO模型里面如果请求方从发起请求到数据最后完成的这一段过程中都需要自己参与，那么这种我们就称为同步请求；反之，如果应用发送完指令后就不再参与过程了，只需要等待最终完成结果的通知，那么这就属于异步 阻塞IO\n调用read时, 将进程添加进socket的等待队列中 网卡接受到数据时触发中断, 保存网络数据到socket的缓存中, 唤醒等待队列中的进程 非阻塞IO\n多路复用IO\nselect 使用一个位数组保存监听的一系列socket, 该位数组中第i位为1时, 说明监听fd为i的socket 调用时, 将位数组复制到内核中, 依次检查位数组中的有效socket是否有可处理事件, 如果有可处理事件在另一个位数组中好对应的socket, 返回 缺点 监听的socket数量有限, 因为位数组的长度有限, 内核代码有限制位数组的最大长度 调用开销大, 每次调用都需要把位数组复制到内核中 调用时检查开销大, 每次检查时需要依次遍历位数组上的所有有效socket, 其开销与监听的socket呈线性关系 poll 克服了select的第一个缺点, 使用一个链表保存监听所有的socket epoll 在poll的基础上克服了select剩下的第二个和第三个缺点 内核内部维护一个红黑树和一个等待队列, 红黑树保存了d到监听事件的对应关系, 等待队列保存了有效的fd fd有效时, 将该fd添加到等待队列中 信号驱动IO\n当数据就绪时, 内核给应用发送一个信号, 应用调用信号处理函数, 该函数中调用read将数据从内核缓存区复制到应用缓存区 异步IO\n当数据就绪时, 内核将数据从内核缓存区复制到应用缓存区, 然后给应用发送一个信号 与信号驱动IO区别是, 内核将数据从内核缓存区复制到应用缓存区 问题 为什么select调用时要将位数组复制到内核, 内核使用位数组的指针不行吗? 是出于安全的考虑吗 socket细节, fd细节 参考 看一遍就理解：IO 模型详解-常用的io模型 (51cto.com) 五种IO模型介绍 100%弄明白5种IO模型 - 知乎 (zhihu.com) 最后部分中阻塞与非阻塞介绍, 同步与非同步介绍 IO多路复用——深入浅出理解select、poll、epoll的实现 - 知乎 (zhihu.com) 三种多路复用IO介绍\u0026mdash; ","permalink":"https://uhuuh.github.io/posts/linux-io%E6%A8%A1%E5%9E%8B/","summary":"总览\n阻塞就是发起读取数据请求的时，当数据还没准备就绪的时候，这时请求是即刻返回，还是在这里等待数据的就绪，如果需要等待的话就是阻塞，反之如果即刻返回就是非阻塞 在IO模型里面如果请求方从发起请求到数据最后完成的这一段过程中都需要自己参与，那么这种我们就称为同步请求；反之，如果应用发送完指令后就不再参与过程了，只需要等待最终完成结果的通知，那么这就属于异步 阻塞IO\n调用read时, 将进程添加进socket的等待队列中 网卡接受到数据时触发中断, 保存网络数据到socket的缓存中, 唤醒等待队列中的进程 非阻塞IO\n多路复用IO\nselect 使用一个位数组保存监听的一系列socket, 该位数组中第i位为1时, 说明监听fd为i的socket 调用时, 将位数组复制到内核中, 依次检查位数组中的有效socket是否有可处理事件, 如果有可处理事件在另一个位数组中好对应的socket, 返回 缺点 监听的socket数量有限, 因为位数组的长度有限, 内核代码有限制位数组的最大长度 调用开销大, 每次调用都需要把位数组复制到内核中 调用时检查开销大, 每次检查时需要依次遍历位数组上的所有有效socket, 其开销与监听的socket呈线性关系 poll 克服了select的第一个缺点, 使用一个链表保存监听所有的socket epoll 在poll的基础上克服了select剩下的第二个和第三个缺点 内核内部维护一个红黑树和一个等待队列, 红黑树保存了d到监听事件的对应关系, 等待队列保存了有效的fd fd有效时, 将该fd添加到等待队列中 信号驱动IO\n当数据就绪时, 内核给应用发送一个信号, 应用调用信号处理函数, 该函数中调用read将数据从内核缓存区复制到应用缓存区 异步IO\n当数据就绪时, 内核将数据从内核缓存区复制到应用缓存区, 然后给应用发送一个信号 与信号驱动IO区别是, 内核将数据从内核缓存区复制到应用缓存区 问题 为什么select调用时要将位数组复制到内核, 内核使用位数组的指针不行吗? 是出于安全的考虑吗 socket细节, fd细节 参考 看一遍就理解：IO 模型详解-常用的io模型 (51cto.com) 五种IO模型介绍 100%弄明白5种IO模型 - 知乎 (zhihu.com) 最后部分中阻塞与非阻塞介绍, 同步与非同步介绍 IO多路复用——深入浅出理解select、poll、epoll的实现 - 知乎 (zhihu.","title":"Linux IO模型"},{"content":"查询优化 表底层使用B+树存储，树的节点是内存页，页内有多条记录，页按照主键值排序。表上的索引也是按照B+树存储，存储索引值和主键值。由于表和索引有类似的结构，表页叫聚簇索引，索引也叫二级索引。查询时使用到了索引，找到索引值和主键值，再根据主键值回聚簇索引找到对应的记录，这个过程叫回表，这也是二级索引名字的由来。 索引本身很复杂，可以有一列或者多列组成，也可以施加非空约束，施加唯一约束。主键实际上就是非空唯一索引 单表查询方法 查询只考虑设计单表，根据查询语句和表上信息可能做出一下区分 单索引时\n以下将主键视作非空唯一索引 多列索引当查询中只涉及前面几列时可以利用索引加快查询 查询类型 查询条件 说明 const 非空唯一索引等值查询 只需找到一条记录 ref 索引等值查询 由于索引不唯一，可能找到多条索引 ref_or_null 索引等值或为空查询 range 索引多个搜索区间查询 index 索引复杂查询 复杂查询中可能使用内置函数、多列索引使用后面几列，LIKE操作设定后面字符等。select的列都能在索引中找到 all 索引复杂查询 双索引时\n如果可以索引合并\nintersection，需要涉及索引顺序与主键一致。实现类似求两个有序数组的交集，不相等时丢掉小的元素，相等时加入结果数组中 union，需要涉及索引顺序与主键一致。实现类似求两个有序数组的并集，不相等时小的元素加入结果集，相等时任意丢掉一个元素 sort-union，不需要涉及索引顺序与主键一致。从A表中取所有合法记录，再从B表中取所有合法记录，两处合法记录排序后合并 否则就全表扫描，index或者all\n索引合并时需要索引涉及顺序与主键一致时，常见于等值查询，二级索引等值后再按照主键值排序\n==没有sort-intersection==\n即便是单表查询，查询语句很复杂，索引也有很多类型，好像很难解析单表查询语句得到具体的执行方法\n多表连接 两表连接，实际上定义一个与两表相关联的条件，求满足该条件的两表笛卡尔积子集。实现时一个表A作为驱动表，另一个表B作为被驱动表，每次从A中选择一个记录，再从B中选择满足条件的所有记录。所以驱动表只需要遍历一次，被驱动表要遍历多次 存在四种连接，内连接，左外连接，右外连接，全连接。这些连接在与驱动表的选择和连接条件的处理方式上不同。内连接对于连接条件不满足的记录不会显示在结果表中，其他连接则会，结果表中不满足的地方是空值代替。 sql在on语句中指定连接条件。由于内节点不满足该条件记录不显示结果表中，on作用与where作用一致，故内连接的on语句可以省略。 嵌套循环连接算法 从两表中选择一个查询代价小的表A作为驱动表，根据where中只涉及单表的查询语句进行判断 根据where中只涉及表A的查询语句，每次从驱动表获取一个合法记录 根据where中只涉及表B的查询语句（由于已经确定表A的一个记录，where中涉及两表的查询语句也转化成单表查询语句），每次从被驱动表中获取一个合法记录 依据连接类型和这两个记录是否满足on条件，决定结果是否返回两个记录连接和表B记录是否为空 重复上述过程，直到找到所有连接记录。处于节省内存的考虑，迭代式返回连接记录，但是运算速度稍慢。 基于块的嵌套循环连接算法 一次选择驱动表中多个合法记录，同时与被驱动表中的合法记录进行匹配，加快连接算法 数据库表连接的简单解释 - 阮一峰的网络日志 (ruanyifeng.com) 查询优化 成本主要分为cpu和io成本，cpu成本是判断记录是否满足条件的成本，io成本是读取页的成本\nall的成本。聚簇索引页数 * io常数 + 记录总数 * cpu常数，其中依次是加载聚簇索引页、读取聚簇索引页内容的成本 range的成本。扫描区间总页数 * io常数 + 扫描区间总记录数 * cpu常数 + 扫描区间总记录数 * io常数 + 扫描区间总记录数 * cpu常数，其中依次是加载二级索引页，读取二级索引页内容，根据每个二级索引页内容回表时加载聚簇索引页，读取聚簇索引页内容的成本 其中确定扫描总页数。需要根据区间左边界在二级索引中找到对应页，右边界同理。再根据左右边界页向上搜索到公共页，确定左右边界页中间一共有多少页 其中当单点扫描区间太多时，根据表的统计数据确定重复比例，大概确定单点区间中有多少记录和多少页 两表连接的成本。驱动表成本+驱动表合法记录数量 * 被驱动表成本 其中驱动表合法记录数量也叫扇出量 多表连接的成本。如果连接表的数量过少，直接穷举所有可能的连接，阶乘复杂度。否则使用某种启发式搜索算法 事务 事务需要满足一下四大特性\nA 原子性. 一个事务最终要么执行成功, 要么执行失败, 没有第三种可能\nC 一致性. 如果事务最终执行成功, 数据库从上一个一致性的状态转移到下一个一致性的状态. 否则, 数据库恢复到事务执行前的一致性状态\nI 隔离性. 多个事务并发执行的时候, 事务的执行不会因此被影响到\nD 持久性. 事务执行成功后造成的影响是持久化的, 不会因为宕机等而失效\n状态是一致性的, 说明??\n事务为什么只有这4大特性\n执行事务出现错误，不回滚\n并发事务问题 数据库一般需要为多个用户提供服务，多个事务并发执行的过冲中可能导致以下问题：\n脏写，事务A修改记录x，事务B同样修改x，A回滚后x恢复旧值，导致B的修改失效\n脏读，事务A修改记录x，事务B读取记录x，A回滚后x恢复旧值，导致B再次读有不一样的值\n不可重复读，事务A读取记录x，事务B修改记录x后提交，导致A再次读x有不一样的值\n幻读，事务A读取表x，事务B在表x中增加或者删除记录后提交，导致A再次读取表x的记录数量不一样\n脏读和脏写都是由另一个事务回滚导致，仅仅涉及了改查，没有涉及增删（不可重复读和幻读涉及了增删查改四种）\n上述分类严重程度依次递减，在事务执行中写失效，多次读记录内容不一样，多次读表记录数量不一样\n脏写对业务影响比较大，一般不被允许\n脏读和脏写是两个事务交叉执行然后其中一个事务回滚造成. 不可重复读和幻读是一个事务内开始执行并提交另一个事务造成. 还有其他情况可能出现问题吗\n如果事务A修改记录x，事务B删除记录x，然后事务A回滚这时候记录x会发生什么\n为什么脏读比不可重复读更严重\n隔离级别 针对出现的不同严重程度的并发事务问题，处于对数据库并发服务性能的考虑，提出以下不同的隔离级别：\n读未提交，最高解决脏写 读已提交，最高解决脏读 可重复读，最高解决不可重复读 串行化，最高解决幻读。即解决所有的并发事务可能导致的问题，但是数据库并发服务的能力比较差 事务并发执行过程中导致的冲突大致上可以分为以下三类\n写写，脏写，==丢失更新== 写读，脏读 读写，不可重复读，幻读 各种语句。 ==可能是因为基于MVCC的快照读本身可能有不一致问题，然后实际业务中可能也需要当前读，所以mysql将两种读都提供给用户==\n一致性读（快照读） 非一致性锁定读（当前读） share型 update型，另外包括更新，删除和插入操作 MVCC中，首先需要记录保存历史版本，事务启用read view（事务根据开始执行时刻依次赋予一个逻辑id，read view中记录了当前活跃的所有事务id），基于read view选择记录的历史版本进行读取\n锁分类\n按照封锁对象级别 行级锁，记录锁，间隙锁，临键锁（记录锁+间隙锁），==插入意向锁== ==表级锁，自增锁，意向锁等== 按照性质 共享锁 独占锁 共享意向锁 独占意向锁 ==在不同隔离级别下不同操作下的情况==\n隔离级别 快照读操作 share当前读操作 update当前读操作 更新操作 删除操作 插入操作 读未提交 最新版本 记录X锁 记录X锁 记录X锁 记录X锁 读已提交 MVCC（读开始前生成read view) 记录S锁 记录X锁 记录X锁 记录X锁 记录X锁 可重复读 MVCC（所有操作执行前生成read view） 记录S锁 记录X锁+间隙锁 记录X锁+间隙锁 记录X锁+间隙锁 记录X锁+间隙锁 可序列化 ==可重复读时，依据当前读查询语句的不同，记录锁和间隙锁在不同的加锁情况==\n总结 问题 MVCC的实现的快照隔离，有写偏序问题 mysql使用的mvcc和锁协议和数据库系统概念那本书上的MVCC结合两段锁协议内容有出入 mysql在可重复读级别中快照读中通过MVCC，当前读中通过间隙锁，一定程度上可以减少幻读的发生。但是两种读操作种都不能完全避免幻读 参考 MySQL是怎样运行的 图解MySQL介绍 | 小林coding (xiaolincoding.com) mysql - InnoDB 的并发控制：锁与 MVCC - nullwy\u0026rsquo;s blog - SegmentFault 思否 一文读懂MySQL的MVCC及实现原理 - 知乎 (zhihu.com) 当前读与快照读的区别联系 MySQL读锁的区别和应用场景分析-腾讯云开发者社区-腾讯云 (tencent.com) 两种当前读的使用场景，但还是没看懂 ","permalink":"https://uhuuh.github.io/posts/mysql/","summary":"查询优化 表底层使用B+树存储，树的节点是内存页，页内有多条记录，页按照主键值排序。表上的索引也是按照B+树存储，存储索引值和主键值。由于表和索引有类似的结构，表页叫聚簇索引，索引也叫二级索引。查询时使用到了索引，找到索引值和主键值，再根据主键值回聚簇索引找到对应的记录，这个过程叫回表，这也是二级索引名字的由来。 索引本身很复杂，可以有一列或者多列组成，也可以施加非空约束，施加唯一约束。主键实际上就是非空唯一索引 单表查询方法 查询只考虑设计单表，根据查询语句和表上信息可能做出一下区分 单索引时\n以下将主键视作非空唯一索引 多列索引当查询中只涉及前面几列时可以利用索引加快查询 查询类型 查询条件 说明 const 非空唯一索引等值查询 只需找到一条记录 ref 索引等值查询 由于索引不唯一，可能找到多条索引 ref_or_null 索引等值或为空查询 range 索引多个搜索区间查询 index 索引复杂查询 复杂查询中可能使用内置函数、多列索引使用后面几列，LIKE操作设定后面字符等。select的列都能在索引中找到 all 索引复杂查询 双索引时\n如果可以索引合并\nintersection，需要涉及索引顺序与主键一致。实现类似求两个有序数组的交集，不相等时丢掉小的元素，相等时加入结果数组中 union，需要涉及索引顺序与主键一致。实现类似求两个有序数组的并集，不相等时小的元素加入结果集，相等时任意丢掉一个元素 sort-union，不需要涉及索引顺序与主键一致。从A表中取所有合法记录，再从B表中取所有合法记录，两处合法记录排序后合并 否则就全表扫描，index或者all\n索引合并时需要索引涉及顺序与主键一致时，常见于等值查询，二级索引等值后再按照主键值排序\n==没有sort-intersection==\n即便是单表查询，查询语句很复杂，索引也有很多类型，好像很难解析单表查询语句得到具体的执行方法\n多表连接 两表连接，实际上定义一个与两表相关联的条件，求满足该条件的两表笛卡尔积子集。实现时一个表A作为驱动表，另一个表B作为被驱动表，每次从A中选择一个记录，再从B中选择满足条件的所有记录。所以驱动表只需要遍历一次，被驱动表要遍历多次 存在四种连接，内连接，左外连接，右外连接，全连接。这些连接在与驱动表的选择和连接条件的处理方式上不同。内连接对于连接条件不满足的记录不会显示在结果表中，其他连接则会，结果表中不满足的地方是空值代替。 sql在on语句中指定连接条件。由于内节点不满足该条件记录不显示结果表中，on作用与where作用一致，故内连接的on语句可以省略。 嵌套循环连接算法 从两表中选择一个查询代价小的表A作为驱动表，根据where中只涉及单表的查询语句进行判断 根据where中只涉及表A的查询语句，每次从驱动表获取一个合法记录 根据where中只涉及表B的查询语句（由于已经确定表A的一个记录，where中涉及两表的查询语句也转化成单表查询语句），每次从被驱动表中获取一个合法记录 依据连接类型和这两个记录是否满足on条件，决定结果是否返回两个记录连接和表B记录是否为空 重复上述过程，直到找到所有连接记录。处于节省内存的考虑，迭代式返回连接记录，但是运算速度稍慢。 基于块的嵌套循环连接算法 一次选择驱动表中多个合法记录，同时与被驱动表中的合法记录进行匹配，加快连接算法 数据库表连接的简单解释 - 阮一峰的网络日志 (ruanyifeng.com) 查询优化 成本主要分为cpu和io成本，cpu成本是判断记录是否满足条件的成本，io成本是读取页的成本\nall的成本。聚簇索引页数 * io常数 + 记录总数 * cpu常数，其中依次是加载聚簇索引页、读取聚簇索引页内容的成本 range的成本。扫描区间总页数 * io常数 + 扫描区间总记录数 * cpu常数 + 扫描区间总记录数 * io常数 + 扫描区间总记录数 * cpu常数，其中依次是加载二级索引页，读取二级索引页内容，根据每个二级索引页内容回表时加载聚簇索引页，读取聚簇索引页内容的成本 其中确定扫描总页数。需要根据区间左边界在二级索引中找到对应页，右边界同理。再根据左右边界页向上搜索到公共页，确定左右边界页中间一共有多少页 其中当单点扫描区间太多时，根据表的统计数据确定重复比例，大概确定单点区间中有多少记录和多少页 两表连接的成本。驱动表成本+驱动表合法记录数量 * 被驱动表成本 其中驱动表合法记录数量也叫扇出量 多表连接的成本。如果连接表的数量过少，直接穷举所有可能的连接，阶乘复杂度。否则使用某种启发式搜索算法 事务 事务需要满足一下四大特性","title":"MYSQL"},{"content":"绪论 数据的存储从文件系统过渡到数据库, 数据库相比于文件系统有以下优点\n文件系统 数据库 数据结构化 数据描述由应用的程序负责 引入逻辑模型由数据库本身维护数据描述 数据共享和独立性 针对不同的应用使用不同的文件保存数据 所有应用统一保存数据, 不同应用的数据之间尽可能共享, 提供三级模式为不同应用提供数据视图 实体是现实中可区分的事物 实体具有一系列属性来描述自己 码是一个或者多个特殊实体属性, 可以区分一个实体. 实体可能具有多个码 实体之间有联系, 比如实体之间的一一对应, 一对多, 多对一, 多对多 数据是事物的符号化化描述 实体型是一个实体的属性集合, 实体集是同一类型实体型的集合. 实体型和实体集都可视作数据 数据模型用来描述数据, 按不同的层次有以下三种\n概念模型, 一般使用ER图, 描述实体有哪些数据和实体之间的联系 逻辑模型, 有对象, 网状和关系多种. 概念模型描述了数据对应实体的属性和实体之间联系, 而逻辑模型进一步规定了数据结构, 数据操作数据完整性约束 物理模型, 进一步确定了数据是如何存储的, ==一般采用三级模式结构== 外模式, 可以为不同的应用提供不同的逻辑视图 模式, 所有数据的统一逻辑视图 内模式, 数据的具体存储方式, 一般多个外模式对应一个模式 , 一个模式对应一个内模式 与书的不同\n==数据模型与模式是两个独立的概念, 把模式放在物理模型方面感觉更好些== 数据模型的三要素(数据结构, 操作和完整性约束)也是只放在了逻辑模型中 关系数据库 关系数据库是采用关系逻辑模型的数据库\n数据结构\n关系是数据的存储方式, 简单来说就是一张表, 表里面保存了一个实体集, 表中每一行是一个实体的各个属性, 同时实体与实体之间的联系也能以关系方式存储, 更形式来说关系是所有属性取值集合的笛卡尔积的子集 关系中有如下概念 域是某个属性的取值集合 候选码是可以标识实体的属性组, 其子集不能标识实体. 一个实体可能有多个候选码, 候选码中可能包含多个属性 主属性是在候选码中的属性, 其他属性是非主属性 数据操作方法\n支持关系上的增删查改 查询包含选择, 投影, 并, 差和笛卡尔积这五种基本操作, 其他查询操作可以通过组合这些基本操作得到 操作的对象和结果都是关系 具体操作工具 关系代数 集合运算, 并差交笛卡尔积 关系运算, 选择, 投影, 连接和除 关系演算 元组关系演算 域关系演算 结构化查询语言(SQL), 结合上述两者, 后面出现现在普遍使用, SQL额外支持数据定义和数据控制 数据完整性定义\n具体有以下三种 实体完整性, 关系中的主属性非空且唯一 ==参照完整性, ???== 用户自定义完整性 在数据库执行增删改操作之后, 检查是否满足完整性约束 数据库完整性 为了维护数据库的完整性, 需要数据库管理系统提供定义完整性约束条件, 检查完整性, 提供完整性违约处理\n实体完整性 创建表时指定主键 插入新纪录时检查, 该纪录主键已存在则插入失败 参照完整性 创建表时有指定外键 在参照表中新增或者修改一条记录, 该纪录的外键在被参照表中找不到, 操作失败 在被参照表中删除或者修改一条记录, 使得参照表中存在记录外键对应失败, 有三种违约处理策略, 分别是拒绝操作, 级联修改和设置空值 用户定义完整性 创建表时指定某个列唯一或非空, 或者一条记录需要满足某个条件 使用断言 使用触发器, 触发器有事件条件动作组成, 事件一般指的是某个表的增删改操作 违反用户定义完整性时, 操作失败 关系的规范化理论 ER图可以建模实体之间的关系，被参考建表，一个实体或者一个多对多关系是一张表。实体的内部属性之间也存在依赖（数据依赖），不对这些依赖进行分析和处理而简单根据实体建表，能造成数据冗余和操作异常。关系的规范化理论对属性的数据依赖进行分析和处理，提出一些范式，范式对实体表中进行拆分以降低数据冗余和操作异常。\n数据依赖\n函数依赖 属性组U中有属性集合X和Y，Y函数依赖X，说明在任意两个元组中X的取值相等时Y的取值也相等，也能说X决定Y 平凡函数依赖 Y是X的子集 非平凡函数依赖 一般情况下都默认非平凡函数依赖 部分函数依赖 完全函数依赖 如果有X的任意真子集Z，Z不能决定Y 传递函数依赖 如果X决定Y，Y决定Z，则X决定Z ==多值依赖== ==连接依赖== ==数据冗余和操作异常==\n数据冗余 插入异常 因为一些情况不能插入 删除异常 更新异常 概念\n候选码（码） 属性组，可以决定整个所有属性。一个关系中可能有多个码 主属性 属性，该属性是任意一个码中的属性 外码 属性组，非本关系上的码，而是其他关系上的码 非主属性 属性，属性组中除主属性之外的其他属性 范式\n高范式同时满足低范式 高范式可以减少数据冗余和操作异常，但是由于表拆分的太细，现实中经常需要连接多个表实现业务需求，造成计算上的损耗。现实中实现到什么级别的范式需要再时间和空间之间取舍 现实中一般设计到第三范式或者BC范式 BC范式在函数依赖的范畴上消除了操作异常 范式分类 第一范式 每个属性都不可再分 第二范式 在满足第一范式的情况下，消除非主属性对码的部分函数依赖，即非主属性完全函数依赖主属性 第三范式 在满足第一范式的情况下，消除非主属性对码的传递函数依赖 BC范式 在满足第一范式的情况下，消除主属性对码的部分和传递函数依赖 ==第四范式== ==部分函数依赖和传递函数依赖一定会造成数据冗余和操作异常吗==\n参考 数据依赖的公理系统_哔哩哔哩_bilibili 比配到书讲得清晰 【哈工大】数据库系统 战德臣（全23讲）哔哩哔哩_bilibili 更偏理论一些 数据库恢复 并发控制 事务是为了实现某个业务的一系列SQL语句集合。 事务的出现是一件很自然的事情，现实生活中一个业务常常需要一系列SQL语句实现。事务也是DBMS执行的最基本单位 为了使DBMS更好用，希望DBMS支持同时执行多个事务的能力。由于事务执行之间可能产生影响，使用ACID这四个特性用来衡量事务执行的正确性 为了实现事务的隔离性，就需要数据库的并发控制机制去决定事务之间的交错的执行是以怎样的一个顺序/时间表来进行，不可以随意地交错执行。实现并发控制有两大流派：\n悲观协议：不要让问题发生，在问题出现之前就让线程停住 乐观协议：假设并发的冲突是少数的，只在问题出现之后再去回滚 事务可串行化调度检测 在简化的系统上讨论并发事务的执行，事务由一系列对数据库对象的读操作和写操作组成\n多个事务并发执行顺序（调度）可能违反数据库的一致性\n串行化调度，一个事务的操作接着一个事务的操作执行，显然不违反数据库的一致性\n可串行化调度，执行效果等价为一种串行化调度的执行效果，也不违反数据库的一致性\n显示可串行化调度，基于观察判断 冲突可串行化调度，基于规则判断 基于交互的冲突可串行化调度判断算法\n冲突操作，两个事务针对同一个对象的写写，读写，写读操作 除了冲突操作之外交互相邻的两个操作，如果最终可以形成串行化调度是冲突可串行化调度，否则不是 如果算法判断失败不能一定说明不是可串行化调度，冲突可串行化只是充分条件，而不是必要条件（从维恩图上可知，不是冲突可串行化的有部分在显示可串行化中） 基于依赖图的冲突可串行化调度判断算法\n基于交互的算法只能判断两个事务之间的调度是否是冲突可串行化，该算法使用上有很多的局限性 如果两个事务之间有冲突操作，这两个事务使用有向边连接起来。如果最终的依赖图是无环的，说明这些事务的调度是冲突可串行化 由基于交互的算法可知冲突操作的执行顺序不能更改，不可串行化说明事务有冲突操作确定的顺序出现回路 两段锁协议（Two-Phase Locking，2PL） 仅仅有串行化调度检测方法不够，需要有并发调度协议控制事务执行直接得到一个可串行化调度 使用锁来控制对象上事务的执行顺序 独占锁（X锁）在一个对象的写操作前获取 共享锁（S锁）在一个对象的读操作前获取 ==有这两种锁的原因== 锁之间有兼容关系，当一个事务T1在一个对象A上已经获取一个锁，另一个事务T2同样在A获取一个不兼容的锁，需要等待T1释放A上的锁后获取 事务执行过程分为以下两个阶段 增长阶段，只能获取锁 缩小阶段，只能释放锁 ==使用两阶段锁协议说明的依赖图是无环的, 事务按照增长阶段的结束时间构成一条链== 缺点 级联回滚，T1写A后，T2读A，然后T1回滚时，由于T2读取了T1修改A后的值，也要跟着回滚。使用强两阶段锁（P2PL），事务提交的时候才将所有锁释放。 死锁，当事务需要获取多个锁时，两个事务都获取一部分锁，等待获取对方已经占用的一部分锁。 死锁检测。锁等待图，出现环说明死锁，将最轻量的事务（一般是持续锁数量最少得事务）回滚。 死锁预防。 优先级，按照事务开始执行时间给事务赋予优先级，高优先级想要低优先级持有的锁时，低优先级事务回滚，高优先级抢占这个锁；低优先级想要高优先级的锁是，低优先级等待高优先级释放锁。 活锁，当多个事务等待获取一个锁使，这个事务总是抢占不到已经释放的锁。这种情况一般不容易出现，先来先服务。 性能，事务执行过程中涉及很多对象。多粒度封锁，==SIX锁== 时间戳（Timestamp Ordering，T/O） 时间戳一般使用逻辑时钟，系统时钟精度不够，另外可能因为时间校准而出问题 基本的T/O协议 每个事务开始执行前赋予一个时间戳 数据库所有对象有一个读时间戳和写时间戳，即最近操作该对象的事物的时间戳 对象读写事件戳更新规则。相比于2Pl通过特定加锁解锁机制使依赖图自然无环，T/O通过以下规则在依赖图上强制使事务按照时间戳构造一条链 ==托马斯写规则== 缺点 较长的事务可能饥饿。较长的事务有更多的可能性碰到需要abort的情况，导致这个事务一直执行不完 调度不可恢复。 性能。==事务读任何对象都需要事务本地拷贝一份== ==T/O协议的改进== ==乐观并发控制==（OCC） 阶段 读阶段 验证阶段 写阶段 多版本并发控制（MVCC） 事务T1读取一个被另一个未提交事务T2更新后的对象时，在2PL中需要等待加锁，在T/O中直接回滚T1。MVCC中维护一个对象的多种版本，使得事务任何情况下的读操作都可以顺利进行，一般与其他三种并发控制协议协同作用 隔离级别 之前讨论的事务操作仅包含读写，但实际上事务也能插入和删除一个对象。幻读问题，事务T1读取表中对象数量之后，事务T2又在该表中插入或者删除对象，使得T2再次读取表中数量两次结果不一致。要实现真正的串行化，还需要解决幻读问题 各种隔离级别 读未提交。有脏读，可以看到一个未提交事务所做的修改。 读已提交。有不可重复读，两次读取对象值不一样。保存已经读取的对象值 可重复读。有幻读，两次读取表中对象数量不一样。保存已经读取的表中对象数量 串行化。解决了所有问题 ==解决幻读== 重新扫描 谓词锁，谓词上加锁 索引锁， 间隙锁 数据库设计 总结 事务处理方面还有很多不清楚的地方，中文这方面的资料太匮乏了，如果有时间需要进一步阅读资料。 问题 一致性和完整性 级联和无法恢复 参考 数据库系统概论(第5版) 15445.courses.cs.cmu.edu/spring2023/schedule.html CMU15-445课程笔记 - 知乎 (zhihu.com) 16-两阶段锁 [中文讲解] CMU-15445 数据库内核_哔哩哔哩_bilibili 进一步阅读 oceanbase/miniob: MiniOB is a compact database that assists developers in understanding the fundamental workings of a database. (github.com) 重要，国内实现数据库管理系统的资料 Database System Concepts 这本书内容比较多，但是有些地方的介绍有些简单 Transaction Processing: Concepts and Techniques 据说这本书对于事物处理内容解释的很好，有时间看一下 sqlite design and implementation 介绍sqlite源码的书 首页 | SQlite源码分析 (huili.github.io) (27 封私信 / 11 条消息) 如何学习sqlite源码？ - 知乎 (zhihu.com) ","permalink":"https://uhuuh.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/","summary":"绪论 数据的存储从文件系统过渡到数据库, 数据库相比于文件系统有以下优点\n文件系统 数据库 数据结构化 数据描述由应用的程序负责 引入逻辑模型由数据库本身维护数据描述 数据共享和独立性 针对不同的应用使用不同的文件保存数据 所有应用统一保存数据, 不同应用的数据之间尽可能共享, 提供三级模式为不同应用提供数据视图 实体是现实中可区分的事物 实体具有一系列属性来描述自己 码是一个或者多个特殊实体属性, 可以区分一个实体. 实体可能具有多个码 实体之间有联系, 比如实体之间的一一对应, 一对多, 多对一, 多对多 数据是事物的符号化化描述 实体型是一个实体的属性集合, 实体集是同一类型实体型的集合. 实体型和实体集都可视作数据 数据模型用来描述数据, 按不同的层次有以下三种\n概念模型, 一般使用ER图, 描述实体有哪些数据和实体之间的联系 逻辑模型, 有对象, 网状和关系多种. 概念模型描述了数据对应实体的属性和实体之间联系, 而逻辑模型进一步规定了数据结构, 数据操作数据完整性约束 物理模型, 进一步确定了数据是如何存储的, ==一般采用三级模式结构== 外模式, 可以为不同的应用提供不同的逻辑视图 模式, 所有数据的统一逻辑视图 内模式, 数据的具体存储方式, 一般多个外模式对应一个模式 , 一个模式对应一个内模式 与书的不同\n==数据模型与模式是两个独立的概念, 把模式放在物理模型方面感觉更好些== 数据模型的三要素(数据结构, 操作和完整性约束)也是只放在了逻辑模型中 关系数据库 关系数据库是采用关系逻辑模型的数据库\n数据结构\n关系是数据的存储方式, 简单来说就是一张表, 表里面保存了一个实体集, 表中每一行是一个实体的各个属性, 同时实体与实体之间的联系也能以关系方式存储, 更形式来说关系是所有属性取值集合的笛卡尔积的子集 关系中有如下概念 域是某个属性的取值集合 候选码是可以标识实体的属性组, 其子集不能标识实体. 一个实体可能有多个候选码, 候选码中可能包含多个属性 主属性是在候选码中的属性, 其他属性是非主属性 数据操作方法","title":"数据库原理"},{"content":" 一个网卡（网络接口，网络适配器）有mac地址、ip地址和子网掩码 在linux中一个有两个网络，一个是虚拟的环回网卡，另一个是可通外网的外网网卡。环回网卡的mac地址全0 在window中好像没有环回网卡，但是环回地址也能正常使用 当socket监听地址为0.0.0.0时，会同时监听来自多个网卡上的数据 局域网数据发送 局域网数据发送有多种实现方式，一般常见是以太网 在以太网中，设备通过总线连接在一起，每个设备有mac地址进行标识 系统上只会使用ip地址进行通信，Address Resolution Protocol协议（arp）可以向机器的ip地址转化为mac地址。 查询arp表如果存在目标ip地址到目标mac地址的映射，同时这个创建时间比较新，使用该映射将目标ip地址转化为目标mac地址 否则发送以太网广播数据包，其中有本机ip，本机mac和目标ip 目标机器接受到该数据包后，存储该发送ip到发送mac的映射到自己的arp表中，同时发送一个单播以太网包，其中包含自己的mac地址。发送方收到该以太网包后，补全相应映射 其他机器接受到该数据包后，仅仅存储发送ip到发送mac的映射到自己arp表中 集线器、网桥、交换机的区别（详解干货！！！） - 知乎 (zhihu.com) 集线器将每个端口与其他端口连接起来，工作在物理层。 网桥和交换器在链路层，可以减少单播消息过程中广播的次数 网桥自动建立转化表。比如当有mac1从port1来，在端口表上建立mac1到port1的映射。如果有一个局域消息是目标地址是mac1，如果转发表中存在相应映射，将其转发到port1，否则对除了发送端口外的其他端口都进行转发 交换器是网桥的细化，在单播消息过程中的广播次数更有效。网桥学习到一个端口中有哪些mac地址，交换机学习到一个端口有哪一个mac地址 互联网数据发送 机器发送 若发送方ip在环回子网中时，数据包发往环回网卡 若发送方ip在同一个子网时，根据arp协议得到对方mac地址，按局域网方式发送 若发送方ip不在同一个子网时，根据arp协议得到网关mac地址，按局域网方式发送 当机器上存在多个网卡时，根据系统配置的路由表决定数据包分发到哪个网卡上，并且其上一般有个默认路由 网关（路由器）转发 查询路由表找到下一跳ip、下一跳mac地址和端口，将数据包中接受方ip转化为下一跳ip后，转发到相应端口按局域网方式发送 显而易见，路由器一般有多个端口，每个端口对应一个网卡 路由器的路由表建立有更复杂的算法 防火墙 防火墙在数据包接受之前提供一种隔离机制，对接受到的数据包进行鉴别和处理，同时可以实现端口转发功能 iptables上记载了一些处理规则 linux网络空间 每个网络空间从逻辑上提供独立的网络协议栈，具体包括网络设备、路由表、arp表、iptables、以及套接字(socket)等 linux本身有default网络空间 linux本身有IP Forwarding功能，其本身可以视作一个路由器，为内部多个网卡之间数据包的转发提供支持 建立veth，可以为不同网络空间中建立连接 建立bridge，同时每个网络空间通过veth连接到该bridge上，可以为多个网络空间之间建立连接 bridge本身可以有一个网卡，并且该网卡也存在于default网络空间中 bridge网卡设定ip地址 连接在bridge上的网络空间将该ip地址设定为网关ip 在default网络空间中设定IP Forwarding，使得连接在bridge上的网络空间可以与default网络空间通信 参考 详细解读Linux网络命名空间，veth， birdge与路由 - 知乎 (zhihu.com) ","permalink":"https://uhuuh.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","summary":" 一个网卡（网络接口，网络适配器）有mac地址、ip地址和子网掩码 在linux中一个有两个网络，一个是虚拟的环回网卡，另一个是可通外网的外网网卡。环回网卡的mac地址全0 在window中好像没有环回网卡，但是环回地址也能正常使用 当socket监听地址为0.0.0.0时，会同时监听来自多个网卡上的数据 局域网数据发送 局域网数据发送有多种实现方式，一般常见是以太网 在以太网中，设备通过总线连接在一起，每个设备有mac地址进行标识 系统上只会使用ip地址进行通信，Address Resolution Protocol协议（arp）可以向机器的ip地址转化为mac地址。 查询arp表如果存在目标ip地址到目标mac地址的映射，同时这个创建时间比较新，使用该映射将目标ip地址转化为目标mac地址 否则发送以太网广播数据包，其中有本机ip，本机mac和目标ip 目标机器接受到该数据包后，存储该发送ip到发送mac的映射到自己的arp表中，同时发送一个单播以太网包，其中包含自己的mac地址。发送方收到该以太网包后，补全相应映射 其他机器接受到该数据包后，仅仅存储发送ip到发送mac的映射到自己arp表中 集线器、网桥、交换机的区别（详解干货！！！） - 知乎 (zhihu.com) 集线器将每个端口与其他端口连接起来，工作在物理层。 网桥和交换器在链路层，可以减少单播消息过程中广播的次数 网桥自动建立转化表。比如当有mac1从port1来，在端口表上建立mac1到port1的映射。如果有一个局域消息是目标地址是mac1，如果转发表中存在相应映射，将其转发到port1，否则对除了发送端口外的其他端口都进行转发 交换器是网桥的细化，在单播消息过程中的广播次数更有效。网桥学习到一个端口中有哪些mac地址，交换机学习到一个端口有哪一个mac地址 互联网数据发送 机器发送 若发送方ip在环回子网中时，数据包发往环回网卡 若发送方ip在同一个子网时，根据arp协议得到对方mac地址，按局域网方式发送 若发送方ip不在同一个子网时，根据arp协议得到网关mac地址，按局域网方式发送 当机器上存在多个网卡时，根据系统配置的路由表决定数据包分发到哪个网卡上，并且其上一般有个默认路由 网关（路由器）转发 查询路由表找到下一跳ip、下一跳mac地址和端口，将数据包中接受方ip转化为下一跳ip后，转发到相应端口按局域网方式发送 显而易见，路由器一般有多个端口，每个端口对应一个网卡 路由器的路由表建立有更复杂的算法 防火墙 防火墙在数据包接受之前提供一种隔离机制，对接受到的数据包进行鉴别和处理，同时可以实现端口转发功能 iptables上记载了一些处理规则 linux网络空间 每个网络空间从逻辑上提供独立的网络协议栈，具体包括网络设备、路由表、arp表、iptables、以及套接字(socket)等 linux本身有default网络空间 linux本身有IP Forwarding功能，其本身可以视作一个路由器，为内部多个网卡之间数据包的转发提供支持 建立veth，可以为不同网络空间中建立连接 建立bridge，同时每个网络空间通过veth连接到该bridge上，可以为多个网络空间之间建立连接 bridge本身可以有一个网卡，并且该网卡也存在于default网络空间中 bridge网卡设定ip地址 连接在bridge上的网络空间将该ip地址设定为网关ip 在default网络空间中设定IP Forwarding，使得连接在bridge上的网络空间可以与default网络空间通信 参考 详细解读Linux网络命名空间，veth， birdge与路由 - 知乎 (zhihu.com) ","title":"计算机网络"},{"content":"表示层状态转移（Representational State Transfer，REST）是一种软件架构风格，\n一个url表示资源，url返回的内容是资源的表示层（可以是html，json，jpg等），表示层中可以包含其他用来改变客户端状态的url（服务端本身是无状态的） 不同http方法表示对资源的管理，get获取资源，post创建资源，put更新资源，delete删除资源 注意点 url中仅包含名词，动词通过http方法体现 url仅表示资源标示，url中不应该有html后缀 表示层通过请求头中的Accept和Content-Type字段指定 基于资源管理，实际使用上有一些局限性 参考 理解RESTful架构 - 阮一峰的网络日志 (ruanyifeng.com) REST - Wikipedia ","permalink":"https://uhuuh.github.io/posts/rest%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC/","summary":"表示层状态转移（Representational State Transfer，REST）是一种软件架构风格，\n一个url表示资源，url返回的内容是资源的表示层（可以是html，json，jpg等），表示层中可以包含其他用来改变客户端状态的url（服务端本身是无状态的） 不同http方法表示对资源的管理，get获取资源，post创建资源，put更新资源，delete删除资源 注意点 url中仅包含名词，动词通过http方法体现 url仅表示资源标示，url中不应该有html后缀 表示层通过请求头中的Accept和Content-Type字段指定 基于资源管理，实际使用上有一些局限性 参考 理解RESTful架构 - 阮一峰的网络日志 (ruanyifeng.com) REST - Wikipedia ","title":"REST接口设计风格"},{"content":"UML类图 ==方法返回类型== 原则 依赖倒置原则: 一般而言, 相关的一些类之间形成模块, 模块之间产生依赖. 高层次的模块依赖低层次模块, 而低层次的模块容易因需求而变动, 进而导致依赖它的整个上游模块变动. 模块之上定义一个稳定的抽象层, 抽象(抽象等价于稳定)之间可以相互依赖. 模块也可以进一步细化到一个类的实现上, 类仅仅依赖抽象(接口或者抽象类) 开放封闭原则: 类不能被修改, 可以被扩展 单一职责原则: 一个类应该仅有一个变化的原因，该变化隐含了它的职责. 类的职责太多意味着这个类更有可能被修改 替换原则: 在代码中的任意地方, 派生类可以替换基类 接口隔离原则: 接口设计应该尽可能小而完备. 接口暴露越多意味接口变动的可能性变多 优先使用组合而不是继承: 组合相比于继承使类之间的耦合更小. 感觉无论是组合和继承都需要依赖另一个对象, 强调组合和继承依赖程度上的区别没有意义, 而应该强调组合和继承在功能上的区别 合成复用原则: 尽量使用合成/聚合的方式，而不是使用继承 对象创建相关 单例 当创建一个对象, 出于性能或者鲁棒性的考虑只需要该对象的一个实例 工厂方法 当创建一个对象, 这个对象可能变动 抽象工厂 当创建一系列相互依赖的对象时, 这些对象可能变动 原型 当创建一个对象时, 直接复制可能更方便时 建造者 当创建一个对象时, 这个对象的创建过程中可能使用到多种可选步骤 接口使用相关 门面 当需要封装一系列对象为子系统时 将一系列功能上相关的对象组成一个子系统, 为该子系统定义稳定的接口 适配器 当使用一个对象适配另一个它没有实现的接口时 装饰器 当给对象原有接口增加新功能时 装饰器模式通过组合和继承实现, 另外有着动态决定对象原有接口新增功能的优点, 具体在main方法中使用一个装饰器对象构造另一个装饰器对象. 如果装饰器模式通过继承实现, 由于装饰器对象继承的基类已经决定, 达不到上述优点 代理 当给对象原有接口访问时增加中间层, 一般为了接口调用的访问控制和缓存等 装饰器模式和代理模式的实现都是基于组合和继承, 由于侧重的使用场景略有不同, 代理模式只有一个代理对象, 装饰器模式可以有多个装饰器, 而多个装饰器之间可以套娃 场景表示相关 复合 当使用对象继承体系表示一个树形事物时 状态 当对象继承体系实现状态机, 避免使用条件语句实现状态机时不好动态添加状态, 需要事先确定改变状态的所有方法 单个状态对象只需要一个实例, 一般命令模式会结合单例模式 状态对象仅仅表示该状态和状态的转移, 一般持有当前状态和负责修改当前状态在另一个对象中 策略 当使用对象表示策略时, 实现策略的运行时可替换 使用上可以等同于一些语言中的函数对象 命令 当使用对象表示请求时, 实现请求的记录和撤销等 官方的UML类图过于理想化 解析器 略, 用的很少 迭代器 当需要提供通用的迭代对象集合的方法时 访问者 当需要给对象集合中添加各种各样的处理对象的方法时 访问器针对不同的元素实现不同的处理 有很大的限制性, 需要对象集合中的对象元素已经确定 中介者 当多个对象相互交互时, 需要修改其中的一个对象时需要改动相互依赖的所有对象 实现时添加一个中介者, 所有对象与中介者交互, 一般修改一个对象时只需要对象改对象和中介者 观察者 当对象的状态变化需要通知其他对象时, 使用该模式后可以增加和删除通知者 责任链 当一个请求有多种处理者时, 使用该模式后动态增加和删除处理者 备忘录 当需要保存与加载对象的状态 略有过时, 现在可以使用对象序列化和反序列化替代 其他 模板方法 当对象方法中某些处理上固定时, 使用该模式后可以只需要实现方法中变化的部分 实现时借助抽象类, 具体要将一个方法拆分成固定和变化两个方法 桥接 当对象继承体系要对应两个维度上的变化时, 比如图形的图形和颜色 如果仅仅使用继承实现的话有子类数量爆炸的问题, 需要结合继承和组合实现. 如果先有A维度再有B维度, A维度上变化使用继承表示, 结合B维度上的变化组合A维度基类后用继承表示 享元 当系统中存在大量相同的不可变对象时, 使用该模式可以尽量共享这些不可变对象, 减少程序的内存占用 建立享元工厂, 工厂创建对象时发现过去创建过直接获取 总结 抽象意味着提取一个对象上固定的部分, 可以是方法签名, 也可以是方法具体实现 接口和抽象类作用相同, 它们之间的区别在于抽象的程度不同. 抽象一个对象的时候, 只固定了方法签名的时候使用接口, 同时也固定了某些方法的实现使用抽象类 对象A依赖对象B说明对象A中有使用对象B, 比如对象A的属性, 方法参数, 方法内部new出现对象B 多继承基类有二义性问题, 有同签名的方法但是在两个基类中有不同实现. 所以java不支持多继承, c++虽然支持通过某种方法确定出现二义性时的顺序. 而多继承接口由于接口只有签名没有实现, 不会出现二义性问题, java也支持多继承接口 分解与合并, 运行时绑定 组合等同于委托, 继承等同于扩展 学习过程 简单理解设计模式概念, 写出相应的简单例子 重新整理设计模式的分类, 使用场景 重新理解设计模式的类图 参考 设计模式目录：22种设计模式 (refactoringguru.cn) 图解设计模式 练习有些简单 24.访问器_哔哩哔哩_bilibili geekband的C++设计模式在线课 ","permalink":"https://uhuuh.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","summary":"UML类图 ==方法返回类型== 原则 依赖倒置原则: 一般而言, 相关的一些类之间形成模块, 模块之间产生依赖. 高层次的模块依赖低层次模块, 而低层次的模块容易因需求而变动, 进而导致依赖它的整个上游模块变动. 模块之上定义一个稳定的抽象层, 抽象(抽象等价于稳定)之间可以相互依赖. 模块也可以进一步细化到一个类的实现上, 类仅仅依赖抽象(接口或者抽象类) 开放封闭原则: 类不能被修改, 可以被扩展 单一职责原则: 一个类应该仅有一个变化的原因，该变化隐含了它的职责. 类的职责太多意味着这个类更有可能被修改 替换原则: 在代码中的任意地方, 派生类可以替换基类 接口隔离原则: 接口设计应该尽可能小而完备. 接口暴露越多意味接口变动的可能性变多 优先使用组合而不是继承: 组合相比于继承使类之间的耦合更小. 感觉无论是组合和继承都需要依赖另一个对象, 强调组合和继承依赖程度上的区别没有意义, 而应该强调组合和继承在功能上的区别 合成复用原则: 尽量使用合成/聚合的方式，而不是使用继承 对象创建相关 单例 当创建一个对象, 出于性能或者鲁棒性的考虑只需要该对象的一个实例 工厂方法 当创建一个对象, 这个对象可能变动 抽象工厂 当创建一系列相互依赖的对象时, 这些对象可能变动 原型 当创建一个对象时, 直接复制可能更方便时 建造者 当创建一个对象时, 这个对象的创建过程中可能使用到多种可选步骤 接口使用相关 门面 当需要封装一系列对象为子系统时 将一系列功能上相关的对象组成一个子系统, 为该子系统定义稳定的接口 适配器 当使用一个对象适配另一个它没有实现的接口时 装饰器 当给对象原有接口增加新功能时 装饰器模式通过组合和继承实现, 另外有着动态决定对象原有接口新增功能的优点, 具体在main方法中使用一个装饰器对象构造另一个装饰器对象. 如果装饰器模式通过继承实现, 由于装饰器对象继承的基类已经决定, 达不到上述优点 代理 当给对象原有接口访问时增加中间层, 一般为了接口调用的访问控制和缓存等 装饰器模式和代理模式的实现都是基于组合和继承, 由于侧重的使用场景略有不同, 代理模式只有一个代理对象, 装饰器模式可以有多个装饰器, 而多个装饰器之间可以套娃 场景表示相关 复合 当使用对象继承体系表示一个树形事物时 状态 当对象继承体系实现状态机, 避免使用条件语句实现状态机时不好动态添加状态, 需要事先确定改变状态的所有方法 单个状态对象只需要一个实例, 一般命令模式会结合单例模式 状态对象仅仅表示该状态和状态的转移, 一般持有当前状态和负责修改当前状态在另一个对象中 策略 当使用对象表示策略时, 实现策略的运行时可替换 使用上可以等同于一些语言中的函数对象 命令 当使用对象表示请求时, 实现请求的记录和撤销等 官方的UML类图过于理想化 解析器 略, 用的很少 迭代器 当需要提供通用的迭代对象集合的方法时 访问者 当需要给对象集合中添加各种各样的处理对象的方法时 访问器针对不同的元素实现不同的处理 有很大的限制性, 需要对象集合中的对象元素已经确定 中介者 当多个对象相互交互时, 需要修改其中的一个对象时需要改动相互依赖的所有对象 实现时添加一个中介者, 所有对象与中介者交互, 一般修改一个对象时只需要对象改对象和中介者 观察者 当对象的状态变化需要通知其他对象时, 使用该模式后可以增加和删除通知者 责任链 当一个请求有多种处理者时, 使用该模式后动态增加和删除处理者 备忘录 当需要保存与加载对象的状态 略有过时, 现在可以使用对象序列化和反序列化替代 其他 模板方法 当对象方法中某些处理上固定时, 使用该模式后可以只需要实现方法中变化的部分 实现时借助抽象类, 具体要将一个方法拆分成固定和变化两个方法 桥接 当对象继承体系要对应两个维度上的变化时, 比如图形的图形和颜色 如果仅仅使用继承实现的话有子类数量爆炸的问题, 需要结合继承和组合实现.","title":"设计模式"},{"content":"实现 相比于其他版本控制系统, git每个版本保存快照(文件内容的二进制压缩表示)而不是与上一个版本的变更, 在版本之间的切换速度很快, 但是相应占用大量存储空间\n实现一个基于快照的版本控制系统, 容易想到如下步骤\n记录当前版本工作目录下所有文件内容, 同时可以基于一个版本进行修改派生出不同的多个版本, 这样版本之间构成一个树状结构 commit对象, 不同commit对象有指针连接, 所有commit对象之间构成一棵树 进一步优化存储空间, 使不同版本之间的相同内容文件只保存一份. 建立文件内容摘要到文件内容的键值数据库, tree与blob对象对应目录和文件, commit对象再对应工作目录的tree对象 提供暂存功能, 而不是每次保存都生成一个新版本. 进入一个中间层索引区, 现在存在三层结构工作区, 索引区和仓库区. 索引区 进一步实现合并版本生成新版本, 而不是之前仅仅只能修改一个版本生成一个新版本. 两个版本合并时遵循一定合并策略, 该策略找到公共祖先节点后, 执行三方合并. 所有commit构成一个有向无环图 初始化git仓库之后, 工作目录下有.git隐藏目录, 里面保存有实现版本控制的一些文件\n参考 [中文] 这才是真正的 Git——Git 内部原理揭秘！（freeCodeConf 2019 深圳站）_哔哩哔哩_bilibili 这才是真正的Git——Git内部原理 - LZANE | 李泽帆（靓仔） 这才是真正的Git——分支合并 - LZANE | 李泽帆（靓仔） 图解Git (marklodato.github.io) 介绍git常见命令, 其中结合图示展示命令流程 Learn Git Branching 玩动画形式学习git ","permalink":"https://uhuuh.github.io/posts/git/","summary":"实现 相比于其他版本控制系统, git每个版本保存快照(文件内容的二进制压缩表示)而不是与上一个版本的变更, 在版本之间的切换速度很快, 但是相应占用大量存储空间\n实现一个基于快照的版本控制系统, 容易想到如下步骤\n记录当前版本工作目录下所有文件内容, 同时可以基于一个版本进行修改派生出不同的多个版本, 这样版本之间构成一个树状结构 commit对象, 不同commit对象有指针连接, 所有commit对象之间构成一棵树 进一步优化存储空间, 使不同版本之间的相同内容文件只保存一份. 建立文件内容摘要到文件内容的键值数据库, tree与blob对象对应目录和文件, commit对象再对应工作目录的tree对象 提供暂存功能, 而不是每次保存都生成一个新版本. 进入一个中间层索引区, 现在存在三层结构工作区, 索引区和仓库区. 索引区 进一步实现合并版本生成新版本, 而不是之前仅仅只能修改一个版本生成一个新版本. 两个版本合并时遵循一定合并策略, 该策略找到公共祖先节点后, 执行三方合并. 所有commit构成一个有向无环图 初始化git仓库之后, 工作目录下有.git隐藏目录, 里面保存有实现版本控制的一些文件\n参考 [中文] 这才是真正的 Git——Git 内部原理揭秘！（freeCodeConf 2019 深圳站）_哔哩哔哩_bilibili 这才是真正的Git——Git内部原理 - LZANE | 李泽帆（靓仔） 这才是真正的Git——分支合并 - LZANE | 李泽帆（靓仔） 图解Git (marklodato.github.io) 介绍git常见命令, 其中结合图示展示命令流程 Learn Git Branching 玩动画形式学习git ","title":"Git"},{"content":"相关算法 对称加密算法, 使用同一个秘钥加密解密 DES, 已被破解 三重DES, 加密性好一点, 但是处理速度不高, 只是为了兼容DES而使用 AES, 广泛使用 非对称加密算法, 算法生成两个秘钥, 一个加密需要使用另一个解密, 两个秘钥之间功能相同, 只是公开的那个叫公钥保存的那个叫私钥. 加密解密速度是对称加密算法的百分之几 RSA, 广泛使用. 基于异或和质因子分解, 为了保证加密性最好选用2024位质数 散列算法, 针对不同长度的消息产生固定长度散列值. 一般无法从散列值逆推出消息, 要求不同的消息生成不同的散列值 MD5, 生成128位散列值, 已被破解 SHA-1, 生成160位散列值, 已被破解 SHA-2, 包括SHA-256, SHA-384和SHA-512, 广泛使用 加密传输 一般安全传输加密消息需要满足以下三个条件\n消息内容加密 消息内容防篡改 发送方和接受方的身份认证 使用对称加密技术\n流程, 假设接受方和发送方已经安全的同步秘钥 发送方使用对称加密算法加密消息 消息认证码同时基于消息内容和秘钥使用散列算法生成散列值, 将其作为消息的一部分. 然后发送消息 接收方使用秘钥解密后, 基于消息内容和秘钥再生成一个消息认证码, 与消息中附加的消息认证码对比, 确保消息没有被篡改和消息是被秘钥持有者发送 问题 由于对称加密双方无法安全的同步秘钥, 上述方式存在隐患 ==如果消息认证码在生成散列值中不加入秘钥, 只能通过消息被解密后是否乱码确定发送方身份, 而加入秘钥后, 只需要简单比较两次散列值是否相等 ==消息认证码仅仅使用消息内容生成散列值, 发送方按照上述消息认证码生成方式使用秘钥A加码后发送消息, 接收方使用另一个秘钥B解密消息, 消息里面的消息认证码还有效吗? 如果无效的话, 消息认证码计算散列值的时候还需要包含秘钥吗 非对称加密技\n生成两个秘钥, 使用一个加密后可以使用另一个解密, 一把将自身保存的叫私钥, 公开的叫公钥 加密消息. 发送方获取接受方的公钥加密, 然后接受方收到消息后通过自身保存的私钥解密 保护消息完整性. 发送方消息内包含消息散列值, 公钥加密后发送接收方 消息发送方验证. 接收方获取发送方的公钥解密数字签名得到散列值, 与消息生成的散列值对比. 要达到消息身份认证, 对称加密需要双方同步秘钥, 非对称加密需要双方持有对方的公钥 显而易见实现加密传输需要安全传输公钥, 可以通过证书授权机构(CA)的数字证书得到 需要发送方向CA注册拿到证书, 证书中包含用户名, 用户公钥, 期限, 颁发机构和数字签名等信息 需要接受方本身保存信任CA的公钥 发送方发送证书后, 接受方证书颁发CA公钥验证证书上数字签名, 确保证书未被修改并且来自对应的CA, 然后接收方就安全的拿到了发送方的公钥 流程, 由于非对称加密很慢, 一般用于交换对称加密的秘钥后使用对称加密继续通信 一方能收到对方证书中的公钥, 使用对称加密技术生成秘钥, 使用公钥加密后将这个秘钥发送给对方 然后双方基于对称加密传输消息 问题 CA机构可能出现问题, 颁发一些非法证书 用户密码保存 服务器并不保存用户密码, 而是保存用户密码的哈希值, 用户密码只有用户自己保存. 这样黑客破解系统数据库也拿不到用户密码. 如果用户密码过于简单, 使用彩虹表攻击技术可以可以从哈希值反推密码, 可能造成大量用户密码泄露 密码加固定盐值, 这个盐值可以保存在服务器的代码中, 数据库保存的是密码拼接盐经过后得到的哈希值. 但是有有可能黑客从服务器上得到这个盐值, 然后重新结合简单密码和这个颜值重新生成彩虹表, 然后从彩虹表中的哈希值中反推密码, 可能造成大量用户密码泄露 密码加随机盐值, 数据库保存盐值和哈希值, 同时使用bcrypt这种慢哈希函数. 每个用户有自己的盐值, 如果破解需要为每个用户生成特定的彩虹表, 然后使用慢哈希函数进一步增加了单个用户被暴力破解的难度 具体在客户端时, 采用一个随机盐, 和秘密拼接后得到哈希值, 然后传输这个哈希值和盐值给服务器 ","permalink":"https://uhuuh.github.io/posts/%E5%8A%A0%E5%AF%86/","summary":"相关算法 对称加密算法, 使用同一个秘钥加密解密 DES, 已被破解 三重DES, 加密性好一点, 但是处理速度不高, 只是为了兼容DES而使用 AES, 广泛使用 非对称加密算法, 算法生成两个秘钥, 一个加密需要使用另一个解密, 两个秘钥之间功能相同, 只是公开的那个叫公钥保存的那个叫私钥. 加密解密速度是对称加密算法的百分之几 RSA, 广泛使用. 基于异或和质因子分解, 为了保证加密性最好选用2024位质数 散列算法, 针对不同长度的消息产生固定长度散列值. 一般无法从散列值逆推出消息, 要求不同的消息生成不同的散列值 MD5, 生成128位散列值, 已被破解 SHA-1, 生成160位散列值, 已被破解 SHA-2, 包括SHA-256, SHA-384和SHA-512, 广泛使用 加密传输 一般安全传输加密消息需要满足以下三个条件\n消息内容加密 消息内容防篡改 发送方和接受方的身份认证 使用对称加密技术\n流程, 假设接受方和发送方已经安全的同步秘钥 发送方使用对称加密算法加密消息 消息认证码同时基于消息内容和秘钥使用散列算法生成散列值, 将其作为消息的一部分. 然后发送消息 接收方使用秘钥解密后, 基于消息内容和秘钥再生成一个消息认证码, 与消息中附加的消息认证码对比, 确保消息没有被篡改和消息是被秘钥持有者发送 问题 由于对称加密双方无法安全的同步秘钥, 上述方式存在隐患 ==如果消息认证码在生成散列值中不加入秘钥, 只能通过消息被解密后是否乱码确定发送方身份, 而加入秘钥后, 只需要简单比较两次散列值是否相等 ==消息认证码仅仅使用消息内容生成散列值, 发送方按照上述消息认证码生成方式使用秘钥A加码后发送消息, 接收方使用另一个秘钥B解密消息, 消息里面的消息认证码还有效吗? 如果无效的话, 消息认证码计算散列值的时候还需要包含秘钥吗 非对称加密技\n生成两个秘钥, 使用一个加密后可以使用另一个解密, 一把将自身保存的叫私钥, 公开的叫公钥 加密消息. 发送方获取接受方的公钥加密, 然后接受方收到消息后通过自身保存的私钥解密 保护消息完整性.","title":"加密"},{"content":"右值引用, 移动语义, 完美转发 23.理解std::move和std::forward 函数的形参是左值, 函数的返回值是右值, 即便该然回值的类型是右值引用 move只是将实参转化右值引用, 经过函数返回后变成右值 template\u0026lt;typename T\u0026gt; typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp; move(T\u0026amp;\u0026amp; param) { using ReturnType = typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp;; return static_cast\u0026lt;ReturnType\u0026gt;(param); // move只进行类型转换 } 右值引用接受一个非const的右值, 因为右值引用一般用于移动语义, 在其中要修改对象内部成员. 当对象存在一个拷贝构造函数和移动构造函数时, const右值会调用拷贝构造函数 class Annotation { public: explicit Annotation(const std::string text) ： value(std::move(text)) //“移动”text到value里；这段代码执行起来 { … } //并不是看起来那样 … private: std::string value; }; 在函数内部调用forward转化形参为实参相应类型的变量 void process(const Widget\u0026amp; lvalArg); //处理左值 void process(Widget\u0026amp;\u0026amp; rvalArg); //处理右值 template\u0026lt;typename T\u0026gt; //用以转发param到process的模板 void logAndProcess(T\u0026amp;\u0026amp; param) { auto now = std::chrono::system_clock::now(); makeLogEntry(\u0026#34;Calling \u0026#39;process\u0026#39;\u0026#34;, now); process(std::forward\u0026lt;T\u0026gt;(param)); // 没经过forward只能调用左值版本 } forward可以替换move class Widget { public: Widget(Widget\u0026amp;\u0026amp; rhs) : s(std::move(rhs.s)) // rhs是形参同时是左值, 所以要再经过一般move { ++moveCtorCalls; } private: static std::size_t moveCtorCalls; std::string s; }; class Widget{ public: Widget(Widget\u0026amp;\u0026amp; rhs) //不自然，不合理的实现 : s(std::forward\u0026lt;std::string\u0026gt;(rhs.s)) // 尽管可以替代, 但是move用法上更简单一些 { ++moveCtorCalls; } } 24.区分通用引用与右值引用 通用引用可以接受左值和右值, 可能在函数模板和auto中出现 template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); //param是一个通用引用 auto\u0026amp;\u0026amp; var2 = var1; //var2是一个通用引用 函数模板形参的类型是T\u0026amp;\u0026amp;, const T\u0026amp;\u0026amp;也不行 template \u0026lt;typename T\u0026gt; void f(const T\u0026amp;\u0026amp; param); //param是一个右值引用 函数模板中, T需要被推导得知是一个通用引用, 可以接受左值和右值 template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); //param是一个通用引用 Widget w; f(w); //传递给函数f一个左值；param的类型 //将会是Widget\u0026amp;，也即左值引用 f(std::move(w)); //传递给f一个右值；param的类型会是 //Widget\u0026amp;\u0026amp;，即右值引用 函数模板中, T不是通过推导 template\u0026lt;class T, class Allocator = allocator\u0026lt;T\u0026gt;\u0026gt; class vector { public: void push_back(T\u0026amp;\u0026amp; x); // T不是通过推导得知, 故此处不是通用引用 } std::vector\u0026lt;Widget\u0026gt; v; // 由于类模板需要给定模板参数 class vector\u0026lt;Widget, allocator\u0026lt;Widget\u0026gt;\u0026gt; { public: void push_back(Widget\u0026amp;\u0026amp; x); // T不是通过自动推导得知, 故此处是右值引用 }; template\u0026lt;class T, class Allocator = allocator\u0026lt;T\u0026gt;\u0026gt; class vector { public: template \u0026lt;class... Args\u0026gt; void emplace_back(Args\u0026amp;\u0026amp;... args); // 由于使用另一种模板参数Args, 模板参数类型需要调用时推导得知, 故此处是通用引用 }; auto\u0026amp;\u0026amp;也需要推导, 也是通用引用 auto timeFuncInvocation = [](auto\u0026amp;\u0026amp; func, auto\u0026amp;\u0026amp;... params) { start timer; std::forward\u0026lt;decltype(func)\u0026gt;(func)( std::forward\u0026lt;delctype(params)\u0026gt;(params)... ); stop timer and record elapsed time; }; 25.对右值引用使用move, 对通用引用使用forward 如果在通用引用上使用move, 可能函数接收左值变量, 但是调用后该变量被出于意料的移动 class Widget { public: template\u0026lt;typename T\u0026gt; void setName(T\u0026amp;\u0026amp; newName) //通用引用可以编译， { name = std::move(newName); } //但是代码太太太差了！ private: std::string name; std::shared_ptr\u0026lt;SomeDataStructure\u0026gt; p; }; std::string getWidgetName(); //工厂函数 Widget w; auto n = getWidgetName(); //n是局部变量 w.setName(n); //把n移动进w！ … //现在n的值未知 函数内部, 只有在最后一次使用形参时(包括return时), 才使用move或者forward转化. 提前转发可能导致该形参值被提前移动 template\u0026lt;typename T\u0026gt; void setSignText(T\u0026amp;\u0026amp; text) //text是通用引用 { sign.setText(text); //使用text但是不改变它 auto now = std::chrono::system_clock::now(); signHistory.add(now, std::forward\u0026lt;T\u0026gt;(text)); } template\u0026lt;typename T\u0026gt; Fraction //按值返回 reduceAndCopy(T\u0026amp;\u0026amp; frac) //通用引用的形参 { frac.reduce(); return std::forward\u0026lt;T\u0026gt;(frac);\t//移动右值，或拷贝左值到返回值中 } 在函数, stack变量return时, 推荐不使用转发, 而是依靠编译器提供的的RVO和NRVO优化, 同时需要满足 stack对象类型与return类型一致 并且直接返回该stack对象, 同时该条件也说明函数中不应该有复杂的控制逻辑导致return不同的stack对象 Widget makeWidget() { Widget w; return w; // return std::move(w); // 返回应用不满足第二个条件, 不使用返回优化 } 26.避免在通用引用上重载 不应该重载有通用引用的函数, 因为通用引用的版本几乎可以匹配任意参数, 导致该版本总是被调用 template\u0026lt;typename T\u0026gt; void logAndAdd(T\u0026amp;\u0026amp; name) { auto now = std::chrono::system_clock::now(); log(now, \u0026#34;logAndAdd\u0026#34;); names.emplace(std::forward\u0026lt;T\u0026gt;(name)); // 只有forward转发后, 再有可能触发name的移动 } void logAndAdd(int idx) //新的重载 { auto now = std::chrono::system_clock::now(); log(now, \u0026#34;logAndAdd\u0026#34;); names.emplace(nameFromIdx(idx)); } logAndAdd(\u0026#34;Patty Dog\u0026#34;); short nameIdx = 22; logAndAdd(nameIdx); // `short`类型通用引用重载优先于`int`类型的重载 尤其不要在构造函数中使用通用引用 27.熟悉通用引用重载的替代方法 28.理解引用折叠 引用折叠 - 左值引用-左值引用 T\u0026amp; \u0026amp;是T\u0026amp; - 左值引用-右值引用 T\u0026amp; \u0026amp;\u0026amp;是T\u0026amp; - 右值引用-左值引用 T\u0026amp;\u0026amp; \u0026amp;是T\u0026amp; - 右值引用-右值引用 T\u0026amp;\u0026amp; \u0026amp;\u0026amp;是T\u0026amp;\u0026amp;\n尽管能在cpp不允许使用一个引用初始化另一个应用, 但是在模板中依据引用折叠推导出准确T类型\ntemplate\u0026lt;typename T\u0026gt; void func(T\u0026amp;\u0026amp; param); Widget widgetFactory(); //返回右值的函数 Widget w; //一个变量（左值） func(w); //形参是左值引用Widget\u0026amp;, T\u0026amp;\u0026amp;必须与实参一致为左值引用, 依据引用折叠推导T为Widget\u0026amp; func(widgetFactory()); //形参是右值引用Widget\u0026amp;\u0026amp;；T被推导为Widget forward实现, 相当于再用\u0026amp;\u0026amp;折叠一次,\ntemplate\u0026lt;typename T\u0026gt; T\u0026amp;\u0026amp; forward(typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp; param) // func内部形参已经是左值, 可以用左值引用接受 { return static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(param); } 引用折叠发生四种地方\n模板实力化 auto typedef decltype 29.假定移动操作不存在，成本高，未被使用 ==stl容器的移动开销可能没有想象中小, 比如移动array不是改变内部指针, 而是话费线性时间移动每个元素== 略 30.熟悉完美转发失败的情况 lambda表达式 C++ 11 Lambda表达式 - 滴水瓦 - 博客园 (cnblogs.com) 使用教程\n31.避免使用默认捕获模式 lambda中的默认捕获有两种, 一种是默认按引用捕获, 另一种是默认按值捕获. 第一种的缺点是显而易见的, 容易出现悬垂引用. lambda只能捕获其被创建时所在作用域的non static变量, 第二种的缺点是有时候不容易区分是否是真正的按值捕获\n一种情况是默认按值捕获this, 容易被误解为按值捕获对象的成员\nclass Widget { public: … //构造函数等 void addFilter() const; //向filters添加条目 private: int divisor; //在Widget的过滤器使用 }; void Widget::addFilter() const { filters.emplace_back( [=](int value) { return value % divisor == 0; } // 实际上divisor不是按值传递得到, 而是按值传递得到this指针, 从this指针里面取得divisor, 由于捕获的是this指针也容易有悬垂引用问题 ); }\t一种是lambda使用static变量, 容易被误解为按值捕获\nvoid addDivisorFilter() { static auto calc1 = computeSomeValue1(); //现在是static static auto calc2 = computeSomeValue2(); //现在是static static auto divisor = //现在是static computeDivisor(calc1, calc2); filters.emplace_back( [=](int value) //什么也没捕获到！ { return value % divisor == 0; } //引用上面的static ); ++divisor; //调整divisor } 32.使用初始化捕获来移动对象到闭包中 c++11中lambda只能使用按值和按引用两种方式捕获, 但是在c++14中提出了初始化捕获(通用捕获), 可以实现移动捕获\nclass Widget { //一些有用的类型 public: … bool isValidated() const; bool isProcessed() const; bool isArchived() const; private: … }; auto pw = std::make_unique\u0026lt;Widget\u0026gt;(); //创建Widget；使用std::make_unique //的有关信息参见条款21 … //设置*pw auto func = [pw = std::move(pw)] //使用std::move(pw)初始化闭包数据成员 { return pw-\u0026gt;isValidated() \u0026amp;\u0026amp; pw-\u0026gt;isArchived(); }; 在不支持c++14的编译器上可以有以下方法替代实现移动捕获\n使用bind表达式代替lambda表达式 定义一个伪函数实现移动捕获. 实际上lambda也是这种方法的简写而已 class IsValAndArch { //“is validated and archived” public: using DataType = std::unique_ptr\u0026lt;Widget\u0026gt;; explicit IsValAndArch(DataType\u0026amp;\u0026amp; ptr) //条款25解释了std::move的使用 : pw(std::move(ptr)) {} bool operator()() const { return pw-\u0026gt;isValidated() \u0026amp;\u0026amp; pw-\u0026gt;isArchived(); } private: DataType pw; }; auto func = IsValAndArch(std::make_unique\u0026lt;Widget\u0026gt;()); 33.对auto\u0026amp;\u0026amp;形参使用decltype以std::forward它们 c++14支持泛型lambda, auto f = [](auto x){ return func(normalize(x)); };实际上是如下\nclass SomeCompilerGeneratedClassName { public: template\u0026lt;typename T\u0026gt; //auto返回类型见条款3 auto operator()(T x) const { return func(normalize(x)); } }; 上述例子中如果normalize函数对待左值和右值的作用不一样, 由于形参总是左值, 考虑使用完美转发\nauto f = [](auto\u0026amp;\u0026amp; param) { return func(normalize(std::forward\u0026lt;decltype(param)\u0026gt;(param))); }; 下面是模板参数中完美转发的例子, 上述例子中的forward\u0026lt;decltype(param)\u0026gt;与forward\u0026lt;T\u0026gt;有一样的功能(对照引用折叠规则容易理解)\ntemplate\u0026lt;typename T\u0026gt; Fraction //按值返回 reduceAndCopy(T\u0026amp;\u0026amp; frac) //通用引用的形参 { frac.reduce(); return std::forward\u0026lt;T\u0026gt;(frac);\t//移动右值，或拷贝左值到返回值中 } 34.考虑lambda而非std::bind 感觉这个条款不需要做笔记\n","permalink":"https://uhuuh.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-effective-modern-cpp/","summary":"右值引用, 移动语义, 完美转发 23.理解std::move和std::forward 函数的形参是左值, 函数的返回值是右值, 即便该然回值的类型是右值引用 move只是将实参转化右值引用, 经过函数返回后变成右值 template\u0026lt;typename T\u0026gt; typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp; move(T\u0026amp;\u0026amp; param) { using ReturnType = typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp;; return static_cast\u0026lt;ReturnType\u0026gt;(param); // move只进行类型转换 } 右值引用接受一个非const的右值, 因为右值引用一般用于移动语义, 在其中要修改对象内部成员. 当对象存在一个拷贝构造函数和移动构造函数时, const右值会调用拷贝构造函数 class Annotation { public: explicit Annotation(const std::string text) ： value(std::move(text)) //“移动”text到value里；这段代码执行起来 { … } //并不是看起来那样 … private: std::string value; }; 在函数内部调用forward转化形参为实参相应类型的变量 void process(const Widget\u0026amp; lvalArg); //处理左值 void process(Widget\u0026amp;\u0026amp; rvalArg); //处理右值 template\u0026lt;typename T\u0026gt; //用以转发param到process的模板 void logAndProcess(T\u0026amp;\u0026amp; param) { auto now = std::chrono::system_clock::now(); makeLogEntry(\u0026#34;Calling \u0026#39;process\u0026#39;\u0026#34;, now); process(std::forward\u0026lt;T\u0026gt;(param)); // 没经过forward只能调用左值版本 } forward可以替换move class Widget { public: Widget(Widget\u0026amp;\u0026amp; rhs) : s(std::move(rhs.","title":"读书笔记 effective modern cpp"},{"content":"4.从一条记录说起 数据库有不同的表组成, 表有不同的列组成, 这一章介绍了列是怎么存储的\n一行数据也被成为一条记录, 一行中的不同列也被称为不同的字段\n存储引擎. InnoDB是mysql默认的存储引擎, 也是最常用的存储引擎\n==逆序存储==\n书中介绍要讲到4中行格式, 其中compact和redundant有介绍, dynamic和compressed和compact类似, 但是处理溢出行有些分歧, 然后compressed还会使用压缩算法对行内容进行压缩\n隐藏列 row_id 当用户定义表结构时没有确定主键, 并且没有不允许null和unique的列, 自动添加该列作为键 trx_id roll_pointer compact行格式 变长字符长度列表, 所有变长列(下图中的varchar)的长度信息 只存非null的列 长度信息可由多个字节确定, 首先读取一个字节第一位位0说明该字节可以表示完整的长度, 否则记录读取随后的字节. 这种策略类似字符集的变成编码策略 当char类型的列为null时, 不占据实际内存 特别的, 当采用变长编码的字符集时, 定长的一列(char)的长度信息也应该保存到该列表中, 并且该列内容至少分配M(char的长度是M) 特别的, 当长度信息需要大于2字节保存时, 溢出处理 null值列表, 所有可null列的位指示信息 按字节对齐 记录头信息, 由固定的5字节组成, 共40二进制位 redundant行格式 古老的行格式, 在mysql5之前被使用, 相比于compact空间效率更差\n字段长度偏移列表 从记录真实数据部分, 各列偏移 根据记录真实数据的总长度确定(从表定义可知, 另外记录头中也有一个位可以知道该信息) 各列偏移量是用1个字节还是2两个字节表示 无论偏移量使用1个字节还是2个字节, 第一位都另做他用, 用来表示该列是否为null 当偏移量需要大于2字节时, 溢出处理 char为null时占据实际的内存, 里面都为0 对于char类型的列和使用变长编码的字符集, 直接为该列分配最大可能得空间 记录头信息, 共使用6字节 溢出列 ==什么时候列太长而需要溢出处理==\n在列格式中无论是列的长度还是偏移量, 最多使用2字节(页大小是16KB, 2字节的足以表示这个页面下的长度和偏移)来表示 一页(默认16KB)至少应该能够保存两条记录(要不然失去了平衡树的意义), 可以根据页大小, 页本身的大小计算出列可以的最大长度 当需要更多字节表示时要特殊处理. 该溢出列对应的内容只保存前面部分内容, 后面20字节指向页链接表地址和剩下内容长度. 注意保存记录的页和放置溢出行数据的页是两种不同的页\n总结 ==行格式设计总结==\n5.盛放记录的盒子 InnoDB存储设计了不同类型的页\n数据页的布局如下所示, user record逐渐占据free space的空间 user record 该处用于保存行信息, 每行(compact格式)中记录头中的一些关键信息如下表 行记录一条条在物理上紧密排列, 在逻辑上按照主键大小构成单向链表\nheap_no反映了行记录在空间中的物理顺序(从0开始) record_type反映了记录的类型. 有两类特殊的记录Infinum(比如所有记录主键小)和Supermum(比所有记录主键大)作为哨兵, Infinum(heap_no为0)和Supermum(heap_no为1)位于空间的开头 next_record反映了逻辑上下一条记录的相对距离, 在后面为正在前面为负, 相当于单向链表的指针. heap_no反应物理顺序, next_record反应逻辑顺序(主键依次增加, 头是Infinum, 尾是和Supermum). next_record指向的是逻辑上下一条记录中的记录头和真实数据的中间位置, ==为什么, 书上没看懂== 删除一条记录\n由于删除造成记录的重排比较耗费性能, 暂时将deleted_flag设为1, 设定next_record与其他被删除的记录组成链表 ==如何获取删除记录链表的头== 将删除的记录重新插入, 可以直接恢复 行记录查找, 不是简单的从逻辑链表上第一个记录依次查找, ==而是类似双层跳表查询==\n而是对链表分块, 块中第一个记录位置(从页开始的位置偏移, 2字节表示, 足以覆盖16KB的页大小. 可以从地址中读取主键的值用于查询中比较大小)写入页目录区 由于页目录区每一项地址对应的主键大小按顺序连续保存, 在上面执行二分, 找到对应的块 块的第一个记录的n_owned反应了这个块内记录大小, 块中的其他记录该属性为0, 可以依次属性在块上遍历 ==每个块最多存8个记录==, 当插入新记录大于这个限制时对块执行分裂操作 页头部 可以获得以下信息 文件头部 有同一层次上一页和下一页的页号 文件尾部 主要是校验信息, 用于判断页面有没有完整的刷新到磁盘中. 在内存中当页面被修改后, 重新计算整个页面的校验和, 分别写入文件头部和尾部, 当修改后的页面写入磁盘中不完全时, 磁盘中的文件头部校验和时新的, 文件尾部的校验和是旧的\n总结 ==孩子存储变长, 节点(页)内孩子查找设计==\n==判断页面有没有完整刷新到磁盘==\n6.快速查询的秘籍 InnoDB索引方案 前面介绍了单页中如何保存保存记录, 以及如何更具主键查找该页中的记录. 当保存的记录在多个页中如何根据主键查找呢? 使用B+树建立多层查找结构, 树的节点是一页, 每页中保存多个记录, 中间页保存的页目录项记录(record_type为1, 是页号和该页中所有记录中主键的最小值), 叶子页中保存用户记录(record_type为0) B+树结构支持范围查找, 找到范围左边键所在的位置, 依次往后查找直到到达右边键的位置(由于B+树叶子节点那一层由构成了双向链表)\n聚簇索引, 记录的主键作为key, 叶子节点中保存的value是用户记录, 默认建立\n二级索引, key是记录中的其他列, 中间节点的value是页号, 叶子节点的value是该列所在记录的主键, 由用户建立为了支持为其他列上元素的快速查找\n考虑到记录上非主键的列不满足unique约束, 更新二级索引时可能有多个插入位置, 一般key会额外包含保存记录对应的主键(==叶子节点中key和value一样吗==), 构成联合索引 在其他列上执行范围查找, 在二级索引上查找得到范围中最左边的主键和其他列, 再根据这两个值执行回表操作在聚簇索引上找到完整的记录, 接下来需要依次进行回表操作 ==为什么直接在叶子节点的value中给出页号== 联合索引(或者复合索引), 联合多个列的值作为key建立索引, 该key比较时先比较第一个列, 等第一个列相等后再比较key中的下一个列\n注意点\n索引表示的B+树建立之后, 根节点所在的页号不应该改变, ==强行要改变也不行吗== 一个页中至少保存两个key-value对 MyISAM索引方案 与上一种方案的区别, 在于上一种方案在叶子节点中直接保存数据, 而该方案中保存指向数据的指针\n在该方案中所有记录保存在一个数据文件中, 叶子节点的value是该文件的地址偏移\n总结 ==常见的B+树中孩子数量比key数量多一, 在上图中则key与value数量一样== 为什么实现中内部节点也使用构成了一个双向链表, 有什么明细的好处吗 7.B+树索引的使用 索引代价\n空间上代价 时间上代价, 每个插入记录同时需要修改所有的索引 在执行一条查询语句时, 通常在执行过程中最多只使用一个二级索引\n首先确定语句中涉及的列中有几个是有二级索引 依次对每个二级索引, 确定选定该二级索引的情况下需要的扫描区间 选择扫描区间最小的二级索引来最终执行查询语句 查询语句中所有操作都能形成扫描区间\nor和and可以是区间的并和交 in 是多个单点区间的并 like 'ab%'相当于[ab, +) 有时候查询语句中的多个操作, 可以通过一个联合索引搞定\n索引除了能用于查询外, 有时候能用于排序和分组. 所以一般在经常出现在where子句中的列, order by和group by中的列建立索引\n有时候对于变长的字符串, 在索引中完全存储字符串可能占用很大的空间, 可以建立索引, 仅仅使用部分字符串前缀建立索引. 显然这种字符串不支持排序和分组\n有时候使用索引如果查询区间太大, 可能回表导致的时间(回表式随机IO, 要慢一些)反而比全表查询(顺序IO)多\n如果limit确定结果数量, select*, 越容易直接使用全表查询 如果select之后索引列, 越容易直接使用索引查询 9.表空间 数据库中的table存储在tablespace中，tablespace可以由一个或者多个文件组成。在早期的版本中所有表存储在一个系统tablespace中，现在的版本每个表有自己的独立tablespace\ntablespace由多个group组成，一个组有256个extent组成，一个extent有64个page组成。一个group或者extent内的page在文件中物理上连续排列。\n页尽管有多种类型，但是不同类型的页有通用的结构页头部和页尾部。页头部有指向上一页和下一页的指针，不同页之间可以构成一个双向链表 区主要为了减少随机IO带来的性能损耗。以区为单位给表分配空间，使节点在地址上排列靠近 组主要为了更好的管理区，每个组开始第一页内保存有区描述符，同时第一个组的开始页保存段描述符 段是表空间中的逻辑结构，一个区只能属于一个段，当为表的聚簇索引的中间节点和叶子节点相应分配不同的段时，确保一个区内不会混杂有中间节点和叶子结点的页，当遍历叶子节点的时候能够减少随机IO 由于表直接以区为单位分配空间，当存在大量规模小的表时带来不容忽视的空间浪费。表空间中存在碎片区的概念，表的首先从碎片区中取页，当取够32页之后以区为单位分配空间\n20.undo日志 ","permalink":"https://uhuuh.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/","summary":"4.从一条记录说起 数据库有不同的表组成, 表有不同的列组成, 这一章介绍了列是怎么存储的\n一行数据也被成为一条记录, 一行中的不同列也被称为不同的字段\n存储引擎. InnoDB是mysql默认的存储引擎, 也是最常用的存储引擎\n==逆序存储==\n书中介绍要讲到4中行格式, 其中compact和redundant有介绍, dynamic和compressed和compact类似, 但是处理溢出行有些分歧, 然后compressed还会使用压缩算法对行内容进行压缩\n隐藏列 row_id 当用户定义表结构时没有确定主键, 并且没有不允许null和unique的列, 自动添加该列作为键 trx_id roll_pointer compact行格式 变长字符长度列表, 所有变长列(下图中的varchar)的长度信息 只存非null的列 长度信息可由多个字节确定, 首先读取一个字节第一位位0说明该字节可以表示完整的长度, 否则记录读取随后的字节. 这种策略类似字符集的变成编码策略 当char类型的列为null时, 不占据实际内存 特别的, 当采用变长编码的字符集时, 定长的一列(char)的长度信息也应该保存到该列表中, 并且该列内容至少分配M(char的长度是M) 特别的, 当长度信息需要大于2字节保存时, 溢出处理 null值列表, 所有可null列的位指示信息 按字节对齐 记录头信息, 由固定的5字节组成, 共40二进制位 redundant行格式 古老的行格式, 在mysql5之前被使用, 相比于compact空间效率更差\n字段长度偏移列表 从记录真实数据部分, 各列偏移 根据记录真实数据的总长度确定(从表定义可知, 另外记录头中也有一个位可以知道该信息) 各列偏移量是用1个字节还是2两个字节表示 无论偏移量使用1个字节还是2个字节, 第一位都另做他用, 用来表示该列是否为null 当偏移量需要大于2字节时, 溢出处理 char为null时占据实际的内存, 里面都为0 对于char类型的列和使用变长编码的字符集, 直接为该列分配最大可能得空间 记录头信息, 共使用6字节 溢出列 ==什么时候列太长而需要溢出处理==\n在列格式中无论是列的长度还是偏移量, 最多使用2字节(页大小是16KB, 2字节的足以表示这个页面下的长度和偏移)来表示 一页(默认16KB)至少应该能够保存两条记录(要不然失去了平衡树的意义), 可以根据页大小, 页本身的大小计算出列可以的最大长度 当需要更多字节表示时要特殊处理.","title":"读书笔记 mysql是怎样运行的"},{"content":"go\n模块包含多个包, 每个模块有唯一标识 import和mod文件中处理的都是模块, 本地模块初始化时指定模块标识, 本地模块import其他本地模块时需要replace到本地路径, 但是同一个workspace下的模块不需要 参考 [golang] 仓库，模块和包 - 知乎 (zhihu.com) 结构调用方法和属性时指针自动解引用和取引用 方法定义时值接受者和指针接受者, 结构的方法和普通函数相比, 需要传入一个结构,, 值接受者相当于传入一个对象副本, 指针接受者可以修改原始结构 Golang中自动“取引用”和“解引用”对原值的影响_seafooler的博客-CSDN博客 可变参数和数组展开 go语言之三个点用法 | Hexo (melonshell.github.io) 强制类型转换和类型断言 golang的强制类型转换 - Go语言中文网 - Golang中文社区 (studygolang.com) 文件写入在操作系统层面上是互斥的, 但是同一程序的协程之间还是需要加锁, 应为协程在操作系统层面不可见 defer 用法 :=, 并不总是定义变量, 如果右边是函数并且该函数返回多个值时, 左边如果有已经定义的变量则使用它 传参时struct, array会内容复制, string, slice会地址复制 Golang方法调用值拷贝与引用拷贝 - Go语言中文网 - Golang中文社区 (studygolang.com) go rpc客户端调用时replay要默认初始化. 因为内部使用gob(go默认的二进制存储方案, 感觉类似python的pickle)进行序列化反序列化, gob不会处理0值. 例如replay的a属性为7, 调用rpc后将a修改为0, 返回的a还是维持原来的7 net/rpc: zero values not transmitted using encoding/gob · Issue #8997 · golang/go (github.com) 插件禁用优化可以调试时找到, 但是run时又找不到. 为什么每次代码更新后引用的插件也要重新编译 引用类那就是指针类型 https://xie.infoq.cn/article/c00724d8b1f3d9c90a32c6678 new和make的区别, make只能对slice, map和chan使用 https://juejin.cn/post/7180326159027011639 线程除非主动终止, 在main结束之后才会终止 temp_arrs := make([][]KeyValue, rep.NReduce) for i := range temp_arrs { temp_arrs[i] = make([]KeyValue, 0) } for _, kv := range res { idx := ihash(kv.Key) % rep.NReduce arr := temp_arrs[idx] temp_arrs[idx] = append(arr, kv) } func main() { a := make([]int, 4) fmt.Println(len(a), a) // 4 [0 0 0 0] a = append(a, 12) fmt.Println(len(a), a) // 5 [0 0 0 0 12] } nil切皮和空切皮 [golang]slice类型nil和空切片的区别_liracle的博客-CSDN博客 以后统一使用make创建空切片, 使用len来判断是否为空 func main() { var a []int // nil切片 fmt.Println(a == nil, a) // true [] a = append(a, 1) // append都会自动扩容 fmt.Println(a == nil, a) // false [1] b := make([]int, 0) // 空切片 fmt.Println(b == nil, b) // false [] b = append(b, 1) fmt.Println(b == nil, b) // false [1] } timer注意点 Go Timer 详解以及 Reset 和 Stop 的正确用法 - 知乎 (zhihu.com) 由另一个已经线程保存所有的timer进堆中, 然后时不时的弹出到时的timer, 并且执行timer的回调函数和chan写入现在时间 Stop如果timer还在堆中将其清除并返回true, 否则什么也不做返回false Reset将timer重新添加进堆中, 所有使用Reset之前一般要确保原来的timer已经超时, 或者通过Stop强制弹出timer if !t.Stop() { // 提前终止一个timer的做法 select { case \u0026lt;-t.C: default: } } t.Reset(d) func fun() { a := 1 go func () { // 由于闭包, 线程函数内使用的变量a在fun退出后也一直存在, 直到这个线程函数退出时才销毁 for { time.Sleep(1000 * time.Millisecond) fmt.Println(a) a += 1 } }() for i := 0; i \u0026lt; 5; i += 1 { time.Sleep(1000 * time.Millisecond) fmt.Println(\u0026#34;this\u0026#34;, a) } } func main() { fun() for { time.Sleep(1 * time.Second) } } func main() { for i := 0 ; i \u0026lt; 5; i += 1 { j := i // 如果将这样注释掉, 打印的都是5 go func() { for { time.Sleep(500 * time.Millisecond) fmt.Println(j) } }() } for { time.Sleep(500 * time.Millisecond) } } ","permalink":"https://uhuuh.github.io/posts/go%E8%AF%AD%E8%A8%80/","summary":"go\n模块包含多个包, 每个模块有唯一标识 import和mod文件中处理的都是模块, 本地模块初始化时指定模块标识, 本地模块import其他本地模块时需要replace到本地路径, 但是同一个workspace下的模块不需要 参考 [golang] 仓库，模块和包 - 知乎 (zhihu.com) 结构调用方法和属性时指针自动解引用和取引用 方法定义时值接受者和指针接受者, 结构的方法和普通函数相比, 需要传入一个结构,, 值接受者相当于传入一个对象副本, 指针接受者可以修改原始结构 Golang中自动“取引用”和“解引用”对原值的影响_seafooler的博客-CSDN博客 可变参数和数组展开 go语言之三个点用法 | Hexo (melonshell.github.io) 强制类型转换和类型断言 golang的强制类型转换 - Go语言中文网 - Golang中文社区 (studygolang.com) 文件写入在操作系统层面上是互斥的, 但是同一程序的协程之间还是需要加锁, 应为协程在操作系统层面不可见 defer 用法 :=, 并不总是定义变量, 如果右边是函数并且该函数返回多个值时, 左边如果有已经定义的变量则使用它 传参时struct, array会内容复制, string, slice会地址复制 Golang方法调用值拷贝与引用拷贝 - Go语言中文网 - Golang中文社区 (studygolang.com) go rpc客户端调用时replay要默认初始化. 因为内部使用gob(go默认的二进制存储方案, 感觉类似python的pickle)进行序列化反序列化, gob不会处理0值. 例如replay的a属性为7, 调用rpc后将a修改为0, 返回的a还是维持原来的7 net/rpc: zero values not transmitted using encoding/gob · Issue #8997 · golang/go (github.","title":"go语言"},{"content":"让自己习惯c++ 1.c++是一个语言联邦 c++支持多种编程泛型, 面向过程, 基于对象, 面向对象, 泛型, 元编程\nc++可以视为一个语言联邦, 由以下四个部分组成\nc object oriented c++ template c++ stl 2.替换define 当define一个常量时, 调试不方便, 只剩下数值没有原来的变量名信息\n使用const定义全局常量 使用const在类中定义常量 class A { private: static const double a; // 声明, static确保所有类只有一份该变量 } const double A::a = 1.35; // static成员变量必须在类外定义 - 旧式编译器不支持static成员变量在声明时获得初值\rclass A{ private: static const double a; } const double A::a = 1.35; - 然后再类编译又需要一个常量值时(比如确定数组的大小), 可以使用enum hack技术. enum和define有很多相似的地方, enum最后会被替换成int, enum不能取地址\rclass A{ private: enum {n = 5}; int arr[n]; } 当define一个函数时, 写起来很麻烦, 而且容易出错\n使用template inline函数替代 template\u0026lt;typename T\u0026gt; inline void max(const T\u0026amp; a, const T\u0026amp; b) { return a \u0026gt; b ? a : b; } 3.const用法 指针\nconst Widget* pw; // pw指向的内容不能改变 Widget const * pw; // 和上者一样 Widget * const pw; // pw不能改变指向 const Widget* const pw; std::vector\u0026lt;int\u0026gt;::iterator iter; // 实际上是一个int* const std::vector\u0026lt;int\u0026gt;::const_iterator iter; // const int* const 函数返回值const, 可以在if中的==误写为=时报错\nconst成员函数中禁止修改成员变量\nconst对象只能调用const成员函数, const对象经可于参数传递和返回 使用mutable修饰符使得在const成员函数中可以修改被修饰的==non-static==变量 class A { public: mutable bool a; void fun() const { a = true; // 编译器不报错 } } 与non-const成员函数之间可以重载, 进一步使用类型转换避免const与non-const写两份代码 class A { public: const char\u0026amp; fun() const { ... } char\u0026amp; fun() { return const_cast\u0026lt;char\u0026amp;\u0026gt;(static_cast\u0026lt;const A\u0026amp;\u0026gt;(*this).fun()); } } ==const_cast==\n4.对象初始化 对于内置类型, c++的c部分为了避免初始化导致的运行时成本, 不进行初始化, 而非c部分则进行. 一个解决办法是再使用该对象前永远初始化\n对于对象, 确保构造函数对对象的每个成员初始化. 构造函数使用初始化列表完成初始化(初始化列表中没有指定的成员变量使用默认构造函数完成初始化, 出于安全性考虑进行为所有成员变量进行初始化操作), 函数内部完成复杂的赋值工作\n初始化列表\n初始化顺序与类中声明顺序有关, 与在列表中的顺序无关 const变量和reference变量必须使用初始化列表进行初始化 ==non-local static对象==\n将non-local static对象放入函数内部, 将其编程local static对象, 并且该函数返回该对象的引用. 这样可以确保调用函数返回的一定是已经初始化的对象, 并且该方法也可以用来实现单例模式\nA\u0026amp; getA() { static A a; return a; } 构造析构赋值运算 5.对象中默认定义的函数 如果对象自己没有实现的话, 编译器会为对象实现4个public且inline的函数, default构造, 析构, copy构造和copy assignment操作符\n但是存在一些情况, 这些函数不会自动生成, 在代码中调用这些函数的话编译器会报错. 比如如下情况, copy assignment操作符不会自动生成, 因为编译器不能直接给已经完成初始化的const与reference对象进行重新赋值. 另外在派生类集成的基类中copy assignment操作符为private时, 编译器无法直接调用基类的完成基类部分数据的赋值\nclass A { private: int\u0026amp; a; const int b; } 6.不像使用, 应该明确拒绝自动生成的函数 比如在单例模式中应该使一个对象不能被复制\n通过拒绝主动生成的copy assignment操作符和copy构造, 实现禁止复制\n在private主动声明这两个函数, 但是不定义. 这样代码中有使用对象的复制行为(成员函数和友元函数), 虽然不会报编译错误, 但是会报链接错误 定义一个基类noncopyable, 在private中主动声明这两个函数, 派生类继承该基类 class noncopyable { protected: uncopyable() {} ~uncopyable() {} private: uncopyable(const noncopyable\u0026amp;); uncopyable\u0026amp; operator=(const noncopyable\u0026amp;); } 7.为多态基类声明virtual析构函数 多态基类说明该基类随后会被继承, 但是继承后的派生类由常常基于引用或者指针向上转型, 这样在转型后的派生类析构时调用的却是基类的析构函数, 使得该派生类只有一部分被析构. 解决方法是将基类的析构函数声明为virtual, 这样即便派生类向上转型后析构时调用的也是派生类的析构函数. 换言之, 如果要继承一个基类, 最好确保基类的析构函数是virtual.\n为了确保所有的对象调用合适的析构函数, 也没有必要析构函数前面都加上virtual, 这会造成对象占用的内存增加(虚表指针增加占用空间), 与一些c代码上的不兼容\n如果一个类中有virtual函数, 说明该类将作为多态基类, 也应该将该类的析构函数也设为virtual\n8.析构函数不应抛出异常 析构函数抛出异常, 可以造成对象析构提前终止, 只释放该对象所拥有的一部分资源\n如果析构函数有可能执行抛出异常的代码, 有以下方案\ncatch到异常后直接abort catch到异常后记录失败记录 将析构函数内可能抛出异常的代码暴露给用户, 析构函数执行时如果该代码还未被用户调用则现在调用, catch到异常后按上两种方法处理. 这个方法较好一点, 将调用这部分危险代码的责任转移到用户 9.不在构造和析构函数中调用虚函数 不应该在基类构造中调用虚函数, 因为在构造过程还未构造完此时对象属于基类而非派生类, 调用的也是基类的虚函数. ==语法上虽然没什么错误, 但是行为和其他语言不一样, 推荐使用==\nclass A { public: A() { fun(); } virtual void fun() const = 0; } class B: A { public: void fun() const {} } 比如在python中, 派生类首先执行基类构造时, 在基类构造就可以执行派生类的重载过的函数\nclass A: def __init__(self) -\u0026gt; None: self.fun2() def fun2(self): print(\u0026#34;A\u0026#34;) class B(A): def __init__(self) -\u0026gt; None: super().__init__() def fun2(self): print(\u0026#34;B\u0026#34;) b = B() // 打印B 析构函数不调用虚函数也是同样的道理\n一个缓解办法是, 派生类中初始化基类时主动传入额外信息, 帮助基类无需借用虚函数直接完成构造\n10.operator=返回引用 int a = 1, b = 2, c = 3; (a = b) = c; std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl; // a == 3 为类重写=操作时也要实现类似的功能, 需要返回一个引用\n11.operator=处理自我赋值 在下面的例子中, 如果this=\u0026amp;rhs会造成pb提前被释放, 导致最终pb指向释放的资料. 简单的解决方法是再开头添加一个if检查(if部分代码取消注释)\nclass Widget { Bitmap* pb; public: Widget\u0026amp; operator=(const Widget\u0026amp; rhs) { //if (this == \u0026amp;rhs) { //\treturn *this; //} delete pb; pb = new Bitmap(rhs.pb); return *this; } } 但是仍然存在异常方面的麻烦. 如果new失败赋值操作强制退出时, 将导致此时被赋值对象的pb资源已被释放, 使得该对象再无法使用. 正确的做法是如果资源已经申请成功后再删除旧资源. 另外再实现异常安全的同时, 也能实现自我赋值安全\nclass Widget { Bitmap* pb; public: Widget\u0026amp; operator=(const Widget\u0026amp; rhs) { Bitmap* pOrig = pb; pb = new Bitmap(*rhs.pb); delete pOrig; return *this; } } 另一个做法如下所示, 但是作者认为不够简洁\nclass Widget { Bitmap* pb; public: Widget\u0026amp; operator=(const Widget\u0026amp; rhs) { Widget temp(rhs); swap(temp); // temp的内容转移到this return *this; }// temp析构函数调用, 其管理的多余资源被释放 } 12.复制对象时不要忘记每个成分 copy构造和copy assignment操作符统称为copying函数. 自己实现copying函数时需要注意, 如果有继承首先需要调用基类的copying, 然后copy自己的成员变量\nclass A { int a; public: A(const A\u0026amp; x) : a(x.a) {} A\u0026amp; operator=(const A\u0026amp; x) { a = x.a; return *this; } } class B: A { int b; public: B(const B\u0026amp; x): A(x), b(x.b) {} // 有时候基类的成员变量无法访问, 直接调用基类的copying函数进行copy B\u0026amp; operator=(const B\u0026amp; x) { A::operator=(x); // 实现copy assignment不应带调用copy构造, 而应该同样使用基类的copy assignment. 实现copy构造时同样如此 b = x.b; return *this; } } 有时候两个copying函数有太多重复的代码, 可以将这部分代码提取出来放入一个init函数中, 而不应该在一个copying函数内部调用另一个copying函数\n资源管理 13.以对象管理资源 资源从操作系统申请后, 将来不用时资源必须归还给操作系统\n申请资源常见的一种做法是通过工厂函数返回指向该资源的指针(函数内部通过new动态申请资源), 但是资源获取方必须负责调用delete释放资源, 由于过早退出等原因这很容易出现问题 利用RAII技术(资源获取的同时初始化), 以一个对象包裹资源指针, 在对象析构的时候自动调用delete释放资源. 早期的auto_ptr(现在的unique_ptr)实现了该操作, 但是为了避免复制auto_ptr导致的资源重复释放, auto_ptr复制都是move, 使得旧auto_ptr不可用 引用型智能指针share_ptr可以实现正常复制, 在指向同一个资源的share_ptr销毁后(即引用计算为0)才会真正的释放资源. 但是share_ptr的使用也存在循环引用问题, 该问题出现后导致资源总不会被释放 在可能出现循环引用的时候, share_ptr与weak_ptr配合使用. weak_ptr基于share_ptr创建, 并不会增加该资源的引用计数, 仅仅可以或者该资源是否已经释放 智能指针析构时仅仅调用delete, 而不会delete[]. 资源数组可以直接使用vector, 或者自定义删除器\n14.在资源管理中小心copying行为 当自己实现资源管理类时, 有时候释放资源不是简单的调用delete, 还有需要小心copying行为, 具体有以下做法\n禁止复制, 重写析构函数 在内部持有一个智能指针, 并且初始化该指针时自定义删除函数 深度复制, 重写析构函数 转移, 重写析构函数 15.在资源管理类中提供原始资源的访问 在资源外面包裹一层管理类的时候, 常常需要访问原始对象, 如下有两种方法, 依情况适用, 一般显示转换比较好\n一种是显示转换, 像智能指针提供get可以获得原始对象的指针 一种是隐式转换, 重写operator函数. 但是也可能造成悬垂引用问题, 资源管理类已经释放资源, 但是由于隐式转换可能使得内部的资源被暴露在释放后还可能被引用 16.成对使用new和delete要采用相同形式 使用new分配一个对象, 相应使用delete释放. 使用new分配一个数组, 相应使用delete []释放. 这二者的区别在于分配拿到的内存块布局不同, 需要调用相应的delete形式进行删除 尽量不要使用typedef一个数组, 可能造成delete不清楚它是一个数组而错用形式 使用数组尽量使用vector, 然后再在外面套一层智能指针 17.以独立语句将newed对象置入智能指针 下面的语句可能造成内存泄露, 因为函数调用时的实参到形参的转换的各部分代码执行顺序是不定的. 可能存在如注释处的执行顺序, 申请完Wdiget对象后, 执行fun时发生异常, 导致Widget不会被释放. 正确的做法是将new处代码单独放置一行\nvoid processWidget(std::share_ptr\u0026lt;Widget\u0026gt;(new Wdiget), fun()) {} // new Widget // fun() // std::share_ptr 设计与声明 18.让接口被正确使用 定义新类约束接口中的数据输入范围 重载操作符, 保证与内置类型一致 工厂函数返回share_ptr可以避免误用 19.设计class犹如设计type 设计class就是设计了一个新type, 需要多加小心, 然后给出了一系列注意点\n20.传递const引用代替值 值传递开销大, 形参的构造和析构 可以正确实现泛化 一般内置类型使用值传递, 并且内置类型占用空间小. 但是当对象占用空间小的时候, 却不一定适合使用值传递, 因为可能该对象有复杂的构造过程(stl中的容器) 引用实际上是指针 21.函数不返回对象引用 返回的引用指向local对象, 会导致从该函数退出后改引用指向已经释放的内存 以值方式返回对象, 让编译器负责优化 22.将成员变量声明为private 有多种好处\n避免牢记在成员后面要不要加括号 对成员变量提供更精确的控制, 可以只读访问, 读写访问 对日后变更影响小 23.使用non-member, non-friend函数替换member函数 考虑要调用该对象的一系列删除方法, 书中推荐第二个做法更好. 因为面向对象编程不仅仅说数据应该和操作函数绑定在一起, 更应该提高数据的封装性. 因为第二种做法每个在对象中增加可以访问数据的成员函数, 说明该方法有更高的封装性\nclass A { public: void clearEverything() {} } void clearEverything(A\u0026amp; a) { a.clearCache(); a.clearHistory(); a.removeCookies(); } 另外一个推荐的做法是, 把相关类似上面的这种工具函数按照类别放在不同的文件夹中, 但是和对象在同一个命名空间下\n24.所有参数皆需要类型转换, 采用non-member函数 有时候设计一个类表示数值类型时, 在重载运算符时需要所有参数支持隐式类型转换, 为了支持混合算术运算. 这时候成员函数形式的重载操作符不满足要求, 因为成员函数第一个参数是隐含的this, 该参数不能接受隐式类型转换(只有在参数列表中的参数才有可能接受隐式类型转换). 合理的做法是设计一个非成员版本的重载运算符\nRational oneHalf(1, 2); Rational result1 = oneHalf * 2; Rational result1 = 2 * oneHalf; // error 25.写出一个不抛异常的swap函数 普通的swap基于对象的copying函数\n但是有时候对象有特殊设计可以对swap操作进行优化. 比如在pimpl模型下, 实现swap仅仅交换pImpl指针就行 另外基于copying的swap容易抛出异常, 而自己实现的优化swap操作可能仅仅是交互内置类型, 一般不会抛出异常 namesapce std { template\u0026lt;typename T\u0026gt; void swap(T\u0026amp; a, T\u0026amp; b) { T temp(a); a = b; b = temp; } } ==这一条好像没咋看懂==\n具体有以下步骤\n写public的swap成员函数, 不应该抛出异常 同对象所在命名空间提供一个非成员swap, 里面调用对象成员swap 为对象特化std::swap, 调用对象的成员swap 实现 26.延后变量定义的出现时间 如果doSomething函数中没有使用变量a, 当该函数抛出异常的时候a承当了构造和析构成本. 但是将a定义挪到doSomething之后就没有这个问题\nvoid fun() { A a; doSomething(); return a; } 延后对象的定义时, 不仅仅需要尽量延后到使用该变量为止, 更应该延后到获得该对象初始化需要的初值. 因为方法一default构造一个对象, 再通过copy assignment合适的初始化. 方法二直接通过有参构造初始化对象. 一般来说后者比前者效率高\n27.尽量少做转型动作 理论上cpp程序通过编译后, 就不应该有类型错误. 但是实际开发中需要转型, 这也导致了类型错误出现的可能性\n有以下几种转型操作. 尽可能使用==c++风格转型==, 清晰易读, 由于细分为不同的转型编译器更容易识别出使用上的错误\n// c (T)expression; T(expression); // todo 这个也是转型吗, 感觉有时候也算是构造临时对象 //c++ const_cast\u0026lt;T\u0026gt;(expression); // 去掉const dynamic_cast\u0026lt;T\u0026gt;(expression); // 有继承关系的类之间的转型. 唯一旧式c方式无法实现, 并且唯一可能耗费巨大成本的转型 reinterpret_cast\u0026lt;T\u0026gt;(expression); // 低级转型. 实际动作取决于编译器, 使用它意味着代码不可移植 static_cast\u0026lt;T\u0026gt;(expression); // 强迫隐式类型转换 一个使用c旧式转型比较合适的场景\nclass A { public: explicit A(int size); } void fun(const A\u0026amp; a); fun(A(1));// 人们更喜欢这一种, 感觉上更像是生成临时对象, 而非转型 fun(static_const\u0026lt;A\u0026gt;(1)); 转型可能导致更多的运行成本. 下面显示了两种场景\nint a = 1; double b = a; // int与double的存储空间不同, 值在内存中的放置也不同, 编译器要生成转换的代码 class Derived: public Base1, Base2 {}; Derived d; Base2* pb = \u0026amp;d; // 由于在base1和base2在derived存储在不同部分, 将\u0026amp;d转换为pb可能涉及到指针偏移的计算 转型的一种错误用法. 在派生类中实现方法中先调用基类的方法, 在处理该派生类的部分\nclass Derived:public Base { void fun() { static\u0026lt;Window\u0026gt;(*this).fun(); // 由于*this实际上生成了一个base对象副本, 而没有修改改派生类上面的base部分 // Base::fun(); // 实际上应该这样使用 // static\u0026lt;Window*\u0026gt;(this)-\u0026gt;fun(); // todo 那这样可以正确调用基类部分的方法吗 // Derived dosomething } } dynamic_cast使用上开销比较大. 由于dynamic_cast的一个很普遍的实现版本, 是基于class的字符串名字进行依次比较. 需要dynamic_cast的一个场景是泛化为base的derived指针, 还原回derived指针, 以调用derived的特定方法. 解决方法是在base中定义一个什么也不做的同签名(与derived对象特定的函数)的virtual函数\n28.避免返回handle指向对象内部成分 const成员函数返回一个handle(指向成员变量的指针, 引用, 或者修改成员变量的函数指针)有多个问题\n不符合const成员函数的直觉, 值的调用方可以通过handle改变对象 改变成员变量的封装性, 由于外部可以通过handle直接改变指向的成员变量, 使得该成员变量从private变成了public 解决的一个简单方法是返回const handle, 但是这样也有问题\n可能造成悬垂引用, 对象内部可能已经销毁handle指向的对象, 但是外部可能还保留该handle, 并且使用它 有时候不得不返回handle, 比如为对象实现=运算符的时候\n29.努力实现异常安全代码 异常安全函数有不泄露资源和不损坏数据两个条件. 一下代码两个条件都不满足\nvoid A::fun(std::string imgSrc) { lock(\u0026amp;mutex); delete bgImage; ++imageChanges; bgImage = new Image(ImgSrc); // new失败后, bgImage指向的数据被删除 unlock(\u0026amp;mutex); // mutex没有被释放 } 异常安全有3个层次\n基本型, ==感觉数据没有完全被删除, 但是数据修改不完整(基本型式什么意思)== 强烈保证, 函数抛出异常后恢复到调用前的状态 不抛出异常 实现强烈保证的异常安全代码, 资源泄露容易通过RAII解决, 比如lock操作使用类封装, 但是数据损坏得通过swap操作, 生成了stack上的临时对象(抛出异常时自动销毁), 在这个临时对象上做修改, 然后swap(要求swap是异常安全的)本身对象和临时对象\nvoid A::fun(std::string imgSrc) { Lock lock(\u0026amp;mutex); Image temp(imgSrc); swap(temp, bgImage); } 但是swap操作带来的高开销和函数内一些其他函数调用的低异常安全保证, 使我们可能不使代码有强烈安全保证\n30.了解inlining inline函数, 定义在class内的成员函数, 默认inline. 可以在函数外添加inline修饰符.\n优点\n像宏一样直接展开函数, 没有调用上的开销, 但是使用代码编写上比宏安全一些 缺点\n但是增加最后代码大小, 可能导致额外的换页行为, 降低缓存的命中率, 带来效率上损失 一般当函数本体比较小而本体简单的时候, 比较适合inline 一旦inline函数有改变, 所有调用该函数的代码都要重新编译. 如果是普通函数, 只需要重新链接 调试器无法处理inline函数 由于在inline是在编译期实现的, 所有需要inline函数完整定义, 而非声明 inline修饰函数只是推荐编译器将该函数inline, 但是某些情况下编译器不能inline函数\n该函数有递归调用 其他地方有使用该函数的指针 31.将文件的编译依存关系降到最低 由于cpp既支持原始类型, 又支持指针和引用. 头文件class的声明中也可能需要对象定义细节(编译器需要确定对象占用的空间大小, 所有需要对象的定义), 需要包含其他对象的头文件, 进而导致之前导入的头文件中些许改变, 所有导入该class声明的头文件的文件需要重新编译. 在其他语言python和java这不是个问题, 因为所有的对象只能通过指针支持, 并且对象都在heap上分配.\n一个解决办法是, 尽量使用对象的指针或者引用, 因为指针的大小是固定的, 对象指针可以通过简单的前向声明解决编译错误\n进一步有所谓的==pimpl模式==, 成员数据保存在另一个对impl对象中(==除了保存数据还会做什么==), 原对象仅仅包含成员函数声明和一个指向impl对象指针的成员变量声明 ==为声明式和定义式提供不同的头文件, 模板也能分为定义和声明== 但是每次成员函数调用都要增加一次解指针操作, impl对象内存动态分配 另一种解决办法是使用接口类, 类中所有的成员函数都是纯虚函数\n由于都是虚函数, 同样需要一层对虚表的简介访问, 另外需要额外的空间存储虚表指针 以上两种方法虽然可降低声明和实现的依赖, 但是带来性能上的消耗, 需要有选择使用\n面向对象设计 32.public继承表示is a关系 public可以实现is a关系. is a关系表示基类可以做的事情, 派生类也一定可以做, 但是反之不成立\n==鸭子型面向对象, 编译型和运行型实现==\n==展示了一个有趣例子, 说明派生类不能像基类那样==\n33.避免遮掩继承而来的名称 在文件中函数作用域的变量会遮蔽全局作用域的变量, 尽管这些变量是不同的类型\ndobule x = 1; void fun() { int x = 2; std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } 在继承的类中也是如此, 如果基类中fun不是虚函数, 而派生类中也定义了fun函数, 派生类中的fun会遮蔽基类)(不管函数签名如何), 使得public 继承带来的is a关系不能成立. 有以下方法解决\nclass Base { public: void fun(int x) {} } class Derived: public Base { public: using Base::fun; // 方法1, 是外部可见 void fun() {} } class Derived: public Base { public: void fun() {Base::fun();} // 方法2, 转交函数, 为旧式编译器上避免变量遮蔽的方法 } ==todo, 子类遮蔽和函数重载和虚函数==\n34.区分接口继承和实现继承 在public继承下\n基类的纯virtual函数, 相当于派生类只继承接口需要自己实现 基类的virtual函数, 相当于派生类继承接口和默认实现, 也可以自己更改实现 基类的普通函数, 相当于派生列继承接口和实现, 不应该改变该函数实现 当基类有virtual函数时, 派生类可能并不想要默认实现, 但是忘记自定义实现带来错误. 以下方法可以强制派生类选择实现\n// 方法1 class A{ public: virtual void fun() = 0; void defaultFun(); } class B: A { public: void fun() { defaultFun(); } } // 方法2 class A{ public: virtual void fun() = 0; } void A::fun() {} class B: A { public: void fun() { A::fun(); } } 35.考虑virtual函数之外的其他选择 将public virtual函数变成private virtual函数, 再定义一个public函数调用private virtual, 这种方法被称为==non virtual interface(NVI)==, 同时这种操作也实现了设计模式中的模板方法模式 传统策略模式通过动态传入一个策略类实现应用不同策略, 策略类中有要执行的虚函数. 代替传入一个函数指针实现策略模式 36.绝不重新定义继承而来的non virtual函数 简而言之如果D中重新定义了fun, pb和pd调用fun都是各自定义的fun\nclass B { public: void fun(); } class D:B { public: void fun(); } D d; D* pd = \u0026amp;d; B* pb = \u0026amp;d; ==不清楚为什么不能==\n37.绝不重新定义继承而来的缺省参数值 简而言之, 虚函数中最好不要定义默认参数. 由于默认参数处于执行效率的考虑是静态绑定, 而虚函数调用是动态绑定. 可能出现如下情况, 调用的fun可能出乎意料\nclass A { public: virtual void draw(Color color=\u0026#34;red\u0026#34;) const {} } class B { public: virtual void draw(Color color) {} } A* pa = new B(); pa-\u0026gt;fun(\u0026#34;green\u0026#34;); // 调用B::fun pa-\u0026gt;fun(); // 调用A::fun ==默认参数再声明和定义, 默认参数与函数重载的关系==\n38.通过复合构造has a 对象分为两种, 一种对象可以直接对应现实世界中的事物, 另一种只是软件层面上的东西, 比如互斥器等. 前者比较好区分is a与has a关系, 但是后者不好区分is a与has a关系, 后者的has a也能叫做is implemented in terms of(根据某物实现出)\n==没太看懂==\n39.谨慎使用private继承 private可以和组合一样实现is implemented in terms of关系\n==例子没看懂==\n40.谨慎使用多重继承 缺点一, 可能继承而来的多个基类中相同的成员函数, 造成歧义 ==有调用private成员函数的例子没有看懂== 缺点二, 菱形继承例子中造成空间浪费, 但是可用虚继承解决, 但是虚继承带来额外的开销 ==对象模型上虚继承的细节== 多重继承也有优点, 举得例子类似java中可以组合多个接口 泛型编程 41.了解隐式接口和编译期多态 class相当于实现了显示接口(类成员函数定义)和运行期多态(运行时才能确定是哪一个类的虚函数), template相当于实现了隐式接口(只能知道要调用一个类型的那些操作)和编译期多态\n42.了解typename的双重意义 在声明模板参数的时候class与typename没有差别 但是在内部typename用于指出一个模板参数内的名称是类型, 而非其他东西 ==有指出的必要吗, 不能等到实例化的时候一起确定吗== template \u0026lt;typename T\u0026gt; void fun(T x) { typename T::const_iterator* y; } ==typename不能用在base class list和member initialization list中== 43.学习处理模板化基类内的名称 ==没看懂==\n在模板化派生类中调用基类成员不能通过编译, 有以下三种方法可以改变\nthis指针明显调用 using 基类调用 编译器诊断可以发生在早期, 模板定义时, 也可以发生在晚期, 模板实例化时\n44.将于参数无关的代码抽离template 45.运用模板参数接受所有兼容类型 std::share_ptr\u0026lt;Top\u0026gt; tp = std::share_ptr\u0026lt;Middle\u0026gt;(new Middle); ==成员函数模板==\n46.需要类型转换时为模板定义非成员函数 47.使用traits class表现类型信息 展示了stl中算法库advance例子使用type trait和函数重载实现编译期的type上if else\n用户类中定义trait class规定的类型 内部类使用trait class从用户类中获取类型信息, 再利用函数重载 48.template模板元编程 ==略==\n定制new和delete 49.了解new handler ","permalink":"https://uhuuh.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-effective-c++/","summary":"让自己习惯c++ 1.c++是一个语言联邦 c++支持多种编程泛型, 面向过程, 基于对象, 面向对象, 泛型, 元编程\nc++可以视为一个语言联邦, 由以下四个部分组成\nc object oriented c++ template c++ stl 2.替换define 当define一个常量时, 调试不方便, 只剩下数值没有原来的变量名信息\n使用const定义全局常量 使用const在类中定义常量 class A { private: static const double a; // 声明, static确保所有类只有一份该变量 } const double A::a = 1.35; // static成员变量必须在类外定义 - 旧式编译器不支持static成员变量在声明时获得初值\rclass A{ private: static const double a; } const double A::a = 1.35; - 然后再类编译又需要一个常量值时(比如确定数组的大小), 可以使用enum hack技术. enum和define有很多相似的地方, enum最后会被替换成int, enum不能取地址\rclass A{ private: enum {n = 5}; int arr[n]; } 当define一个函数时, 写起来很麻烦, 而且容易出错","title":"读书笔记 effective C++"}]